<!DOCTYPE html>
<html lang="en" dir="ltr">

<head prefix="og: http://ogp.me/ns#">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>程序构成-第二章 – Will&#39;s Blog</title>
    


<script src="/blog/js/enquire.min.dfb99dee1e029d51d6cfb672d847929890b1585402de17f5ed092edd72a688b4.js"></script>

<script defer src="/blog/js/lazysizes.min.31dd6a2d3a1ec0f78a8df007535cf23f03aeb5c70f026e6d6a19dac3b3acc340.js"></script>

<script defer src="/blog/js/fuse.min.94c78ad70b02749822921660cf4e9f0b3701bc0680c421afb784a78228de0275.js"></script>

<script defer src="/blog/js/helper/getParents.min.1618c696be7c98933f9a92677f518b512a74e55bdbb976b09936b4182e93181b.js"></script>

<script defer src="/blog/js/helper/fadeinout.min.93a331f96194789a542f33690bbe4f0c102c7e78ffc018217f5a1c33010bad91.js"></script>

<script defer src="/blog/js/helper/closest.min.js"></script>
  
<script>
  "use strict";

  
  
  if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
  }

  
  if (!String.prototype.includes) {
    String.prototype.includes = function (search, start) {
      'use strict';

      if (search instanceof RegExp) {
        throw TypeError('first argument must not be a RegExp');
      }
      if (start === undefined) { start = 0; }
      return this.indexOf(search, start) !== -1;
    };
  }

  
  Document.prototype.append = Element.prototype.append = function append() {
    this.appendChild(_mutation(arguments));
  };
  function _mutation(nodes) {
    if (!nodes.length) {
      throw new Error('DOM Exception 8');
    } else if (nodes.length === 1) {
      return typeof nodes[0] === 'string' ? document.createTextNode(nodes[0]) : nodes[0];
    } else {
      var
      fragment = document.createDocumentFragment(),
      length = nodes.length,
      index = -1,
      node;

      while (++index < length) {
        node = nodes[index];

        fragment.appendChild(typeof node === 'string' ? document.createTextNode(node) : node);
      }

      return fragment;
    }
  }

  
  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (searchString, position) {
      position = position || 0;
      return this.indexOf(searchString, position) === position;
    };
  }
  


  document.addEventListener('DOMContentLoaded', function () {
    
    var navCollapseBtn = document.querySelector('.navbar__burger');
    navCollapseBtn ? navCollapseBtn.addEventListener('click', function (e) {
      var navCollapse = document.querySelector('.navbarm__collapse');

      if (navCollapse) {
        var dataOpen = navCollapse.getAttribute('data-open');

        if (dataOpen === 'true') {
          navCollapse.setAttribute('data-open', 'false');
          navCollapse.style.maxHeight = 0;
          navCollapseBtn.classList.remove('is-active');
        } else {
          navCollapse.setAttribute('data-open', 'true');
          navCollapse.style.maxHeight = navCollapse.scrollHeight + "px";
          navCollapseBtn.classList.add('is-active');
        }
      }
    }) : null;
    


    
    var summaryContainer = document.querySelector('.summary__container');
    var searchResult = document.querySelector('.search-result');
    var searchResultCloseBtn = document.querySelector('.search-result__close');
    searchResultCloseBtn ? searchResultCloseBtn.addEventListener('click', function (e) {
      searchResult.setAttribute('data-display', 'none');
      summaryContainer.setAttribute('data-display', 'block');
    }) : null;
    


    
    document.querySelectorAll('.tab') ? 
    document.querySelectorAll('.tab').forEach(function(elem, idx) {
      var containerId = elem.getAttribute('id');
      var containerElem = elem;
      var tabLinks = elem.querySelectorAll('.tab__link');
      var tabContents = elem.querySelectorAll('.tab__content');
      var ids = [];

      tabLinks && tabLinks.length > 0 ?
      tabLinks.forEach(function(link, index, self) {
        link.onclick = function(e) {
          for (var i = 0; i < self.length; i++) {
            if (index === parseInt(i, 10)) {
              if (!self[i].classList.contains('active')) {
                self[i].classList.add('active');
                tabContents[i].style.display = 'block';
              }
            } else {
              self[i].classList.remove('active');
              tabContents[i].style.display = 'none';
            }
          }
        }
      }) : null;
    }) : null;
    


    
    document.querySelectorAll('.codetab') ? 
    document.querySelectorAll('.codetab').forEach(function(elem, idx) {
      var containerId = elem.getAttribute('id');
      var containerElem = elem;
      var codetabLinks = elem.querySelectorAll('.codetab__link');
      var codetabContents = elem.querySelectorAll('.codetab__content');
      var ids = [];

      codetabLinks && codetabLinks.length > 0 ?
      codetabLinks.forEach(function(link, index, self) {
        link.onclick = function(e) {
          for (var i = 0; i < self.length; i++) {
            if (index === parseInt(i, 10)) {
              if (!self[i].classList.contains('active')) {
                self[i].classList.add('active');
                codetabContents[i].style.display = 'block';
              }
            } else {
              self[i].classList.remove('active');
              codetabContents[i].style.display = 'none';
            }
          }
        }
      }) : null;
    }) : null;
    


    
    var gttBtn = document.getElementById("gtt");
    gttBtn.style.display = "none";
    gttBtn.addEventListener('click', function () {
      if (window.document.documentMode) {
        document.documentElement.scrollTop = 0;
      } else {
        scrollToTop(250);
      }
    });

    function scrollToTop(scrollDuration) {
      var scrollStep = -window.scrollY / (scrollDuration / 15);
      var scrollInterval = setInterval(function () {
        if (window.scrollY != 0) {
          window.scrollBy(0, scrollStep);
        }
        else clearInterval(scrollInterval);
      }, 15);
    }

    var scrollFunction = function () {
      if (document.body.scrollTop > 250 || document.documentElement.scrollTop > 250) {
        gttBtn.style.display = "block";
      } else {
        gttBtn.style.display = "none";
      }
    }
    


    
    var expandBtn = document.querySelectorAll('.expand__button');

    for (let i = 0; i < expandBtn.length; i++) {
      expandBtn[i].addEventListener("click", function () {
        var content = this.nextElementSibling;
        if (content.style.maxHeight) {
          content.style.maxHeight = null;
          this.querySelector('svg').classList.add('expand-icon__right');
          this.querySelector('svg').classList.remove('expand-icon__down');
        } else {
          content.style.maxHeight = content.scrollHeight + "px";
          this.querySelector('svg').classList.remove('expand-icon__right');
          this.querySelector('svg').classList.add('expand-icon__down');
        }
      });
    }
    


    
    var lastScrollTop = window.pageYOffset || document.documentElement.scrollTop;
    var tocElem = document.querySelector('.toc');
    var tableOfContentsElem = tocElem ? tocElem.querySelector('#TableOfContents') : null;
    var toggleTocElem = document.getElementById('toggle-toc');
    var singleContentsElem = document.querySelector('.single__contents');
    var navbar = document.querySelector('.navbar');
    var tocFlexbox = document.querySelector('.toc__flexbox');
    var tocFlexboxOuter = document.querySelector('.toc__flexbox--outer');
    var expandContents = document.querySelectorAll('.expand__content');
    var boxContents = document.querySelectorAll('.box');
    var notAllowedTitleIds = null;

    
    var tocFolding = JSON.parse("false");
    
    var tocLevels = JSON.parse("[\"h2\",\"h3\",\"h4\"]");
    
    if (tocLevels) {
      tocLevels = tocLevels.toString();
    } else {
      tocLevels = "h1, h2, h3, h4, h5, h6";
    }

    
    singleContentsElem && singleContentsElem.querySelectorAll(".tab") ?
    singleContentsElem.querySelectorAll(".tab").forEach(function (elem) {
      elem.querySelectorAll(tocLevels).forEach(function (element) {
        notAllowedTitleIds = Array.isArray(notAllowedTitleIds) ?
          notAllowedTitleIds.concat(element.getAttribute('id')) :
          [element.getAttribute('id')];
      });
    }) : null;

    
    expandContents ? expandContents.forEach(function(elem) {
      elem.querySelectorAll(tocLevels).forEach(function (element) {
        notAllowedTitleIds = Array.isArray(notAllowedTitleIds) ?
          notAllowedTitleIds.concat(element.getAttribute('id')) :
          [element.getAttribute('id')];
      });
    }) : null;

    
    boxContents ? boxContents.forEach(function(elem) {
      elem.querySelectorAll(tocLevels).forEach(function (element) {
        notAllowedTitleIds = Array.isArray(notAllowedTitleIds) ?
          notAllowedTitleIds.concat(element.getAttribute('id')) :
          [element.getAttribute('id')];
      });
    }) : null;

    
    window.onscroll = function () {
      scrollFunction();
      
      var st = window.pageYOffset || document.documentElement.scrollTop;
      if (st > lastScrollTop) { 
        if (st < 250) {
          gttBtn.style.display = "none";
        } else {
          gttBtn.style.display = "block";
        }

        if (st < 45) {
          return null;
        }
        
        if (!navbar.classList.contains('navbar--hide')) {
          navbar.classList.add('navbar--hide');
        } else if (navbar.classList.contains('navbar--show')) {
          navbar.classList.remove('navbar--show');
        }

        if (singleContentsElem) {
          if (singleContentsElem.querySelectorAll(tocLevels).length > 0) {
            singleContentsElem.querySelectorAll(tocLevels).forEach(function (elem) {
              if (toggleTocElem && !toggleTocElem.checked) {
                return null;
              }

              if (notAllowedTitleIds && notAllowedTitleIds.includes(elem.getAttribute('id'))) {
                return null;
              }
              
              if (document.documentElement.scrollTop >= elem.offsetTop) {
                if (tableOfContentsElem) {
                  var id = elem.getAttribute('id');
                  tocElem.querySelectorAll('a').forEach(function (elem) {
                    elem.classList.remove('active');
                  });
                  tocElem.querySelector('a[href="#' + id + '"]') ?
                    tocElem.querySelector('a[href="#' + id + '"]').classList.add('active') : null;

                  if (false === tocFolding) {
                    
                  } else {
                    tableOfContentsElem.querySelectorAll('ul') ?
                      tableOfContentsElem.querySelectorAll('ul').forEach(function (rootUl) {
                        rootUl.querySelectorAll('li').forEach(function (liElem) {
                          liElem.querySelectorAll('ul').forEach(function (ulElem) {
                            ulElem.style.display = 'none';
                          });
                        });
                      }) : null;
                  }

                  var curElem = tableOfContentsElem.querySelector("[href='#" + id + "']");
                  if (curElem && curElem.nextElementSibling) {
                    curElem.nextElementSibling.style.display = 'block';
                  }
                  getParents(curElem, 'ul') ?
                    getParents(curElem, 'ul').forEach(function (elem) {
                      elem.style.display = 'block';
                    }) : null;
                }
              }
            });
          } else {
            if (tocFlexbox) {
              tocFlexbox.setAttribute('data-position', '');
              if (!tocFlexbox.classList.contains('hide')) {
                tocFlexbox.classList.add('hide');
              }
            }
            if (tocFlexboxOuter) {
              tocFlexboxOuter.setAttribute('data-position', '');
              if (!tocFlexboxOuter.classList.contains('hide')) {
                tocFlexboxOuter.classList.add('hide');
              }
            }
          }
        }
      } else { 
        if (st < 250) {
          gttBtn.style.display = "none";
        }

        if (navbar.classList.contains('navbar--hide')) {
          navbar.classList.remove('navbar--hide');
        } else if (!navbar.classList.contains('navbar--show')) {
          navbar.classList.add('navbar--show');
        }

        if (singleContentsElem) {
          if (singleContentsElem.querySelectorAll(tocLevels).length > 0) {
            singleContentsElem.querySelectorAll(tocLevels).forEach(function (elem) {
              if (toggleTocElem && !toggleTocElem.checked) {
                return null;
              }
              
              if (notAllowedTitleIds && notAllowedTitleIds.includes(elem.getAttribute('id'))) {
                return null;
              }

              if (document.documentElement.scrollTop >= elem.offsetTop) {
                if (tableOfContentsElem) {
                  var id = elem.getAttribute('id');
                  tocElem.querySelectorAll('a').forEach(function (elem) {
                    elem.classList.remove('active');
                  });
                  tocElem.querySelector('a[href="#' + id + '"]') ?
                    tocElem.querySelector('a[href="#' + id + '"]').classList.add('active') : null;

                  if (false === tocFolding) {
                    
                  } else {
                    tableOfContentsElem.querySelectorAll('ul') ?
                      tableOfContentsElem.querySelectorAll('ul').forEach(function (rootUl) {
                        rootUl.querySelectorAll('li').forEach(function (liElem) {
                          liElem.querySelectorAll('ul').forEach(function (ulElem) {
                            ulElem.style.display = 'none';
                          });
                        });
                      }) : null;
                  }

                  var curElem = tableOfContentsElem.querySelector("[href='#" + id + "']");
                  if (curElem && curElem.nextElementSibling) {
                    curElem.nextElementSibling.style.display = 'block';
                  }
                  getParents(curElem, 'ul') ?
                    getParents(curElem, 'ul').forEach(function (elem) {
                      elem.style.display = 'block';
                    }) : null;
                }
              }
            });
          } else {
            if (tocFlexbox && !tocFlexbox.classList.contains('hide')) {
              tocFlexbox.classList.add('hide');
            }
            if (tocFlexboxOuter && !tocFlexboxOuter.classList.contains('hide')) {
              tocFlexboxOuter.classList.add('hide');
            }
          }
          
        }

        if (tableOfContentsElem && document.documentElement.scrollTop < 250) {
          if (false === tocFolding) {

          } else {
            tableOfContentsElem.querySelector('ul') ?
              tableOfContentsElem.querySelector('ul').querySelectorAll('li').forEach(function (liElem) {
                liElem.querySelectorAll('ul').forEach(function (ulElem) {
                  ulElem.style.display = 'none';
                });
              }) : null;
          }
        }
      }
      lastScrollTop = st <= 0 ? 0 : st;
    };
  


  
    var localTheme = localStorage.getItem('theme');
    var rootEleme = document.getElementById('root');
    var selectThemeElem = document.querySelectorAll('.select-theme');
    var selectThemeItemElem = document.querySelectorAll('.select-theme__item');

    var setMetaColor = function(themeColor) {
      var metaMsapplicationTileColor = document.getElementsByName('msapplication-TileColor')[0];
      var metaThemeColor = document.getElementsByName('theme-color')[0];
      var metaMsapplicationNavbuttonColor = document.getElementsByName('msapplication-navbutton-color')[0];
      var metaAppleMobileWebAappStatusBarStyle = document.getElementsByName('apple-mobile-web-app-status-bar-style')[0];

      if (themeColor.includes('dark')) {
        metaMsapplicationTileColor.setAttribute('content', '#fcfcfa');
        metaThemeColor.setAttribute('content', '#403E41');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#403E41');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#403E41');
      } else if (themeColor.includes('light')) {
        metaMsapplicationTileColor.setAttribute('content', '#555');
        metaThemeColor.setAttribute('content', '#eee');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#eee');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#eee');
      } else if (themeColor.includes('hacker')) {
        metaMsapplicationTileColor.setAttribute('content', '#e3cd26');
        metaThemeColor.setAttribute('content', '#252526');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#252526');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#252526');
      } else if (themeColor.includes('solarized')) {
        metaMsapplicationTileColor.setAttribute('content', '#d3af86');
        metaThemeColor.setAttribute('content', '#51412c');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#51412c');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#51412c');
      } else if (themeColor.includes('kimbie')) {
        metaMsapplicationTileColor.setAttribute('content', '#586e75');
        metaThemeColor.setAttribute('content', '#eee8d5');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#eee8d5');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#eee8d5');
      } 
    }
    
    if (localTheme) {
      selectThemeItemElem ? 
      selectThemeItemElem.forEach(function (elem) {
        if (elem.text.trim() === localTheme) {
          elem.classList.add('is-active');
        } else {
          elem.classList.remove('is-active');
        }
      }) : null;

      setMetaColor(localTheme);
    } else {
      setMetaColor(rootEleme.className);
    }

    selectThemeItemElem ? 
    selectThemeItemElem.forEach(function (v, i) {
      v.addEventListener('click', function (e) {
        var selectedThemeVariant = e.target.text.trim();
        localStorage.setItem('theme', selectedThemeVariant);
        setMetaColor(selectedThemeVariant);

        rootEleme.removeAttribute('class');
        rootEleme.classList.add('theme__' + selectedThemeVariant);
        selectThemeElem.forEach(function(rootElem) {
          rootElem.querySelectorAll('a').forEach(function (elem) {
            if (elem.classList) {
              if (elem.text.trim() === selectedThemeVariant) {
                if (!elem.classList.contains('is-active')) {
                  elem.classList.add('is-active');
                }
              } else {
                if (elem.classList.contains('is-active')) {
                  elem.classList.remove('is-active');
                }
              }
            }
          });
        });

        if (window.mermaid) {
          if (selectedThemeVariant === "dark" || selectedThemeVariant === "hacker") {
            mermaid.initialize({ theme: 'dark' });
            location.reload();
          } else {
            mermaid.initialize({ theme: 'default' });
            location.reload();
          }
        }

        var utterances = document.getElementById('utterances');
        if (utterances) {
          utterances.querySelector('iframe').contentWindow.postMessage({
            type: 'set-theme',
            theme: selectedThemeVariant === "dark" || selectedThemeVariant === "hacker" ? 'photon-dark' : selectedThemeVariant === 'kimbie' ? 'github-dark-orange' : 'github-light',
          }, 'https://utteranc.es');
        }

        var twitterCards = document.querySelectorAll('.twitter-timeline');
        if (twitterCards) {
          window.postMessage({
            type: 'set-twitter-theme',
            theme: selectedThemeVariant === 'light' || selectedThemeVariant === 'solarized' ? 'light' : 'dark',
          });
        }
      });
    }) : null;
  


  
    
    var permalink = JSON.parse("\"https://jmwill.github.io/blog/2017/06/11/%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90-%E7%AC%AC%E4%BA%8C%E7%AB%A0/\"");
    var searchResults = null;
    var searchMenu = null;
    var searchText = null;
    
    
    var enableSearchHighlight = JSON.parse("true");
    
    var searchResultPosition = JSON.parse("null");
    
    var sectionType = JSON.parse("\"posts\"");

    var fuse = null;

    (function initFuse() {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', permalink + "index.json");
      xhr.setRequestHeader('Content-Type', 'application/json; charset=utf-8');
      xhr.onload = function () {
        if (xhr.status === 200) {
          fuse = new Fuse(JSON.parse(xhr.response.toString('utf-8')), {
            keys: sectionType.includes('publication') ? ['title', 'abstract'] : ['title', 'description', 'content'],
            includeMatches: enableSearchHighlight,
            shouldSort: true,
            threshold: 0.4,
            location: 0,
            distance: 100,
            maxPatternLength: 32,
            minMatchCharLength: 1,
          });
          window.fuse = fuse;
        }
        else {
          console.error('[' + xhr.status + ']Error:', xhr.statusText);
        }
      };
      xhr.send();
    })();

    function makeLi(ulElem, obj) {
      var li = document.createElement('li');
      li.className = 'search-result__item';
      
      var a = document.createElement('a');
      a.innerHTML = obj.title;
      a.setAttribute('class', 'search-result__item--title');
      a.setAttribute('href', obj.permalink);

      var descDiv = document.createElement('div');
      descDiv.setAttribute('class', 'search-result__item--desc');
      if (obj.description) {
        descDiv.innerHTML = obj.description;
      } else if (obj.content) {
        descDiv.innerHTML = obj.content.substring(0, 225);
      }
      
      li.appendChild(a);
      li.appendChild(descDiv);
      ulElem.appendChild(li);
    }

    function makeHighlightLi(ulElem, obj) {
      var li = document.createElement('li');
      li.className = 'search-result__item';
      var descDiv = null;

      var a = document.createElement('a');
      a.innerHTML = obj.item.title;
      a.setAttribute('class', 'search-result__item--title');
      a.setAttribute('href', obj.item.uri);

      if (obj.matches && obj.matches.length) {
        for (var i = 0; i < obj.matches.length; i++) {
          if ('title' === obj.matches[i].key) {
            a = document.createElement('a');
            a.innerHTML = generateHighlightedText(obj.matches[i].value, obj.matches[i].indices);
            a.setAttribute('class', 'search-result__item--title');
            a.setAttribute('href', obj.item.uri);
          }
          
          if ('description' === obj.matches[i].key) {
            descDiv = document.createElement('div');
            descDiv.setAttribute('class', 'search-result__item--desc');
            descDiv.innerHTML = generateHighlightedText(obj.item.description, obj.matches[i].indices);
          } else if ('content' === obj.matches[i].key) {
            if (!descDiv) {
              descDiv = document.createElement('div');
              descDiv.setAttribute('class', 'search-result__item--desc');
              descDiv.innerHTML = generateHighlightedText(obj.item.content.substring(0, 150), obj.matches[i].indices);
            }
          } else {
            if (obj.item.description) {
              descDiv = document.createElement('div');
              descDiv.setAttribute('class', 'search-result__item--desc');
              descDiv.innerHTML = obj.item.description;
            } else {
              descDiv = document.createElement('div');
              descDiv.setAttribute('class', 'search-result__item--desc');
              descDiv.innerHTML = obj.item.content.substring(0, 150);
            }
          }
        }

        li.appendChild(a);
        if (descDiv) {
          li.appendChild(descDiv);
        }
        if (li) {
          ulElem.appendChild(li);
        }
      }
    }

    function renderSearchResultsSide(searchText, results) {
      searchResults = document.getElementById('search-results');
      searchMenu = document.getElementById('search-menu');
      searchResults.setAttribute('class', 'dropdown is-active');
      
      var ul = document.createElement('ul');
      ul.setAttribute('class', 'dropdown-content search-content');

      if (results.length) {
        results.forEach(function (result) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          a.setAttribute('href', result.uri);
          a.setAttribute('class', 'dropdown-item');
          a.appendChild(li);

          var titleDiv = document.createElement('div');
          titleDiv.innerHTML = result.title;
          titleDiv.setAttribute('class', 'menu-item__title');

          var descDiv = document.createElement('div');
          descDiv.setAttribute('class', 'menu-item__desc');
          if (result.description) {
            descDiv.innerHTML = result.description;
          } else if (result.content) {
            descDiv.innerHTML = result.content.substring(0, 150);
          }

          li.appendChild(titleDiv);
          li.appendChild(descDiv);
          ul.appendChild(a);
        });
      } else {
        var li = document.createElement('li');
        li.setAttribute('class', 'dropdown-item');
        li.innerText = 'No results found';
        ul.appendChild(li);
      }

      while (searchMenu.hasChildNodes()) {
        searchMenu.removeChild(
          searchMenu.lastChild
        );
      }
      
      searchMenu.appendChild(ul);
    }

    function renderSearchHighlightResultsSide(searchText, results) {
      searchResults = document.getElementById('search-results');
      searchMenu = document.getElementById('search-menu');
      searchResults.setAttribute('class', 'dropdown is-active');

      var ul = document.createElement('ul');
      ul.setAttribute('class', 'dropdown-content search-content');

      if (results.length) {
        results.forEach(function (result) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          var descDiv = null;

          a.setAttribute('href', result.item.uri);
          a.setAttribute('class', 'dropdown-item');
          a.appendChild(li);

          var titleDiv = document.createElement('div');
          titleDiv.innerHTML = result.item.title;
          titleDiv.setAttribute('class', 'menu-item__title');
          
          if (result.matches && result.matches.length) {
            for (var i = 0; i < result.matches.length; i++) {
              if ('title' === result.matches[i].key) {
                titleDiv.innerHTML = generateHighlightedText(result.matches[i].value, result.matches[i].indices);
              }

              if ('description' === result.matches[i].key) {
                descDiv = document.createElement('div');
                descDiv.setAttribute('class', 'menu-item__desc');
                descDiv.innerHTML = generateHighlightedText(result.item.description, result.matches[i].indices);
              } else if ('content' === result.matches[i].key) {
                if (!descDiv) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'menu-item__desc');
                  descDiv.innerHTML = generateHighlightedText(result.item.content.substring(0, 150), result.matches[i].indices);
                }
              } else {
                if (result.item.description) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'menu-item__desc');
                  descDiv.innerHTML = result.item.description;
                } else {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'menu-item__desc');
                  descDiv.innerHTML = result.item.content.substring(0, 150);
                }
              }
            }
            
            li.appendChild(titleDiv);
            if (descDiv) {
              li.appendChild(descDiv);
            }
            ul.appendChild(a);
          }
        });
      } else {
        var li = document.createElement('li');
        li.setAttribute('class', 'dropdown-item');
        li.innerText = 'No results found';
        ul.appendChild(li);
      }

      while (searchMenu.hasChildNodes()) {
        searchMenu.removeChild(
          searchMenu.lastChild
        );
      }
      searchMenu.appendChild(ul);
    }

    function renderSearchResultsMobile(searchText, results) {
      searchResults = document.getElementById('search-mobile-results');

      var content = document.createElement('div');
      content.setAttribute('class', 'mobile-search__content');

      if (results.length > 0) {
        results.forEach(function (result) {
          var item = document.createElement('a');
          item.setAttribute('href', result.uri);
          item.innerHTML = '<div class="mobile-search__item"><div class="mobile-search__item--title">📄 ' + result.title + '</div><div class="mobile-search__item--desc">' + (result.description ? result.description : result.content) + '</div></div>';
          content.appendChild(item);
        });
      } else {
        var item = document.createElement('span');
        content.appendChild(item);
      }

      let wrap = document.getElementById('search-mobile-results');
      while (wrap.firstChild) {
        wrap.removeChild(wrap.firstChild)
      }
      searchResults.appendChild(content);      
    }

    function renderSearchHighlightResultsMobile(searchText, results) {
      searchResults = document.getElementById('search-mobile-results');

      var ul = document.createElement('div');
      ul.setAttribute('class', 'mobile-search__content');

      if (results.length) {
        results.forEach(function (result) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          var descDiv = null;

          a.setAttribute('href', result.item.uri);
          a.appendChild(li);
          li.setAttribute('class', 'mobile-search__item');

          var titleDiv = document.createElement('div');
          titleDiv.innerHTML = result.item.title;
          titleDiv.setAttribute('class', 'mobile-search__item--title');
          
          if (result.matches && result.matches.length) {
            for (var i = 0; i < result.matches.length; i++) {
              if ('title' === result.matches[i].key) {
                titleDiv.innerHTML = generateHighlightedText(result.matches[i].value, result.matches[i].indices);
              }

              if ('description' === result.matches[i].key) {
                descDiv = document.createElement('div');
                descDiv.setAttribute('class', 'mobile-search__item--desc');
                descDiv.innerHTML = generateHighlightedText(result.item.description, result.matches[i].indices);
              } else if ('content' === result.matches[i].key) {
                if (!descDiv) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'mobile-search__item--desc');
                  descDiv.innerHTML = generateHighlightedText(result.item.content.substring(0, 150), result.matches[i].indices);
                }
              } else {
                if (result.item.description) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'mobile-search__item--desc');
                  descDiv.innerHTML = result.item.description;
                } else {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'mobile-search__item--desc');
                  descDiv.innerHTML = result.item.content.substring(0, 150);
                }
              }
            }
            
            li.appendChild(titleDiv);
            if (descDiv) {
              li.appendChild(descDiv);
            }
            ul.appendChild(a);
          }
        });
      } else {
        var item = document.createElement('span');
        ul.appendChild(item);
      }

      let wrap = document.getElementById('search-mobile-results');
      while (wrap.firstChild) {
        wrap.removeChild(wrap.firstChild)
      }
      searchResults.appendChild(ul);
    }

    function generateHighlightedText(text, regions) {
      if (!regions) {
        return text;
      }

      var content = '', nextUnhighlightedRegionStartingIndex = 0;

      regions.forEach(function(region) {
        if (region[0] === region[1]) {
          return null;
        }
        
        content += '' +
          text.substring(nextUnhighlightedRegionStartingIndex, region[0]) +
          '<span class="search__highlight">' +
            text.substring(region[0], region[1] + 1) +
          '</span>' +
        '';
        nextUnhighlightedRegionStartingIndex = region[1] + 1;
      });

      content += text.substring(nextUnhighlightedRegionStartingIndex);

      return content;
    };

    var searchElem = document.getElementById('search');
    var searchMobile = document.getElementById('search-mobile');
    var searchResultsContainer = document.getElementById('search-results');

    searchElem ?
    searchElem.addEventListener('input', function(e) {
      if (!e.target.value | window.innerWidth < 770) {
        searchResultsContainer ? searchResultsContainer.setAttribute('class', 'dropdown') : null;
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
        return null;
      }

      searchText = e.target.value;
      var results = fuse.search(e.target.value);
      
      if (searchResultPosition === "main") {
        if (enableSearchHighlight) {
          renderSearchHighlightResultsMain(searchText, results);
        } else {
          renderSearchResultsMain(searchText, results);
        }
      } else {
        if (enableSearchHighlight) {
          renderSearchHighlightResultsSide(searchText, results);
        } else {
          renderSearchResultsSide(searchText, results);
        }
        
        var dropdownItems = searchResultsContainer.querySelectorAll('.dropdown-item');
        dropdownItems ? dropdownItems.forEach(function(item) {
          item.addEventListener('mousedown', function(e) {
            e.target.click();
          });
        }) : null;
      }
    }) : null;

    searchElem ? 
    searchElem.addEventListener('blur', function() {
      if (window.innerWidth < 770) {
        return null;
      }
      searchResultsContainer ? searchResultsContainer.setAttribute('class', 'dropdown') : null;
    }) : null;

    searchElem ? 
    searchElem.addEventListener('click', function(e) {
      if (window.innerWidth < 770) {
        return null;
      }
      if (!e.target.value) {
        searchResultsContainer ? searchResultsContainer.setAttribute('class', 'dropdown') : null;
        return null;
      }

      searchText = e.target.value;
      var results = fuse.search(e.target.value);

      if (searchResultPosition === "main") {
        if (enableSearchHighlight) {
          renderSearchHighlightResultsMain(searchText, results);
        } else {
          renderSearchResultsMain(searchText, results);
        }
      } else{
        if (enableSearchHighlight) {
          renderSearchHighlightResultsSide(searchText, results);
        } else {
          renderSearchResultsSide(searchText, results);
        }

        var dropdownItems = searchResultsContainer.querySelectorAll('.dropdown-item');
        dropdownItems ? dropdownItems.forEach(function (item) {
          item.addEventListener('mousedown', function (e) {
            e.target.click();
          });
        }) : null;
      }
    }) : null;

    var searchMenuElem = document.getElementById("search-menu");
    var activeItem = document.querySelector('#search-menu .dropdown-item.is-active');
    var activeIndex = null;
    var items = null;
    var searchContainerMaxHeight = 350;

    searchElem ? 
    searchElem.addEventListener('keydown', function(e) {
      if (window.innerWidth < 770) {
        return null;
      }

      if (e.key === 'Escape') {
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
      }

      var items = document.querySelectorAll('#search-menu .dropdown-item');
      var keyCode = e.which || e.keyCode;

      if (!items || !items.length) {
        return null;
      }
      
      if (e.key === 'ArrowDown' || keyCode === 40) {
        if (activeIndex === null) {
          activeIndex = 0;
          items[activeIndex].classList.remove('is-active');
        } else {
          items[activeIndex].classList.remove('is-active');
          activeIndex = activeIndex === items.length - 1 ? 0 : activeIndex + 1;
        }
        items[activeIndex].classList.add('is-active');

        let overflowedPixel = items[activeIndex].offsetTop + items[activeIndex].clientHeight - searchContainerMaxHeight;
        if (overflowedPixel > 0) {
          document.querySelector(".search-content").scrollTop += items[activeIndex].getBoundingClientRect().height;
        } else if (activeIndex === 0) {
          document.querySelector(".search-content").scrollTop = 0;
        }
      } else if (e.key === 'ArrowUp' || keyCode === 38) {
        if (activeIndex === null) {
          activeIndex = items.length - 1;
          items[activeIndex].classList.remove('is-active');
        } else {
          items[activeIndex].classList.remove('is-active');
          activeIndex = activeIndex === 0 ? items.length - 1 : activeIndex - 1;
        }
        items[activeIndex].classList.add('is-active');
        
        let overflowedPixel = items[activeIndex].offsetTop + items[activeIndex].clientHeight - searchContainerMaxHeight;
        if (overflowedPixel < 0) {
          document.querySelector(".search-content").scrollTop -= items[activeIndex].getBoundingClientRect().height;
        } else {
          document.querySelector(".search-content").scrollTop = overflowedPixel + items[activeIndex].getBoundingClientRect().height;
        }
      } else if (e.key === 'Enter' || keyCode === 13) {
        if (items[activeIndex] && items[activeIndex].getAttribute('href')) {
          location.href = items[activeIndex].getAttribute('href');
        }
      } else if (e.key === 'Escape' || keyCode === 27) {
        e.target.value = null;
        if (searchResults) {
          searchResults.classList.remove('is-active');
        }
      }
    }) : null;

    searchMobile ? 
    searchMobile.addEventListener('input', function(e) {
      if (!e.target.value) {
        let wrap = document.getElementById('search-mobile-results');
        while (wrap.firstChild) {
          wrap.removeChild(wrap.firstChild);
        }
        return null;
      }

      searchText = e.target.value;
      var results = fuse.search(e.target.value);
      renderSearchResultsMobile(searchText, results);
      if (enableSearchHighlight) {
        renderSearchHighlightResultsMobile(searchText, results);
      } else {
        renderSearchResultsMobile(searchText, results);
      }
    }) : null;
  


  
    var mobileSearchInputElem = document.querySelector('#search-mobile');
    var mobileSearchClassElem = document.querySelector('.mobile-search');
    var mobileSearchBtnElem = document.querySelector('#mobileSearchBtn');
    var mobileSearchCloseBtnElem = document.querySelector('#search-mobile-close');
    var mobileSearchContainer = document.querySelector('#search-mobile-container');
    var mobileSearchResultsElem = document.querySelector('#search-mobile-results');
    var htmlElem = document.querySelector('html');

    if (mobileSearchClassElem) {
      mobileSearchClassElem.style.display = 'none';
    }

    mobileSearchBtnElem ? 
    mobileSearchBtnElem.addEventListener('click', function () {
      if (mobileSearchContainer) {
        mobileSearchContainer.style.display = 'block';
      }

      if (mobileSearchInputElem) {
        mobileSearchInputElem.focus();
      }

      if (htmlElem) {
        htmlElem.style.overflowY = 'hidden';
      }
    }) : null;

    mobileSearchCloseBtnElem ? 
    mobileSearchCloseBtnElem.addEventListener('click', function() {
      if (mobileSearchContainer) {
        mobileSearchContainer.style.display = 'none';
      }

      if (mobileSearchInputElem) {
        mobileSearchInputElem.value = '';
      }
      
      if (mobileSearchResultsElem) {
        while (mobileSearchResultsElem.firstChild) {
          mobileSearchResultsElem.removeChild(mobileSearchResultsElem.firstChild);
        }
      }

      if (htmlElem) {
        htmlElem.style.overflowY = 'visible';
      }
    }) : null;

    mobileSearchInputElem ?
    mobileSearchInputElem.addEventListener('keydown', function(e) {
      var keyCode = e.which || e.keyCode;
      if (e.key === 'Escape' || keyCode === 27) {
        if (mobileSearchContainer) {
          mobileSearchContainer.style.display = 'none';
        }
        
        if (mobileSearchInputElem) {
          mobileSearchInputElem.value = '';
        }

        if (mobileSearchResultsElem) {
          while (mobileSearchResultsElem.firstChild) {
            mobileSearchResultsElem.removeChild(mobileSearchResultsElem.firstChild);
          }
        }
        if (htmlElem) {
          htmlElem.style.overflowY = 'visible';
        }
      }
    }) : null;
  


  
    function renderSearchResultsMain(searchText, results) {
      var searchBody = document.querySelector('.search-result__body');
      var originUl = searchBody.querySelector('ul');
      var ul = document.createElement('ul');
      
      if (!searchText) {
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
      } else if (results) {
        if (results && results.length) {
          results.forEach(function (result) {
            makeLi(ul, result);
          });

          searchResult ? searchResult.setAttribute('data-display', 'block') : null;
          summaryContainer ? summaryContainer.setAttribute('data-display', 'none') : null;
        }
      }

      originUl.parentNode.replaceChild(ul, originUl);
    }

    function renderSearchHighlightResultsMain(searchText, results) {
      var searchBody = document.querySelector('.search-result__body');
      var originUl = searchBody.querySelector('ul');
      var ul = document.createElement('ul');

      if (!searchText) {
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
      } else if (results) {
        if (results && results.length) {
          results.forEach(function (result) {
            makeHighlightLi(ul, result);
          });

          searchResult ? searchResult.setAttribute('data-display', 'block') : null;
          summaryContainer ? summaryContainer.setAttribute('data-display', 'none') : null;
        }
      }

      originUl.parentNode.replaceChild(ul, originUl);
    }
  
  });
</script>    
    


<link rel="stylesheet" href="/blog/css/main.min.css">


    
<meta name="description" content="JMwill&#39;s github site. Build with hugo" />


<meta name="keywords" content="译文,Design Programs">

<meta name="created" content="2017-06-11T16:57:25&#43;0800">
<meta name="modified" content="2017-06-11T16:57:25&#43;0800">
<meta property="article:published_time" content="2017-06-11T16:57:25&#43;0800">

<meta name="author" content="Will">


<meta property="og:site_name" content="Will&#39;s Blog">
<meta property="og:title" content="程序构成-第二章">
<meta property="og:url" content="https://jmwill.github.io/blog/2017/06/11/%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90-%E7%AC%AC%E4%BA%8C%E7%AB%A0/">
<meta property="og:type" content="article">
<meta property="og:description" content="JMwill&#39;s github site. Build with hugo">

<meta name="generator" content="Hugo 0.74.2" />
<meta name="msapplication-TileColor" content="#fff">

<meta name="theme-color" content="#fff">

<meta name="msapplication-navbutton-color" content="#fff">

<meta name="apple-mobile-web-app-status-bar-style" content="#fff">

<link rel="canonical" href="https://jmwill.github.io/blog/2017/06/11/%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90-%E7%AC%AC%E4%BA%8C%E7%AB%A0/">

<link rel="manifest" href="/blog/manifest.json">

  
  <link rel="shortcut icon" href="/blog/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/blog/favicon.png" sizes="any" type="image/png" />
  


    <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebPage",
    "headline": "程序构成-第二章",
    "datePublished": "2017-06-11T16:57:25+08:00",
    "dateModified": "2017-06-11T16:57:25+08:00",
    "url" : "https://jmwill.github.io/blog/2017/06/11/%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90-%E7%AC%AC%E4%BA%8C%E7%AB%A0/",
    "description": "\u003ch2 id=\"第二章-构筑抽象数据\"\u003e第二章: 构筑抽象数据\u003c/h2\u003e \u003ch3 id=\"21-介绍\"\u003e2.1 介绍\u003c/h3\u003e \u003cp\u003e在第一章我们集中关注计算过程, 以及函数对程序设计的作用与影响. 我们已经见识过如何使用原始数据(numbers)以及原始操作符(算术), 如何通过组合和控制来组成复合函数, 以及通过给计算过程赋予名称来创建函数抽抽象. 我们也看到高阶函数通过允许我们自行控制, 从而推理出一般计算方法来增强我们的语言 …\u003c/p\u003e",
    "keywords": ["译文","Design Programs"],
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://jmwill.github.io/blog/"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Will's Blog",
      "url": "https://jmwill.github.io/blog/"
    }
  }
</script>

    
  
  







    
</head>

<body id="root" class="theme__solarized">
    <script>
        var localTheme = localStorage.getItem('theme');
        if (localTheme) {
            document.getElementById('root').className = 'theme__' + localTheme;
        }
    </script>
    <div id="container">
        





        <div class="wrapper" data-type="posts" data-kind="page">
            <nav class="navbar" role="navigation" aria-label="main navigation" data-dir="ltr">
  <div class="navbar__brand">
    
    <a href="/blog/" title="Home" rel="home" class="navbar__logo-link">
      <img src="/blog/logo.png" alt="Home" class="navbar__logo">
    </a>
    
    
      <a href="/blog/" title="Home" rel="home" class="navbar__title-link">
        <h6 class="navbar__title">Will</h6>
      </a>
    
  </div>

  
<div class="theme theme-mobile" data-ani="true">
  <div class="dropdown">
    <button class="dropdown-trigger navbar__slide-down" aria-label="Select Theme Button" style="" data-ani="true">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"><path fill="none" d="M24 0H0v24h24V0z"/><path fill="currentColor" d="M6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31C7.9 20.8 9.95 21.58 12 21.58s4.1-.78 5.66-2.34c3.12-3.12 3.12-8.19 0-11.31l-4.95-4.95c-.39-.39-1.02-.39-1.41 0L6.34 7.93zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59s.62-3.11 1.76-4.24L12 5.1v14.49z"/></svg>      
    </button>
    <div class="dropdown-content select-theme">
      
        
        <a href="#" class="dropdown-item select-theme__item is-active">
          solarized
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          dark
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          light
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          hacker
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          kimbie
        </a>
        
      
    </div>
  </div>
</div>


<div id="mobileSearchBtn" class="mobile-search__btn" data-ani="true">
  <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M15.5 14h-.79l-.28-.27c1.2-1.4 1.82-3.31 1.48-5.34-.47-2.78-2.79-5-5.59-5.34-4.23-.52-7.79 3.04-7.27 7.27.34 2.8 2.56 5.12 5.34 5.59 2.03.34 3.94-.28 5.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
</div>

<div id="search-mobile-container" class="mobile-search hide" data-dir="ltr">
  <div class="mobile-search__top">
    <input id="search-mobile" type="text" aria-label="Mobile Search" placeholder="Search" class="mobile-search__top--input"/>
    <div id="search-mobile-close" class="mobile-search__top--icon">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"><path opacity=".87" fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3.59-13L12 10.59 8.41 7 7 8.41 10.59 12 7 15.59 8.41 17 12 13.41 15.59 17 17 15.59 13.41 12 17 8.41z"/></svg>
    </div>
  </div>
  <div id="search-mobile-results" class="mobile-search__body">
    
  </div>
</div>


<a role="button" class="navbar__burger" aria-label="menu" aria-expanded="false"
  data-ani="true">
  <span aria-hidden="true"></span>
  <span aria-hidden="true"></span>
  <span aria-hidden="true"></span>
</a>
<div class="navbarm__collapse" data-open="false">
  <ul dir="ltr">
    
    
      
      
      
      

      
        <li class="navbarm__menu--item active">
          <a href="/blog/posts">posts</a>
        </li>
      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="/blog/archive">archive</a>
        </li>
      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="/blog/about">about</a>
        </li>
      
      
    

    
      <li class="navbarm__menu--item ">
        <a href="/blog/tags" class="navbarm__menu--term" data-index="0">
          Tags
        </a>
      </li>
    
  </ul>
</div>
  <div class="navbar__menu">
  
<div class="theme" data-ani="true">
  <div class="dropdown">
    <button class="dropdown-trigger navbar__slide-down" aria-label="Select Theme Button" data-ani="true">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"><path fill="none" d="M24 0H0v24h24V0z"/><path fill="currentColor" d="M6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31C7.9 20.8 9.95 21.58 12 21.58s4.1-.78 5.66-2.34c3.12-3.12 3.12-8.19 0-11.31l-4.95-4.95c-.39-.39-1.02-.39-1.41 0L6.34 7.93zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59s.62-3.11 1.76-4.24L12 5.1v14.49z"/></svg>      
    </button>
    <div class="dropdown-content select-theme">
      
        
        <a href="#" class="dropdown-item select-theme__item is-active">
          solarized
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          dark
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          light
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          hacker
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          kimbie
        </a>
        
      
    </div>
  </div>
</div>

  
  
  
  
  
  
  
  <a href="/blog/posts" class="navbar__menu-item navbar__slide-down active" dir="ltr" data-ani="true">posts</a>
  
  
  
  
  
  
  
  <a href="/blog/archive" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">archive</a>
  
  
  
  
  
  
  
  <a href="/blog/about" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">about</a>
  
  
</div>
</nav>
            
            

<main class="single__main main-main">
  
    <nav class="breadcrumb hide" aria-label="breadcrumbs">
  <script>document.querySelector('.breadcrumb').classList.remove('hide')</script>
  <ol>
    
  
  
  
  
  
  <li >
    
      <a href="https://jmwill.github.io/blog/" class="capitalize">Will&#39;s Blog</a>
    
  </li>
  
  
  <li >
    
      <a href="https://jmwill.github.io/blog/posts/" class="capitalize">Posts</a>
    
  </li>
  
  
  <li  class="is-active" >
    
      <span>程序构成-第二章</span>
    
  </li>
  
  </ol>
  
</nav>
  
  
  <div class="single ">
    <div class="single__nojs">This page looks best with JavaScript enabled</div>
    <script>document.querySelector('.single').classList.remove('hide'); document.querySelector('.single__nojs').classList.add('hide');</script>
    <h2 class="single__title" data-ani="true">程序构成-第二章</h2>
    <div class="single__meta">
      
<div class="single__infos">
  <time class="single__info" title="Written At">📅&nbsp;Jun 11, 2017 </time>
  
  &nbsp;&middot;&nbsp; <span class="single__info" title="Reading Time"> ☕&nbsp;126&nbsp;min read </span>
  
  <span class="single__info">
    
  </span>
</div>
      
<ul class="single__tags caption">
  
  🏷️
  

  <li><a href="https://jmwill.github.io/blog/tags/%E8%AF%91%E6%96%87/" class="single__tag" title="译文">#译文</a></li>

  <li><a href="https://jmwill.github.io/blog/tags/design-programs/" class="single__tag" title="Design Programs">#Design Programs</a></li>

</ul>
    </div>
    <article class="single__contents" data-dir="ltr" data-ani="true">
      
      <h2 id="第二章-构筑抽象数据">第二章: 构筑抽象数据</h2>
<h3 id="21-介绍">2.1 介绍</h3>
<p>在第一章我们集中关注计算过程, 以及函数对程序设计的作用与影响. 我们已经见识过如何使用原始数据(numbers)以及原始操作符(算术), 如何通过组合和控制来组成复合函数, 以及通过给计算过程赋予名称来创建函数抽抽象. 我们也看到高阶函数通过允许我们自行控制, 从而推理出一般计算方法来增强我们的语言的力量. 这就是编程的本质.</p>
<p>这一章主要关注数据. 我们在这里探讨的技术允许我们表达以及操作许多不同领域的信息. 由于因特网的爆炸性增长, 提供给我们大量在线且免费的结构化信息, 并且可以在大范围不同问题上进行计算. 有效使用內建的以及用户定义的数据类型是数据处理程序的根本.</p>
<h4 id="211-基本数据类型">2.1.1 基本数据类型</h4>
<p>每一种数据在Python中都有一个类属, 这个类属决定了这个值是什么类型. 共享的数据同时具有共享的行为. 例如, 整数1以及2都是int类的实例. 这两个值能够进行类似的处理. 例如, 它们都可以被另外一个整数加或者减. 內建的type函数允许我们检查任何数值的类型.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">int</span><span class="s1">&#39;&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>我们目前使用的数值知识少量Python语言的內建_本地_数据类型. 本地数据类型具有以下属性:</p>
<ol>
<li>有对原生类型的值进行定义的表达式, 叫做常量</li>
<li>有对原生类型的值进行操作的內建函数以及操作符</li>
</ol>
<p>int类是用来表示整数的原生数据类型. 整型常量(相邻数字序列)表达为int值, 以及数学运算符来操作这些值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">3000000000000000000000000</span>
<span class="mi">3000000000000000000000012</span>
</code></pre></td></tr></table>
</div>
</div><p>Python包含有三种本地数据类型: 整型(int), 实数(float), 以及复数(complex).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">float</span><span class="s1">&#39;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1j</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">complex</span><span class="s1">&#39;&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>Floats</strong>: 名字float来源于Python以及许多其他的程序语言实数的表示方式是以: &ldquo;浮点(floating point)&ldquo;来表示的. 至于数字是如何表示的这些细节不在我们这一节的讨论范围之内, 而一些int以及float对象的高级差异需要重点了解. 尤其是, int对象能够准确地表示整数, 对其大小没有任何近似以及限制. 另一方面, float对象能够表示较宽范围内的分数, 但不是所有的数字都能够准确表示, 同时它们还具有最小值以及最大值. 因此, float数值应该被视为实际值的近似值来对待. 这些近似值只具有有限的精度. 合并浮点数会导致一些精度错误; 如果不用近似值的话下面的表达式计算后应该会等于7:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="mi">7</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">3</span>
<span class="mf">7.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">7</span> <span class="o">*</span> <span class="mi">3</span>
<span class="mf">6.999999999999999</span>
</code></pre></td></tr></table>
</div>
</div><p>虽然上面是int的组合, 用一个int除以另一个会得到一个float的值: 一个被截断了的近似值, 也就是两个整数相除的实际比率.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">float</span><span class="s1">&#39;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
<span class="mf">0.3333333333333333</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们进行相等性测试的时候就会出现近似值的问题.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span> <span class="o">==</span> <span class="mf">0.333333333333333312345</span>  <span class="c1"># Beware of float approximation</span>
<span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p>这些int类型与float类型之间的微妙不同, 对程序的编写具有广泛的影响, 因此它们的细节程序员必须要铭记在心. 幸运的是, 只有少量的本地数据类型, 限制了精通编程语言所需要的记忆量. 此外, 这些相同的细节在许多编程语言中也是一致的. 由社区准则强制执行, 如: <a href="http://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754 floating point standard</a></p>
<p><strong>非数字类型</strong>. 数值能够代表许多其他类型的数据, 例如声音, 图像, 地点, 网址, 网络连接等等. 少量是通过本地数据类型来表示的, 例如代表真(True)和假(False)的布尔(bool)类型. 大多数值的类型都需要程序员来使用本章中研究的组合和抽象手段来进行定义.</p>
<p>接下来的部分将介绍更多Python的本地数据类型, 侧重于它们在创建有用的数据抽象中所起到的作用. 那些对于更加深入的细节感兴趣的人可以阅读一下深入Python3这本书的<a href="http://getpython3.com/diveintopython3/native-datatypes.html">本地数据类型</a>这一章,写出了所有Python的本地数据类型的实用概述以及如何对它们进行操作, 包括大量的用法例子以及练习提示.</p>
<h3 id="22-数据抽象">2.2 数据抽象</h3>
<p>当我们考虑世界上的广泛的事物的时候, 我们会想要将它在我们的程序中表现出来, 我们会发现它们大多数都具有复合结构. 例如, 一个地理位置有经度以及纬度坐标. 为了表示位置, 我们会想让我们的程序语言有能力将经度和纬度合在一起以形成一对, 作为一个我们的程序能够操作的一个单一的概念单元, 但是它也具有两个部分可以进行单独考虑.</p>
<p>使用复合数据能够让我们提升程序的模块性, 如果我们能够将地理位置作为一个整体来进行操作, 然后我们就可以对程序使用位置进行计算中是如何对这些地理位置进行表示的细节进行屏蔽. 一般的隔离程序各个部分的技术, 都是处理数据是如何被表示, 以及处理数据是如何被操作的强大的设计方法, 这方法称为数据抽象. 数据抽象让程序更容易被设计, 维护, 以及修改</p>
<p>数据抽象在性质上跟函数抽象那一章相似. 当我们创建一个函数抽象, 函数是如何实现的细节能够被压制, 以及特定的函数本身能够被任何其他的具有相同整体行为的函数进行替换. 换句话说, 我们可以实现一个抽象来将函数使用的方式与函数如何实现的细节上进行分离. 类似地, 数据抽象对复合数据的使用方式与如何构造的细节进行了隔离.</p>
<p>数据抽象的基本思想是结构化程序, 以便于它们对抽象数据进行操作. 也就是说, 我们的程序应该以尽可能少的以对数据进行假设的方式来使用数据. 同时, 数据的具体表现应该定义为程序的一个独立的部分.</p>
<p>程序的这两个部分, 对数据抽象进行操作的部分以及定义具体表示的部分, 通过一组小的函数进行连接, 这些函数根据具体表示实现抽象数据. 为了说明这种技术, 我们需要考虑如何设计一套函数来操作有理数.</p>
<h4 id="221-例子-有理数">2.2.1 例子: 有理数</h4>
<p>一个有理数就是整数的比率, 有理数是构成实数的重要子类. 一个有理数如1/3或者17/29通常写作:</p>
<p><code>&lt;numerator&gt;/&lt;denominator&gt;</code></p>
<p>而<code>&lt;numerator&gt;</code>以及<code>&lt;denominator&gt;</code>都是整数的占位符. 这些部分都需要用来准确地表征有理数的值. 实际上整数相除得到一个浮点数的近似值, 失去了整数的精确度.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
<span class="mf">0.3333333333333333</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span> <span class="o">==</span> <span class="mf">0.333333333333333300000</span>  <span class="c1"># Dividing integers yields an approximation</span>
<span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p>然而, 我们可以通过将分子和分母组合在一起来为有理数创建一个精确的表示.</p>
<p>我们从使用函数的抽象中可以知道, 我们可以在程序的某些部分实现之前开始进行编程. 让我们假设我们已经有办法从一个分子以及一个分母中构造一个有理数开始. 我们还假设, 给定一个有理数, 我们有方法选定它的分子和分母的部分. 让我们进一步假设构造器以及选择器可具有一下的三个功能:</p>
<ul>
<li>**rational(n, d)**以分子为n分母为d的形式返回一个有理数</li>
<li>**numer(x)**返回有理数中的分子x</li>
<li>**denom(x)**返回有理数中的分母x</li>
</ul>
<p>在这里我们使用程序设计中的强大策略: <em>祈愿思维</em>. 我们还没有讲述一个有理数是如何表示的, 或者函数number, denom, 以及rational应该怎么实现. 即使这样, 如果我们定义了这三个函数, 我们可以对有理数进行加, 乘, 打印, 以及测试相等性等操作:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">add_rationals</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">numer</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">denom</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">ny</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">numer</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">denom</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rational</span><span class="p">(</span><span class="n">nx</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">+</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">mul_rational</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">rational</span><span class="p">(</span><span class="n">numer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">numer</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">denom</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">print_rational</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">numer</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="n">denom</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">rationals_are_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">numer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">numer</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>现在我们具有定义在选择器函数number以及denom和构造器函数rational之上的操作函数, 但是我们还没有定义这些选择器函数以及构造器函数. 我们需要一种方法来将分子和分母进行粘合, 形成一个复合值.</p>
<h4 id="222-一对">2.2.2 一对</h4>
<p>为了让我们实现正确等级的数据抽象, Python提供了一种复合数据结构叫做list, 能够通过将表达式放到方括号内并用逗号分隔开来构造, 这种表达式就叫做列表字面量.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>列表中的元素可以用两种方式来进行访问, 第一种方式是通过我们熟悉的多重分配的方法, 通过对list对象中的元素进行解包然后绑定每一个元素到不同的名字.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">pair</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pair</span>
<span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pair</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span>
<span class="mi">20</span>
</code></pre></td></tr></table>
</div>
</div><p>第二个访问方法是通过list的元素选择运算符, 也通过方括号来进行表达. 不像列表字面量, 一个方括号表达式直接跟在另一个表达式后面不以生成列表值来运行, 而是在前面的表达式中选择一个元素.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">20</span>
</code></pre></td></tr></table>
</div>
</div><p>在Python中的列表(以及大多数其他的编程语言)是以0索引作为开始的, 这意味着索引0选定第一个元素, 索引1选定第二个, 等等. 一个支持这个索引惯例的直觉是索引代表一个元素偏离列表开始位置有多远.</p>
<p>跟元素选择操作符相等的函数叫做getitem, 它也用索引0作为开始位置来对列表对象进行选取.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">getitem</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">getitem</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">getitem</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">20</span>
</code></pre></td></tr></table>
</div>
</div><p>两个元素的列表不是表示一对的唯一方法, 任何将两个值捆绑到一块的方法都可以认为是一对. 只是列表是一种常用的方法. 列表也可以容纳超过两个对象, 正如我们本章接下来要进行讨论的.</p>
<p><strong>表示有理数</strong>. 现在我们能够将有理数表示为一对整数的组合: 一个分子和一个分母.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">rational</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">numer</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">denom</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>结合早先我们定义的算术运算, 我们可以用我们已经定义好的函数来操作有理数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">half</span> <span class="o">=</span> <span class="n">rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">print_rational</span><span class="p">(</span><span class="n">half</span><span class="p">)</span>
<span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">third</span> <span class="o">=</span> <span class="n">rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">print_rational</span><span class="p">(</span><span class="n">mul_rational</span><span class="p">(</span><span class="n">half</span><span class="p">,</span> <span class="n">third</span><span class="p">))</span>
<span class="mi">1</span> <span class="o">/</span> <span class="mi">6</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">print_rational</span><span class="p">(</span><span class="n">add_rationals</span><span class="p">(</span><span class="n">third</span><span class="p">,</span> <span class="n">third</span><span class="p">))</span>
<span class="mi">6</span> <span class="o">/</span> <span class="mi">9</span>
</code></pre></td></tr></table>
</div>
</div><p>像上面例子显示的那样, 我们的有理数的实现不会将有理数减少到最低项. 我们可以通过改变rational函数的实现来修复这个缺陷. 如果我们有一个函数来计算两个整数的最大公分母, 我们就可以在构建有理数对时用它来将分子和分母减少为最底项. 跟许多有用的工具一样, 在Python的库中已经有这样的一个函数了.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">gcd</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">rational</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="n">g</span><span class="p">,</span> <span class="n">d</span><span class="o">//</span><span class="n">g</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>整除运算符, <code>//</code>, 表示整除, 也就是对相除的结果将向下舍入小数部分. 由于我们已经知道g能够完全整除n以及d, 整除在这种情况下是精确的. 这个rational函数的合理地进行了修正保证了有理数以最低项来表示.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">print_rational</span><span class="p">(</span><span class="n">add_rationals</span><span class="p">(</span><span class="n">third</span><span class="p">,</span> <span class="n">third</span><span class="p">))</span>
<span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span>
</code></pre></td></tr></table>
</div>
</div><p>这种改进是通过改进构造函数而不用改变其他函数(即实现实际运算的函数)来完成的.</p>
<h4 id="223-抽象屏障">2.2.3 抽象屏障</h4>
<p>在继续(介绍)更多的组合数据和数据抽象的例子之前, 让我们思考一下有理数例子提出的一些问题. 我们根据构造函数rational和选择器numer, denom定义操作. 一般来说, 数据抽象的基础思想是识别一组基础操作, 根据这些操作来表达某种类型的值的所有操作, 然后只使用这些操作来处理数据. 通过限制这些操作的使用方式, 将会更容易改变抽象数据的表示而不用修改程序的行为.</p>
<p>对于有理数, 程序的不同部分使用不同的操作来操纵有理数, 如下表所述:</p>
<table>
<thead>
<tr>
<th align="left"><strong>Parts of the program that&hellip;</strong></th>
<th align="left"><strong>Treat rational as&hellip;</strong></th>
<th align="left"><strong>Using only&hellip;</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Use rational numbers to perform computation</td>
<td align="left">whole data values</td>
<td align="left"><code>add_rational</code>, <code>mul_rational</code>, <code>rationals_are_equal</code>, <code>print_rational</code></td>
</tr>
<tr>
<td align="left">Create rationals or implement rational operations</td>
<td align="left">numerators and denominators</td>
<td align="left"><code>rational</code>, <code>numer</code>, <code>denom</code></td>
</tr>
<tr>
<td align="left">Implement selectors and constructor for rationals</td>
<td align="left">two-element lists</td>
<td align="left">list literals and element selection</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th align="left"><strong>程序的每个部分&hellip;</strong></th>
<th align="left"><strong>将有理数当做&hellip;</strong></th>
<th align="left"><strong>只用作</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">用有理数来执行计算</td>
<td align="left">整个数值</td>
<td align="left"><code>add_rational</code>, <code>mul_rational</code>, <code>rationals_are_equal</code>, <code>print_rational</code></td>
</tr>
<tr>
<td align="left">创建有理数或操作有理数</td>
<td align="left">分子以及分母</td>
<td align="left"><code>rational</code>, <code>numer</code>, <code>denom</code></td>
</tr>
<tr>
<td align="left">实现有理数的构造器以及选择器</td>
<td align="left">两个元素的列表</td>
<td align="left">列表字面量以及元素选择</td>
</tr>
</tbody>
</table>
<p>在上面的每一层, 最后一列的函数实现了一个抽象屏障. 这些函数通过更低层次的抽象来实现来被更高层的函数调用.</p>
<p>违反一个抽象屏障的情况发生在每当可以在较高级别函数中使用程序的一部分时, 却使用较低级别的函数来实现. 举个例子, 一个计算有理数平方的函数最好是根据<code>mul_rational</code>来实现, 而无需对有理数的实现进行任何假设.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">square_rational</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mul_rational</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>直接涉及到分子以及分母会违反一层抽象屏障.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">square_rational_violating_once</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">rational</span><span class="p">(</span><span class="n">numer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">numer</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">denom</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>假设有理数用两个元素的列表表示会违反两层抽象屏障.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">square_rational_violating_twice</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
</code></pre></td></tr></table>
</div>
</div><p>抽象屏障让程序更容易管理与修改. 越少函数依赖于特定的表示, 当想改变其中一个的表示的时候就需要越少的改动. 所有的这些<code>square_rational</code>的实现都具有正确的行为, 但是只有第一个对于未知的变化是健壮的. <code>square_rational</code>函数即使在我们修改有理数的表示的时候也不需要更新. 相比之下, <code>square_rational_violating_once</code>每当选择器或者构造器的特征改变的时候都需要进行修改, 而<code>square_rational_violating_twice</code>则在有理数的实现有任何改变时都需要进行更新.</p>
<h4 id="224-数据的属性">2.2.4 数据的属性</h4>
<p>抽象屏障能够塑造我们思考数据的方式. 对有理数进行有效的表示是不限于任何特定的实现的(如具有两个元素的列表); 它是rational函数返回的一个值, 这个值能够输入到numer以及denom当中. 除此之外, 必需维持构造器跟选择器之间恰当的关系. 也就是说, 如果我们从整数n跟d中构造一个有理数x, 应该得到一种情况是numer(x)/denom(x)等于n/d.</p>
<p>一般来说, 我们可以用选择器函数以及构造器函数集合与一些行为条件一起来表示抽象数据. 只要这些行为条件满足(例如上面的除法属性), 选择器以及构造器函数构成了一种数据的有效表示. 在抽象屏障之下的细节可能会有更改, 但是如果行为没有改变, 那数据抽象依然是有效的, 然后任何使用这些数据抽象编写的程序依然是正确的.</p>
<p>这一观点能够进行广泛地应用, 包括我们用于实现有理数的数据对. 我们从没有说过什么是数据对, 只有语言提供的创建以及操作两个元素的列表方法. 我们需要实现的数据对的行为是它能将两个值黏合在一起. 而行为条件,</p>
<ul>
<li>如果一个数据对p由值x跟y构造, 那么select(p, 0)返回x, select(p, 1)返回y.</li>
</ul>
<p>我们实际上不需要用列表类型来创建数据对, 作为替代, 我们可以实现两个函数pair以及select来满足这个描述, 就像两个元素的列表一样.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">pair</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a function that represents a pair.&#34;&#34;&#34;</span>
        <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span>
            <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">y</span>
        <span class="k">return</span> <span class="n">get</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return the element at index i of pair p.&#34;&#34;&#34;</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>有了这个实现, 我们可以创建并操作数据对.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pair</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">select</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">20</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">select</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">14</span>
</code></pre></td></tr></table>
</div>
</div><p>这种高阶函数的使用方式能够跟我们对于数据是什么这种直观的概念进行对应. 然而, 这些函数足够表示我们程序中用到的数据对. 函数足以表示复合数据.</p>
<p>用函数展示数据对的意思不代表Python就是以这种方式来运行的(处于效率的原因, 列表的实现更加的直观)但是它能以这种方式运行. 函数型的表示虽然模糊, 但它完全具有表示数据对的能力, 因为它满足数据对唯一需要满足的条件. 数据抽象的实践允许我们轻易地在各种表示中进行切换.</p>
<h3 id="23-序列">2.3 序列</h3>
<p>序列就是一个值的有序集合. 序列在计算机科学中是强大的, 基本的抽象. 序列不是某个特定的內建类型的实例或者抽象数据表示, 而是在一些不同类型的数据之间共享行为的集合. 也就是说, 有许多种类型的序列. 但是它们都共享共同的行为. 尤其是,</p>
<p><strong>长度</strong>. 一个序列具有有限的长度. 一个空序列的长度是0.</p>
<p><strong>元素选择</strong>. 一个序列的对于任何小于它长度的非负整数的索引值都对应它的一个元素, 第一个元素从0开始.</p>
<p>Python包含的一些本地数据类型就是序列, 最重要的莫过于<strong>列表</strong>了.</p>
<h4 id="231-列表">2.3.1 列表</h4>
<p>一个列表就是一个具有任意长度的序列. 列表具有一大套內建行为, 以及表示这些行为的特殊语法. 我们已经见识过列表字面量了, 也就是用来运算生成列表实例那个, 以及元素选择表达式, 即用来获取列表中的值的语法. 內建的len函数用于返回一个序列的长度. 下面, digits是一个具有四个元素的列表. 索引为3的元素值是8.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">digits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">)</span>
<span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">digits</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="mi">8</span>
</code></pre></td></tr></table>
</div>
</div><p>另外, 列表可以加在一起, 以及与一个整数相乘. 对于序列来说, 加法以及乘法不会添加或者乘里面的元素, 而是复制序列本身并将它们合并在一起. 也就是说, 在operator模块下的add函数(以及符号+)返回的是添加的参数级联后生成的一个列表. 而在operator中的mul函数(以及<code>*</code>号)能够传入一个列表以及一个整数然后返回另一个列表, 这个列表是由k次重复的源列表组成的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="n">digits</span> <span class="o">*</span> <span class="mi">2</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>任意的值都可以包含在列表中, 包括其他的列表. 为了选择到包括在列表里面的列表这样深层次嵌套的元素可以多次应用列表元素选择语法.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">pairs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="mi">30</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="232-序列迭代">2.3.2 序列迭代</h4>
<p>在很多情况下, 我们会想要对序列的元素进行迭代然后反过来对每个元素执行一些计算. 这种模式是如此的常见以至于Python有一个额外的控制语句来处理顺序的数据: for语句.</p>
<p>想一下计算一个值在序列中出现的次数这样的一个问题, 我们可以实现一个函数用while循环来进行计数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">total</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">total</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">count</span><span class="p">(</span><span class="n">digits</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="mi">2</span>
</code></pre></td></tr></table>
</div>
</div><p>Python的for语句能够简化这个函数体通过直接对元素值进行迭代而根本不需要引入名称index.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">total</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">count</span><span class="p">(</span><span class="n">digits</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="mi">2</span>
</code></pre></td></tr></table>
</div>
</div><p>for语句由单个子句组成, 形式如下:</p>
<pre><code>for &lt;name&gt; in &lt;expression&gt;:
    &lt;suite&gt;
</code></pre><p>一个for语句会按照以下的步骤执行:</p>
<ol>
<li>计算头部表达式<code>&lt;expression&gt;</code>, 必须返回一个可迭代的值.</li>
<li>遍历该可迭代值中的每一个元素, 是为了:
<ol>
<li>将这个元素值当前域的中的<code>&lt;name&gt;</code>进行绑定</li>
<li>执行<code>&lt;suite&gt;</code></li>
</ol>
</li>
</ol>
<p>这个执行过程引用的是可迭代的值, 列表是序列的一种, 而序列是一种可迭代的值. 它们的元素按照它们原有的顺序被考虑. Python包括其他的可迭代的值, 但是目前我们会专注于序列; 术语&quot;可迭代&quot;的一般定义出现在第四章的迭代器部分.</p>
<p>这个计算过程的一个重要的意义是<code>&lt;name&gt;</code>会在for语句运行后绑定到序列中的最后一个元素. for循环引入了另外一种可以让运行环境随语句执行而更新的方式.</p>
<p><strong>序列解包</strong>. 在程序中的常见模式是有一个以序列为元素的序列, 但元素都是固定长度的. 一个for语句可能会包含有多个名称在它的头部用来对序列中的每一个序列元素&quot;解包&quot;到各自对应的名称上. 例如, 可能会有一个以包含两个元素的序列为元素的序列:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">pairs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
</code></pre></td></tr></table>
</div>
</div><p>然后希望从中找到这些序列对中两个数字是相等的序列对</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">same_count</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></td></tr></table>
</div>
</div><p>下面的for语句在它的头部有两个变量名x和y, 这两个变量名会分别跟序列对的第一和第二个元素进行绑定:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
            <span class="n">same_count</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">same_count</span>
<span class="mi">2</span>
</code></pre></td></tr></table>
</div>
</div><p>这种将多个名称以固定长度的顺序绑定到多个值的模式称为序列解包; 这跟我们在赋值语句中看到的绑定多个名称到多个值的模式是一样的.</p>
<p><strong>范围</strong>. 一个range类型是Python中另一个內建的序列类型, 它代表了一个整数的区间. 区间由range来创造, 需要两个整数作为参数: 第一个数字和一个超出所需范围内的最后一个数字.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="c1"># 包含1, 但不包含10</span>
<span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>调用list构造器计算出在一个在范围内的与范围相符的列表, 因此可以很容易地检查里面的元素.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>如果只给定一个参数, 这被解析为构建一个从零开始到超出所需范围内的最后一个数字的区间.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>区间通常出现在for表达式的头部来指定<code>&lt;suite&gt;</code>部位应该执行的次数: 有一个共同的约定是如果在for的头部写入的名称在<code>&lt;suite&gt;</code>中没有用到的话就用单个下划线作为名称:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Go Bears!&#39;</span><span class="p">)</span>

<span class="n">Go</span> <span class="n">Bears</span><span class="err">!</span>
<span class="n">Go</span> <span class="n">Bears</span><span class="err">!</span>
<span class="n">Go</span> <span class="n">Bears</span><span class="err">!</span>
</code></pre></td></tr></table>
</div>
</div><p>下划线对于解释器环境而言只是另外的一个名称, 但是它在程序员之间却是具有常规的意义, 那就是表明这个名称不会现在在之后的任何表达式中.</p>
<h4 id="233-序列处理">2.3.3 序列处理</h4>
<p>序列是一种如此常见的用于组成复合数据的形式以至于整个程序通常都围绕这个单一抽象来进行组织. 模块化组件同时以序列作为输入和输出能够对数据处理过程进行混合以及匹配. 复杂组件能够通过将序列处理操作连接在一起形成管道来进行定义, 而每个处理都是简单和集中的.</p>
<p><strong>列表推导</strong>. 很多的序列处理操作能够通过为序列中的每个元素计算一个固定的表达式然后收集结果的值到一个结果序列中来表示. 在Python中, 一个列表推导式是一个执行这样的计算的表达式:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">odds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">odds</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的for关键词不是for语句的一部分, 而是列表表达式的一部分因为它包含在方括号里面. 而子表达式 x+1 是将x顺序绑定到每一个odds中的元素来进行运算, 然后收集每次运算的结果到列表中.</p>
<p>另一个常见的列表推导操作是去选择一个满足某些结果的子集. 列表推导能够表达这种模式, 例如选择所有odds中的能够整除25的元素:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">odds</span> <span class="k">if</span> <span class="mi">25</span> <span class="o">%</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>列表推导的一般形式是:</p>
<p><code>[&lt;map expression&gt; for &lt;name&gt; in &lt;sequence expression&gt; if &lt;filter expression&gt;]</code></p>
<p>为了运算一个列表推导, Python会计算<code>&lt;sequence expression&gt;</code>, 这个表达式必须要返回一个可迭代值. 然后, 对每个元素按照顺序, 将元素的值与<code>&lt;name&gt;</code>进行绑定, 接着运算过滤表达式, 然后如果过滤结果返回真值, <code>map expression</code>(映射表达式)将会执行, 最后结果会被收集到一个列表中.</p>
<p><strong>聚合</strong>. 第三个序列处理的一般模式是将一个序列中所有的值聚合到单一的一个值中. 內建函数sum, min, 以及max所有都是聚合函数的例子.</p>
<p>通过结合这些对每个元素进行运算, 选择元素的子集, 以及聚集元素的模式, 我们可以使用序列处理方法来解决问题.</p>
<p>一个完备正整数指的就是一个等于它的除数的总和. n的除数是小于n且能均分n的正整数. 可以通过列表推导来运算从而列出这些n的除数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">divisors</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">divisors</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>使用divisors函数, 我们可以用其他的列表推导来计算出从1到1000的所有的完备数. (1通常也被认为是完备数, 但是它不符合我们对divisors的定义)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">divisors</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">==</span> <span class="n">n</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">496</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以复用我们定义的divisors来解决另外的问题, 找出一个具有固定面积以及整数长度边长的长方形的最小周长. 长方形的面积等于它的高乘以宽. 而且, 给定面积以及高, 我们可以计算出宽. 我们可以肯定地说, 长和宽都能均分面积的话, 就可以保证边长都是整数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">area</span> <span class="o">%</span> <span class="n">height</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">area</span> <span class="o">//</span> <span class="n">height</span>
</code></pre></td></tr></table>
</div>
</div><p>长方形的周长等于它边长的总和</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">perimeter</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">height</span>
</code></pre></td></tr></table>
</div>
</div><p>具有整数边长的长方形的高必须是它面积的除数. 我们可以通过考虑它所有的高来计算最小周长.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">minimum_perimeter</span><span class="p">(</span><span class="n">area</span><span class="p">):</span>
        <span class="n">heights</span> <span class="o">=</span> <span class="n">divisors</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
        <span class="n">perimeters</span> <span class="o">=</span> <span class="p">[</span><span class="n">perimeter</span><span class="p">(</span><span class="n">width</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">heights</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">perimeters</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">80</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">width</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">16</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">perimeter</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">42</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">perimeter</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="mi">36</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">minimum_perimeter</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
<span class="mi">36</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">minimum_perimeter</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>高阶函数</strong></p>
<p>我们在序列处理中观察到的一般模式可以用高阶函数来进行表示. 首先, 为序列中的每个元素运行一个表达式可以通过对每一个元素应用函数来来表示.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">apply_to_all</span><span class="p">(</span><span class="n">map_fn</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">map_fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>通过对每一个元素应用的函数表达式然后仅选择能使表达式结果为真的元素.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">keep_if</span><span class="p">(</span><span class="n">filter_fn</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
</code></pre></td></tr></table>
</div>
</div><p>最后, 许多形式的聚合可以表示为反复应用一个带有两个参数的函数, 分别是进行<strong>reduced</strong>后的值, 以及顺序应用的每一个元素.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="n">reduce_fn</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">initial</span><span class="p">):</span>
        <span class="n">reduced</span> <span class="o">=</span> <span class="n">initial</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">reduced</span> <span class="o">=</span> <span class="n">reduce_fn</span><span class="p">(</span><span class="n">reduced</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reduced</span>
</code></pre></td></tr></table>
</div>
</div><p>例如, reduce可以用来将序列中的所有元素乘到一起. 使用mul替代<code>reduce_fn</code>, 1替代<code>initial</code>, reduce可以用来将序列中的数都乘到一起.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">64</span>
</code></pre></td></tr></table>
</div>
</div><p>我们也可以用这些高阶函数来找寻完备数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">divisors_of</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">divides_n</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">n</span> <span class="o">%</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">keep_if</span><span class="p">(</span><span class="n">divides_n</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">divisors_of</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">sum_of_divisors</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">divisors_of</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">perfect</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sum_of_divisors</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">keep_if</span><span class="p">(</span><span class="n">perfect</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">496</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>常规名称</strong></p>
<p>在计算机科学的社群中, <code>apply_to_all</code>一般叫做<code>map</code>, <code>keep_if</code>一般叫做<code>filter</code>. 在Python中, 內建的map以及filter是这些方法的泛化, 且并不返回列表对象. 这些方法会在第四章来进行讨论. 上面的定义相当于用列表构造器到处理內建的map以及filter调用后所返回结果.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="n">apply_to_all</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">map_fn</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">map_fn</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
<span class="n">keep_if</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">filter_fn</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">filter_fn</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>reduce函数构建在Python的标准库的<code>functools</code>模块中. 在这个版本中, initial参数是可选的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">mul</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">product</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="mi">120</span>
</code></pre></td></tr></table>
</div>
</div><p>在Python程序中, 直接使用列表推导是比使用高阶函数更一般的模式, 但两者在列表处理中都是广泛使用的方法.</p>
<h4 id="234-序列抽象">2.3.4 序列抽象</h4>
<p>我们已经介绍了两种满足序列抽象的本地数据类型: 列表和区间(lists and ranges). 两者都满足这部分开始所设的条件: 长度以及元素选择. Python包含了额外的两个序列类型的行为用来进行序列抽象的拓展.</p>
<p><strong>成员</strong>. 一个值能够就是否是一个序列的成员来进行测试. Python有两个操作符<code>in</code>以及<code>not in</code>其计算的结果是True或者False取决于元素是否出现在序列中.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">digits</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span> <span class="ow">in</span> <span class="n">digits</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">1828</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">digits</span>
<span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>切片</strong>. 序列都包含更小的序列. 一个序列的切片是原有序列的任何一个连续片段, 由一对整数来指定. 就像range构造函数一样, 第一个整数指定了切片的起始下标, 然后第二个整数指定了超过结束下标的数.</p>
<p>在Python中, 序列切片的表达式跟元素选择类似, 用方括号包裹. 一个冒号分割起始以及结束索引. 任何省略的边界都被认定为一个极值: 0是开始下标的极值, 而序列的长度则是结束下标的极值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">digits</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">digits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>切片也可以用于树的分支上. 例如, 我们可能想要对一些树的分支数进行限制. 一个共同的树转型通过将原始树进行分组组合并调整分支得出的一个二叉树叫做二值化计算.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">right_binarize</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Construct a right-branching binary tree.&#34;&#34;&#34;</span>
        <span class="k">if</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tree</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">right_binarize</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">right_binarize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]]]]]</span>
</code></pre></td></tr></table>
</div>
</div><p>对Python序列抽象中的这些额外行为进行枚举给我们一个机会来反映一个一般有用的数据抽象的组成. 抽象的丰富性(也就是说它包含的行为有多少)是有意义的. 对用户来说, 一个抽象的, 额外的行为可能很有帮助. 另一方面, 用一个新类型来满足对丰富抽象性的要求可能很具挑战性. 另一个丰富抽象性的负面后果是它们可能需要用户用更长的时间来学习.</p>
<p>序列具有丰富的抽象性因为因为它们在计算机中是如此的无所不在, 以至于需要学习一些复杂的行为是合理的, 一般来说, 大多数用户定义的抽象应该尽可能保持简单.</p>
<p><strong>深入阅读</strong>. 切片符号收录了各种各样的特殊例子, 例如负的起始值, 结束值以及步进大小. 一个完整的描述出现在Dive Into Python 3的子节中叫做<a href="http://getpython3.com/diveintopython3/native-datatypes.html#slicinglists">切片列表</a>. 在这节章中, 我们只会使用到上面提及的基础特性.</p>
<h4 id="235-字符串">2.3.5 字符串</h4>
<p>文本值在计算机科学中可能是比数字要更一般的存在. 作为例子, Python程序的都是以文本进行编写以及存储. Python中作为文本的本地数据类型被叫做字符串, 而对应的构造器就是<code>str</code>.</p>
<p>在Python中关于字符串的表现, 表达以及操作有很多的细节. 字符串是另一个丰富抽象的例子, 一个需要程序员承诺牢固地掌握的部分. 此部分会用作对基本字符串行为的简明介绍.</p>
<p>字符串字面表达式通过用单引号或者双引号作为记号来包围可以表达任意的文本.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="s1">&#39;I am string!&#39;</span>
<span class="s1">&#39;I am string!&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s2">&#34;I&#39;ve got an apostrophe&#34;</span>
<span class="s2">&#34;I&#39;ve got an apostrophe&#34;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s1">&#39;您好&#39;</span>
<span class="s1">&#39;您好&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>我们已经在代码中见识过字符串了, 如<code>docstring</code>, <code>print</code>函数的调用中, 以及在<code>assert</code>语句中的错误消息.</p>
<p>字符串满足我们在本节最开始介绍的序列的两个基本条件: 它们具有长度以及支持元素选择.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">city</span> <span class="o">=</span> <span class="s1">&#39;Berkeley&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">city</span><span class="p">)</span>
<span class="mi">8</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">city</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="s1">&#39;k&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>属于字符串本身也是字符串, 只不过它们只有一个字符. 字符是字母表的任意单个字符, 标点符号, 或者其他符号. 不像许多其他的编程语言, Python没有分开字符类型; 任何文本都是字符串, 单一一个字符代表一个长度为一的字符串.</p>
<p>就像列表, 字符串也可以用加法或者乘法来进行结合.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="s1">&#39;Berkeley&#39;</span> <span class="o">+</span> <span class="s1">&#39;, CA&#39;</span>
<span class="s1">&#39;Berkeley, CA&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s1">&#39;Shabu &#39;</span> <span class="o">*</span> <span class="mi">2</span>
<span class="s1">&#39;Shabu Shabu &#39;</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>成员</strong>. 字符串的行为发散自Python中的其他序列类型. 字符串抽象不符合我们描述的列表以及区间那样的全序列抽象, 尤其是, 当成员运算符<code>in</code>应用到字符串时, 却会有跟应用到序列上完全不同的行为表现. 它匹配的是子字符串而不是元素.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="s1">&#39;here&#39;</span> <span class="ow">in</span> <span class="s2">&#34;Where&#39;s Waldo?&#34;</span>
<span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>多行文本</strong>. 字符串并不限制只有一行. 三重引号划定了字符串文本可以跨越多行的范围. 我们已经对docstring广泛使用这个三重引号了.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="s2">&#34;&#34;&#34;The Zen of Python
</span><span class="s2">claims, Readability counts.
</span><span class="s2">Read more: import this.&#34;&#34;&#34;</span>
<span class="s1">&#39;The Zen of Python</span><span class="se">\n</span><span class="s1">claims, &#34;Readability counts.&#34;</span><span class="se">\n</span><span class="s1">Read more: import this.&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>在上面打印出来的结果中, 那个<code>\n</code>(发音是&quot;backlash en&rdquo;)是一个单元素, 用来代表一个新行. 即使它是用两个字符来表示的(backslash 以及 n), 它在长度以及元素选择上依然被认为是单个字符.</p>
<p><strong>字符串强制转换</strong>. 一个字符串能够从Python的任何对象中通过调用<code>str</code>构造器函数以一个对象作为它的参数来构建. 这个字符串的特性对于从各种类型的对象中构造描述性的字符串是十分有用的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; is an element of &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">digits</span><span class="p">)</span>
<span class="s1">&#39;2 is an element of [1, 8, 2, 8]&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>深入阅读</strong>. 编码文本在计算机中是一个复杂的主题. 在这一章中, 我们会抽象出字符串是如何表示的细节. 然而, 对许多应用来说, 字符串是如何被计算机编码的特定细节是是必要的知识. 在<a href="http://getpython3.com/diveintopython3/strings.html">The strings chapter of Dive Into Python3</a>中提供了字符编码以及Unicode的描述</p>
<h4 id="236-树">2.3.6 树</h4>
<p>我们有将一个列表作为另一个列表内的元素来使用的能力, 在我们的编程语言中提供了一种新的组合手段. 这种能力叫做数据类型的闭包属性. 一般来说, 如果组合数据的方法组合出来的结果本身可以用于这个组合方法就说这个组合方法具有闭包属性. 闭包是任何组合手段的关键源泉, 因为它允许我们去创建分层的结构&ndash;由部件组成的结构, 而这个部件本身又是由其他部件构成的等等.</p>
<p>我们可以在环境图中通过块以及指针符号对列表进行可视化, 一个列表描述为一系列包含列表中元素的相邻块. 原始值如数字, 字符串, 布尔值, 以及None值会出现在元素块中, 合成的数据, 如函数值, 以及其他列表, 会用一个箭头来表示.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=one_two%20%3D%20%5B1,%202%5D%0Anested%20%3D%20%5B%5B1,%202%5D,%20%5B%5D,%0A%20%20%20%20%20%20%20%20%20%20%5B%5B3,%20False,%20None%5D,%0A%20%20%20%20%20%20%20%20%20%20%20%5B4,%20lambda%3A%205%5D%5D%5D&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=4&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>将一个列表嵌套到另一个列表中会引入复杂性. 树是基本的数据抽象, 用于加强如何对分层数据进行结构化以及操作的规律性.</p>
<p>一棵树有一个根值以及一系列的分支. 树的每一个分支都是一棵树. 一棵没有分支的树叫做叶子. 任何被包含在另一个树中的树都叫做棵树树的子树(就像一个分支的分支). 而一棵树的一棵子树的根值又被称作这棵树的一个节点(或者节点值).</p>
<p>树的数据抽象由一个构造器<code>tree</code>以及选择器<code>root</code>和<code>branches</code>组合而成. 我们由最简单的版本开始.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">tree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">branches</span> <span class="o">=</span> <span class="p">[]):</span>
        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">is_tree</span><span class="p">(</span><span class="n">branch</span><span class="p">),</span> <span class="s1">&#39;branches must be trees&#39;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">[</span><span class="n">branches</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">root</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">branches</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</code></pre></td></tr></table>
</div>
</div><p>只有当树具有根值并且所有分支也是树时，才会形式一棵良好的树. <code>is_tree</code>函数是用在<code>tree</code>构造器中用来校验是否所有的分支都形成良好.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">is_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_tree</span><span class="p">(</span><span class="n">branch</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p><code>is_leaf</code>函数用来检查一棵树是否有分支.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">branches</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>树能够用嵌套表达式来构建, 下面的树<code>t</code>有根值3以及两个分支.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="n">tree</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">tree</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">tree</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">tree</span><span class="p">(</span><span class="mi">1</span><span class="p">)])])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">root</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">branches</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">root</span><span class="p">(</span><span class="n">branches</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">branches</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
<span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p>树递归函数可以用来构造一棵树. 例如, 一棵n阶斐波那契树以n阶斐波那契数作为根值, 对于<code>n &gt; 1</code>时, 两个分支也是斐波那契树. 一个斐波那契树演示了斐波那契数的树递归计算.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">fib_tree</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">fib_tree</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="n">fib_tree</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">fib_n</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">root</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">tree</span><span class="p">(</span><span class="n">fib_n</span><span class="p">,</span> <span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fib_tree</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]]]]</span>
</code></pre></td></tr></table>
</div>
</div><p>树递归函数也用于处理树. 例如, <code>count_leaves</code>函数用于统计树的树叶的量.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">count_leaves</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">branch_counts</span> <span class="o">=</span> <span class="p">[</span><span class="n">count_leaves</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">(</span><span class="n">tree</span><span class="p">)]</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">branch_counts</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">count_leaves</span><span class="p">(</span><span class="n">fib_tree</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="mi">8</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>分区树</strong>. 树可以用来表示整数的划分形式. 一个用最大为m的数划分数n来组成的分区树是一棵二叉树(两个分支), 代表了计算时候的两个选择. 在非叶子分区树中:</p>
<ul>
<li>左边的(下标为0)分支包含了至少使用一个m来划分n的所有方式</li>
<li>右边的(下标为1)分支包含了用<code>m-1</code>部分来划分的分区树, 以及</li>
<li>根的值是m</li>
</ul>
<p>分区树叶子的值表示了从树的根到叶的路径是否代表一个n的成功分区.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">partition_tree</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tree</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tree</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">==</span> <span class="n">partition_tree</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">==</span> <span class="n">partition_tree</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">tree</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">partition_tree</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="bp">True</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="bp">True</span><span class="p">],</span> <span class="p">[</span><span class="bp">False</span><span class="p">]],</span> <span class="p">[</span><span class="bp">False</span><span class="p">]]]</span>
</code></pre></td></tr></table>
</div>
</div><p>从一个分区树打印出分区是另外一个遍历树的树递归过程, 将每一个分区构造成一个列表. 不管是否能够触及True叶子, 分区树都会打印出来.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">print_parts</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">partition</span> <span class="o">=</span> <span class="p">[]):</span>
        <span class="k">if</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39; +&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">partition</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">branches</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">root</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
            <span class="n">print_parts</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">partition</span> <span class="o">+</span> <span class="p">[</span><span class="n">m</span><span class="p">])</span>
            <span class="n">print_parts</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">print_parts</span><span class="p">(</span><span class="n">partition_tree</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span>
<span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span>
<span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
<span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="237-链接列表">2.3.7 链接列表</h4>
<p>目前为止, 我们只用了原生的数据类型来表示序列. 然而, 我们也可以开发一个不是Python原生的序列表示. 一个序列的常见表示法是由嵌套的成对数据来构成, 叫做列表. 下面的环境图例表示出一个由四个按顺序包含1, 2, 3和4的元素组成的链表.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=four%20%3D%20%5B1,%20%5B2,%20%5B3,%20%5B4,%20'empty'%5D%5D%5D%5D&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>一个链表是一个成对的数据, 包含了序列的第一个元素(在例子中是1)以及剩下的元素的序列(在例子中是2, 3, 4). 第二个元素也是一个链表. 剩下的最里面的链表只包含4, 其余部分是<code>empty</code>, 一个用于代表空链表的值.</p>
<p>链表具有递归结构: 链表的其余部分是一个链表或者<code>empty</code>值. 我们可以定义一个抽象数据表示来进行验证, 构造以及选择链表的某部分.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">empty</span> <span class="o">=</span> <span class="s1">&#39;empty&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">is_link</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;s is a linked list if it is empty or a (first, rest) pair.&#34;&#34;&#34;</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">==</span> <span class="n">empty</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">is_link</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">link</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">rest</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Construct a linked list from its first element and the rest.&#34;&#34;&#34;</span>
        <span class="k">assert</span> <span class="n">is_link</span><span class="p">(</span><span class="n">rest</span><span class="p">),</span> <span class="s1">&#39;rest must be a linked list.&#39;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">first</span><span class="p">,</span> <span class="n">rest</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return the first element of a linked list s.&#34;&#34;&#34;</span>
        <span class="k">assert</span> <span class="n">is_link</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s1">&#39;first only applies to linked lists.&#39;</span>
        <span class="k">assert</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">empty</span><span class="p">,</span> <span class="s1">&#39;empty linked list has no first element.&#39;</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">rest</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return the rest of the elements of a linked list s.&#34;&#34;&#34;</span>
        <span class="k">assert</span> <span class="n">is_link</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s1">&#39;rest only applies to linked lists.&#39;</span>
        <span class="k">assert</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">empty</span><span class="o">.</span> <span class="s1">&#39;empty linked list has no rest.&#39;</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>上面, <code>link</code>是一个构造器, <code>first</code>以及<code>rest</code>是用于代表已经链接的列表抽象数据的选择器. 链表的行为条件是像数据对, 它的构造器以及选择器是其反函数.</p>
<ul>
<li>如果一个链表s是由第一个元素是f以及一个已经是链表的r组成, 那么<code>first(s)</code>返回的是f, <code>rest(s)</code>返回的是r.</li>
</ul>
<p>我们可以用构造器以及选择器来操纵链表.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">four</span> <span class="o">=</span> <span class="n">link</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">link</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">link</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">empty</span><span class="p">))))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">first</span><span class="p">(</span><span class="n">four</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">rest</span><span class="p">(</span><span class="n">four</span><span class="p">)</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;empty&#39;</span><span class="p">]]]</span>
</code></pre></td></tr></table>
</div>
</div><p>我们实现的这种类型的抽象数据是数据对, 一个具有两个元素的列表值. 值得注意的是, 我们也可以通过函数来实现对数据, 同时我们也可以用任何对数据来实现链表, 因此我们可以只用函数来实现链表.</p>
<p>链表可以按顺序存储一系列的数据值, 但是我们还没有展示它满足序列抽象的那一部分. 使用我们定义的抽象数据表示, 我们可以实现序列的两个特征行为: 长度以及元素选择.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">len_link</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return the length of linked list s&#34;&#34;&#34;</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">empty</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">length</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">getitem_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return the element at index i of linked list s.&#34;&#34;&#34;</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>现在, 我们可以用这些函数来把链表当做序列来操作. (我们现在还不能用內建的len函数, 元素选择语法, 或者for语句, 但是很快就可以了)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">len_link</span><span class="p">(</span><span class="n">four</span><span class="p">)</span>
<span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">getitem_link</span><span class="p">(</span><span class="n">four</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">2</span>
</code></pre></td></tr></table>
</div>
</div><p>下面的一系列环境图例演示了<code>getitem_link</code>的找寻链表中下标为1的第二个元素的迭代过程. 下面, 我们已经用Python原语来简化图表来定义链表four. 这种实现选择违反了抽象边界, 但是允许我们更容易检视这个例子的计算过程</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20first(s%29%3A%0A%20%20%20%20return%20s%5B0%5D%0Adef%20rest(s%29%3A%0A%20%20%20%20return%20s%5B1%5D%0A%0Adef%20getitem_link(s,%20i%29%3A%0A%20%20%20%20while%20i%20%3E%200%3A%0A%20%20%20%20%20%20%20%20s,%20i%20%3D%20rest(s%29,%20i%20-%201%0A%20%20%20%20return%20first(s%29%0A%0Afour%20%3D%20%5B1,%20%5B2,%20%5B3,%20%5B4,%20'empty'%5D%5D%5D%5D%0Agetitem_link(four,%201%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>首先, 函数<code>getitem_link</code>被调用, 创建了一个本地帧:</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20first(s%29%3A%0A%20%20%20%20return%20s%5B0%5D%0Adef%20rest(s%29%3A%0A%20%20%20%20return%20s%5B1%5D%0A%0Adef%20getitem_link(s,%20i%29%3A%0A%20%20%20%20while%20i%20%3E%200%3A%0A%20%20%20%20%20%20%20%20s,%20i%20%3D%20rest(s%29,%20i%20-%201%0A%20%20%20%20return%20first(s%29%0A%0Afour%20%3D%20%5B1,%20%5B2,%20%5B3,%20%5B4,%20'empty'%5D%5D%5D%5D%0Agetitem_link(four,%201%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>while头部的表达式计算得到true, 然后while的内部等式会被执行, 函数<code>rest</code>返回以2开头的子列表.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20first(s%29%3A%0A%20%20%20%20return%20s%5B0%5D%0Adef%20rest(s%29%3A%0A%20%20%20%20return%20s%5B1%5D%0A%0Adef%20getitem_link(s,%20i%29%3A%0A%20%20%20%20while%20i%20%3E%200%3A%0A%20%20%20%20%20%20%20%20s,%20i%20%3D%20rest(s%29,%20i%20-%201%0A%20%20%20%20return%20first(s%29%0A%0Afour%20%3D%20%5B1,%20%5B2,%20%5B3,%20%5B4,%20'empty'%5D%5D%5D%5D%0Agetitem_link(four,%201%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>接下来, 局部名称s会更新成以原列表第二个元素为开头的子列表的引用. 运算while头部表达式现在会返回false值, 然后Python运算在返回语句之后的<code>getitem_link</code>的最后一行表达式.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20first(s%29%3A%0A%20%20%20%20return%20s%5B0%5D%0Adef%20rest(s%29%3A%0A%20%20%20%20return%20s%5B1%5D%0A%0Adef%20getitem_link(s,%20i%29%3A%0A%20%20%20%20while%20i%20%3E%200%3A%0A%20%20%20%20%20%20%20%20s,%20i%20%3D%20rest(s%29,%20i%20-%201%0A%20%20%20%20return%20first(s%29%0A%0Afour%20%3D%20%5B1,%20%5B2,%20%5B3,%20%5B4,%20'empty'%5D%5D%5D%5D%0Agetitem_link(four,%201%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>最后的环境图例显示调用first的本地帧, 也就是含有绑定到同一个子列表的名称s. first函数选择值2然后返回, 也会从<code>getitem_link</code>中返回.</p>
<p>这个例子演示了一个列表计运算的一般模式, 迭代操作中的每一步都会不断得到原列表中较短的后缀. 这查找列表长度以及元素的增量处理过程需要一些时间来运算. Python的內建序列类型是用不同形式实现的, 这让计算序列长度或者检索它的元素都不会导致很大的计算成本. 这种表现的细节已经超出本文的范围.</p>
<p><strong>递归操作</strong>. <code>len_link</code>以及<code>getitem_link</code>函数都是迭代的. 它们不断剥离每一层的嵌套数据对直到到达到达列表的最后(在<code>len_link</code>函数中)或者到达期望的元素(在<code>getitem_link</code>中).我们也可以用递归来实现长度以及元素选择.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">len_link_recursive</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return the length of a linked list s.&#34;&#34;&#34;</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">len_link_recursive</span><span class="p">(</span><span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">getitem_link_recursive</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return the element at index i of linked list s.&#34;&#34;&#34;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">getitem_link_recursive</span><span class="p">(</span><span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">len_link_recursive</span><span class="p">(</span><span class="n">four</span><span class="p">)</span>
<span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">getitem_link_recursive</span><span class="p">(</span><span class="n">four</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">2</span>
</code></pre></td></tr></table>
</div>
</div><p>这些递归实现跟随数据对组成的链直到到达列表的最后(在<code>len_link_recursive</code>中)或者到达期望的元素(在<code>getitem_link_recursive</code>中).</p>
<p>递归对于转换以及合并链表也是有用的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">extend_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a list with the elements of s followed by those of t.&#34;&#34;&#34;</span>
        <span class="k">assert</span> <span class="n">is_link</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_link</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">link</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">extend_link</span><span class="p">(</span><span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">t</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">extend_link</span><span class="p">(</span><span class="n">four</span><span class="p">,</span> <span class="n">four</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;empty&#39;</span><span class="p">]]]]]]]]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">apply_to_all_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Apply f to each element of s.&#34;&#34;&#34;</span>
        <span class="k">assert</span> <span class="n">is_link</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">link</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">apply_to_all_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">apply_to_all_link</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">four</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="s1">&#39;empty&#39;</span><span class="p">]]]]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">keep_if_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a list with elements of s for which f(e) is true.&#34;&#34;&#34;</span>
        <span class="k">assert</span> <span class="n">is_link</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kept</span> <span class="o">=</span> <span class="n">keep_if_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">link</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">kept</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">kept</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">keep_if_link</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">four</span><span class="p">)</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;empty&#39;</span><span class="p">]]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">join_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">separator</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a string of all elements in s separated by separator.&#34;&#34;&#34;</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&#34;&#34;</span>
        <span class="k">elif</span> <span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="o">+</span> <span class="n">separator</span> <span class="o">+</span> <span class="n">join_link</span><span class="p">(</span><span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">separator</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">join_link</span><span class="p">(</span><span class="n">four</span><span class="p">,</span> <span class="s2">&#34;, &#34;</span><span class="p">)</span>
<span class="s1">&#39;1, 2, 3, 4&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>递归构建</strong>. 链表在我们增量地构造序列的时候尤其有用, 这种情况经常在递归计算中出现.</p>
<p>第一章中的<code>count_partitions</code>函数通过树递归过程来计算整数n用最大为m的数来进行分割的总数. 通过序列我们也可以通过明确地使用相似的过程来枚举这些切分.</p>
<p>跟我们计算时一样, 我们用跟随问题的相同递归分析: 用最大为m的整数来划分n涉及到</p>
<ol>
<li>使用最大为m的整数来划分n-m, 或者</li>
<li>使用最大为m-1的整数来划分n</li>
</ol>
<p>对于基本情况, 我们发现用一个负整数或者用小于1的部分来划分0是不可能的, 因此0的划分数为空.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a linked list of partitions of n using parts of up to m.
</span><span class="s2">        Each partition is represented as a linked list.
</span><span class="s2">        &#34;&#34;&#34;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">link</span><span class="p">(</span><span class="n">empty</span><span class="p">,</span> <span class="n">empty</span><span class="p">)</span> <span class="c1"># A list containing the empty partition</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">empty</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">using_m</span> <span class="o">=</span> <span class="n">partitions</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">with_m</span> <span class="o">=</span> <span class="n">apply_to_all_link</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">link</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="n">using_m</span><span class="p">)</span>
            <span class="n">without_m</span> <span class="o">=</span> <span class="n">partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">extend_link</span><span class="p">(</span><span class="n">with_m</span><span class="p">,</span> <span class="n">without_m</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>在递归情况下, 我们构建两个分区的子列表. 第一个用m, 因此我们在结果<code>using_m</code>中的每个元素前面加上m来构建<code>with_m</code>.</p>
<p>partitions的结果是高度嵌套的: 一个链接列表的链接列表, 并且每个链接列表被表示为作为列表值的嵌套对. 在<code>join_link</code>函数中用恰当的分隔符, 我们可以用人类可阅读的方式来展示出分区.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">print_partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">lists</span> <span class="o">=</span> <span class="n">partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">strings</span> <span class="o">=</span> <span class="n">apply_to_all_link</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">join_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">&#34; + &#34;</span><span class="p">),</span> <span class="n">lists</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">join_link</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">print_partitions</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span>
<span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span>
<span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
<span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="24-可变数据">2.4 可变数据</h3>
<p>我们已经见识过抽象对于帮助我们应对大型系统的复杂性上的重要性了. 有效的编程依赖于有组织的能够指导我们在制定程序的整体设计的规则. 尤其是, 我们需要很多策略来帮助我们构造模块化的大型系统, 这意味着它们会自然分裂成各个相关的部分且能够分头开发以及维护.</p>
<p>有一个强大的创建模块化程序的技术, 那就是合并可能随时间改变状态的数据, 通过这种方式, 单个数据对象可以表示独立于程序的其余部分演进的东西. 改变对象的行为可能会受到其历史的影响, 就像一个真实世界的实体一样. 为数据添加状态是面向对象编程范式的核心要素</p>
<h4 id="241-对象隐喻">2.4.1 对象隐喻</h4>
<p>在本文开头, 我们要区分函数跟数据: 函数用于执行操作, 而数据则是在其上被操作. 当我们在我们的数据中包含函数的值的时候, 我们认识到数据也可以具有行为. 函数可以作为数据来操作, 也可以被调用来执行计算.</p>
<p><em>对象</em>将数据值与行为进行组合. 对象代表信息, 同时也表现得像它们所代表的事物. 一个对象跟另一个对象互动的逻辑是跟编码这个对象的值捆绑在一起的. 当一个对象需要被打印出来时, 它知道如何用文本来表示自身, 如果一个对象是由部分组合而成的, 那么它知道如何按需显示这些部分. 对象(包含的)全都是信息以及(处理)过程, (它们)捆绑在一起来表示复杂事物的性质, 相互作用和行为.</p>
<p>对象的行为在Python中是通过专门的对象语法以及相关术语来实现的, 我们可以通过例子来进行介绍, 一个日期是一个对象.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span>
</code></pre></td></tr></table>
</div>
</div><p>名称<code>date</code>绑定到一个类上的. 正如我们看到的, 一个类代表一种值. 个别的日期就叫做这个类的实例. 实例能够通过使用表明这个实例的特征参数来调用类来构建.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">tues</span> <span class="o">=</span> <span class="n">date</span><span class="p">(</span><span class="mi">2014</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>当用原始数字构造<code>tues</code>之后, 它的行为表现得像日期一样, 例如, 将它跟其他的日期相减会返回一个时差, 我们可以打印出来.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">date</span><span class="p">(</span><span class="mi">2014</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">19</span><span class="p">)</span> <span class="o">-</span> <span class="n">tues</span><span class="p">)</span>
<span class="mi">6</span> <span class="n">days</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mo">00</span>
</code></pre></td></tr></table>
</div>
</div><p>对象具有<em>属性</em>, 是一个命名后的对象的一部分的值. 在Python中, 像很多其他的编程语言一样, 我们用点符号来指定一个对象的属性.</p>
<p><code>&lt;expression&gt; . &lt;name&gt;</code></p>
<p>上面, <code>&lt;expression&gt;</code>是一个对象, 然后<code>&lt;name&gt;</code>是一个对象属性的名称. 不我们至今为止考虑过的名称, 属性名对于点符号前面的对象实例来说是独特的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">tues</span><span class="o">.</span><span class="n">year</span>
<span class="mi">2014</span>
</code></pre></td></tr></table>
</div>
</div><p>对象通常也有方法, 也就是属性值为函数的属性. 隐含的意思是, 我们认为这个对象&quot;知道&quot;如何去执行这些方法. 通过实现, (对象)方法是一个用来从它们的参数以及它们的对象中计算结果的函数. 例如, <code>tues</code>有一个<code>strftime</code>方法(一个经典函数的名称, 意思是&quot;字符串格式的时间&rdquo;)接受一个参数用于指定如何显示日期(例如: %A表示这周的某一天应该完整地拼写出来).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">tues</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&#34;%A, %B </span><span class="si">%d</span><span class="s2">&#34;</span><span class="p">)</span>
<span class="s1">&#39;Tuesday, May 13&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>计算<code>strftime</code>的返回值需要两个输入: 一个用于描述输出格式的字符串以及绑定在tues中的日期信息. 特定日期逻辑需要应用这个方法来返回结果. 我们从来没有说过2014年5月13号是星期二, 但是知道它对应的是工作日的一部分, 这就意味着它是一个日期. 通过将行为以及信息绑定到一起, 这个Python对象提供给我们一个可信的, 自足的日期抽象.</p>
<p>日期是一个对象, 而且数字, 符串吗, 列表以及区间等也全都是对象. 它们代表一个值, 而且还以符合它们表示的值的方式表现. 它们也有属性以及方法. 比如, 字符串具有一个数组方法用于方便文本处理.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="s1">&#39;1234&#39;</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">()</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s1">&#39;rOBERT dE nIRO&#39;</span><span class="o">.</span><span class="n">swapcase</span><span class="p">()</span>
<span class="s1">&#39;Robert De Niro&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s1">&#39;eyes&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;YES&#39;</span><span class="p">)</span>
<span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p>实际上, 在Python中所有的值都是对象, 也就是说, 所有值都具有行为以及属性. 它们的行为就像它们所代表的值.</p>
<h4 id="242-序列对象">2.4.2 序列对象</h4>
<p>原始內建的值的实例如数字是不可变的. 这个值在程序的执行过程中是不可变的. 而另一方面列表则是可变的.</p>
<p>可变对象用来代表随时间变化的值. 一个人是在今天到明天依然是同一个人, 尽管变得老了, 剪了头发, 或者以某种方式改变了. 同样地, 一个对象的属性可能会由于可变操作而改变了属性. 例如, 可以改变列表中的内容. 大多数改变通过调用执行列表对象内部的方法.</p>
<p>我们可以通过一个说明扑克牌历史的例子(大大简化)来介绍很多列表的修改操作. 在例子的注释中, 描述了每个方法调用的结果.</p>
<p>扑克牌是在中国发明的, 大约在9世纪. 较早的扑克牌只有三种花式, 分别跟钱的面额对应起来.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">chinese</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;coin&#39;</span><span class="p">,</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="s1">&#39;myriad&#39;</span><span class="p">]</span> <span class="c1"># 一个文字列表</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">suits</span> <span class="o">=</span> <span class="n">chinese</span> <span class="c1"># 两个名字对应同一个列表</span>
</code></pre></td></tr></table>
</div>
</div><p>随着扑克牌传入欧洲(可能是通过埃及), 只有coin那那个花式还存在西班牙的牌桌上(oro).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">suits</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># 删除最后一个元素并返回</span>
<span class="s1">&#39;myriad&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">suits</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="c1"># 删除跟参数相等的第一个元素</span>
</code></pre></td></tr></table>
</div>
</div><p>新增了三个花式(它们的名字还有设计进行了几次更改).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">suits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;cup&#39;</span><span class="p">)</span> <span class="c1"># 添加一个元素到最后</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">suits</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;sword&#39;</span><span class="p">,</span> <span class="s1">&#39;club&#39;</span><span class="p">])</span> <span class="c1"># 将所有的元素添加到序列的最后</span>
</code></pre></td></tr></table>
</div>
</div><p>然后意大利人将剑叫做锹.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">suits</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;spade&#39;</span> <span class="c1"># 替代一个元素</span>
</code></pre></td></tr></table>
</div>
</div><p>得到一副传统的意大利扑克牌.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">suits</span>
<span class="p">[</span><span class="s1">&#39;coin&#39;</span><span class="p">,</span> <span class="s1">&#39;cup&#39;</span><span class="p">,</span> <span class="s1">&#39;spade&#39;</span><span class="p">,</span> <span class="s1">&#39;club&#39;</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>今天美国用的扑克牌是法国的变种, 修改了前两个花式:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">suits</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;heart&#39;</span><span class="p">,</span> <span class="s1">&#39;diamond&#39;</span><span class="p">]</span> <span class="c1"># 修改一个切片</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">suits</span>
<span class="p">[</span><span class="s1">&#39;heart&#39;</span><span class="p">,</span> <span class="s1">&#39;diamond&#39;</span><span class="p">,</span> <span class="s1">&#39;spade&#39;</span><span class="p">,</span> <span class="s1">&#39;club&#39;</span><span class="p">]]</span>
</code></pre></td></tr></table>
</div>
</div><p>还存在用于插入, 排序, 以及翻转列表的方法. 所有这些变动的操作都会修改列表的值; 它们不会创建一个新的列表对象.</p>
<p><strong>共享和标识</strong>. 由于我们已经修改单个列表, 而不是创建一个新的列表, 因此对象绑定的名称<code>chinese</code>的值同样也会改变, 因为它跟suits绑定的是同一个列表对象.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">chinese</span>  <span class="c1"># 名称跟&#34;suits&#34;共同指代同一个被修改的列表</span>
<span class="p">[</span><span class="s1">&#39;heart&#39;</span><span class="p">,</span> <span class="s1">&#39;diamond&#39;</span><span class="p">,</span> <span class="s1">&#39;spade&#39;</span><span class="p">,</span> <span class="s1">&#39;club&#39;</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>这种行为是新的. 早先, 如果一个名称没有出现在一个语句中, 那么它的值就不会被这个语句影响到. 对于可变数据, 在一个名称上调用方法能够同时影响到其他的名称.</p>
<p>对于这里例子, 下面的运行环境图展示了跟chinese名称绑定的值是如何在只涉及到suits的语句中被修改的. 观察例子中的每一个步骤来查看这些改变.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=chinese%20%3D%20%5B'coin',%20'string',%20'myriad'%5D%0Asuits%20%3D%20chinese%0Asuits.pop(%29%0Asuits.remove('string'%29%0Asuits.append('cup'%29%0Asuits.extend(%5B'sword',%20'club'%5D%29%0Asuits%5B2%5D%20%3D%20'spade'%0Asuits%5B0%3A2%5D%20%3D%20%5B'heart',%20'diamond'%5D&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>列表对象可以用列表构造器函数来复制. 修改一个列表不会影响到另外一个, 除非它们共享相同的数据结构.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">nest</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">suits</span><span class="p">)</span> <span class="c1"># 绑定&#34;nest&#34;到第二个具有相同元素的列表中</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">nest</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">suits</span> <span class="c1"># 创建一个嵌套的列表</span>
</code></pre></td></tr></table>
</div>
</div><p>根据这种环境, 通过suits引用来修改列表会影响到nest的第一个元素的那个内嵌的列表, 但是不会对其他的元素有影响.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">suits</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Joker&#39;</span><span class="p">)</span>  <span class="c1"># 在下标为2的地方插入一个元素, 其他的元素进行响应的移位</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">nest</span>
<span class="p">[[</span><span class="s1">&#39;heart&#39;</span><span class="p">,</span> <span class="s1">&#39;diamond&#39;</span><span class="p">,</span> <span class="s1">&#39;Joker&#39;</span><span class="p">,</span> <span class="s1">&#39;spade&#39;</span><span class="p">,</span> <span class="s1">&#39;club&#39;</span><span class="p">],</span> <span class="s1">&#39;diamond&#39;</span><span class="p">,</span> <span class="s1">&#39;spade&#39;</span><span class="p">,</span> <span class="s1">&#39;club&#39;</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>同样地, 在nest的第一个元素中撤销这个改动同样也会影响到suit</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">nest</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="s1">&#39;Joker&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">suits</span>
<span class="p">[</span><span class="s1">&#39;heart&#39;</span><span class="p">,</span> <span class="s1">&#39;diamond&#39;</span><span class="p">,</span> <span class="s1">&#39;spade&#39;</span><span class="p">,</span> <span class="s1">&#39;club&#39;</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=suits%20%3D%20%5B'heart',%20'diamond',%20'spade',%20'club'%5D%0Anest%20%3D%20list(suits%29%0Anest%5B0%5D%20%3D%20suits%0Asuits.insert(2,%20'Joker'%29%0Ajoke%20%3D%20nest%5B0%5D.pop(2%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>因为两个列表有可能会有相同的内容, 但是实际上是两个不同的列表, 我们需要一个手段来测试两个对象是否是相同的. Python含有两个比较操作符, 叫做 <code>is</code> 以及 <code>is not</code>, 用来测试两个表达式实际上是否得到的是相同的对象. 如果两个对象它们的当前值是一样的, 然后任何一个的改动都会反映到另一个对象中, 那么两个对象是相等的. 身份标识是比相等性更强的条件.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">suits</span> <span class="ow">is</span> <span class="n">nest</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">suits</span> <span class="ow">is</span> <span class="p">[</span><span class="s1">&#39;heart&#39;</span><span class="p">,</span> <span class="s1">&#39;diamond&#39;</span><span class="p">,</span> <span class="s1">&#39;spade&#39;</span><span class="p">,</span> <span class="s1">&#39;club&#39;</span><span class="p">]</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">suits</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;heart&#39;</span><span class="p">,</span> <span class="s1">&#39;diamond&#39;</span><span class="p">,</span> <span class="s1">&#39;spade&#39;</span><span class="p">,</span> <span class="s1">&#39;club&#39;</span><span class="p">]</span>
<span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p>最后两个比照说明了 <code>==</code> 跟 <code>is</code> 两者的不同, 前者检查身份, 而后者则是检查内容的的相等性</p>
<p><strong>列表推导</strong>. 一个列表推导总是会创建一个新的列表. 例如, <code>unicodedata</code>模块跟踪Unicode字母表中每一个字符的官方名称. 我们可以查找与名称相对应的字符, 包括那些扑克牌的花式.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">unicodedata</span> <span class="kn">import</span> <span class="n">lookup</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">lookup</span><span class="p">(</span><span class="s1">&#39;WHITE &#39;</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39; SUIT&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">suits</span><span class="p">]</span>
<span class="p">[</span><span class="s1">&#39;♡&#39;</span><span class="p">,</span> <span class="s1">&#39;♢&#39;</span><span class="p">,</span> <span class="s1">&#39;♤&#39;</span><span class="p">,</span> <span class="s1">&#39;♧&#39;</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>这些结果列表并没有将它的内容跟suits进行共享, 执行列表表达式也不会改动到suits列表.</p>
<p>你可以在Dive into Python 3中的<a href="http://getpython3.com/diveintopython3/strings.html#one-ring-to-rule-them-all">Unicode章节</a>中, 查看更多相关的用于表示文本的Unicode标准.</p>
<p><strong>元组</strong></p>
<p>一个元组, 是一个內建的<code>tuple</code>类型的实例, 是一个不可变序列. 是用元组字面量, 也就是用逗号分割元素来创建的. 括号是可选的, 但是在实践中经常使用. 任何对象都可以放在元组中.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="s2">&#34;the&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s2">&#34;and&#34;</span><span class="p">,</span> <span class="s2">&#34;only&#34;</span><span class="p">))</span>
<span class="p">(</span><span class="s1">&#39;the&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;only&#39;</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">tuple</span><span class="s1">&#39;&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>空的或者拥有一个元素的元组具有特殊的字面语法.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="p">()</span>    <span class="c1"># 0 elements</span>
<span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="mi">10</span><span class="p">,)</span> <span class="c1"># 1 element</span>
<span class="p">(</span><span class="mi">10</span><span class="p">,)</span>
</code></pre></td></tr></table>
</div>
</div><p>像列表, 元组具有有限的长度, 同时也支持元素选择. 它们同样也具有一些可用于列表的方法, 例如<code>count</code>以及<code>index</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">code</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&#34;up&#34;</span><span class="p">,</span> <span class="s2">&#34;up&#34;</span><span class="p">,</span> <span class="s2">&#34;down&#34;</span><span class="p">,</span> <span class="s2">&#34;down&#34;</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&#34;left&#34;</span><span class="p">,</span> <span class="s2">&#34;right&#34;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
<span class="mi">8</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">code</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="s1">&#39;down&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">code</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&#34;down&#34;</span><span class="p">)</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">code</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&#34;left&#34;</span><span class="p">)</span>
<span class="mi">4</span>
</code></pre></td></tr></table>
</div>
</div><p>然而, 对于那些操作列表内容的方法在元组中是不可用的, 因为元组是不可变的.</p>
<p>因此无法改变元组中的元素, 但是可以修改一个包含在元组中的可变元素的值.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=nest%20%3D%20(10,%2020,%20%5B30,%2040%5D%29%0Anest%5B2%5D.pop(%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>多重赋值中隐式地使用元组, 一个将两个值绑定到两个名称中的赋值语句会创建两个元素的元组然后对它进行解包.</p>
<h4 id="243-字典">2.4.3 字典</h4>
<p>字典在Python中是一个內建的数据类型, 用来存储以及操作对应关系. 一个字典包含有多个键值对, 键跟值都是对象. 字典的目的是提供一个抽象化的用于存储以及检索数据并不以连续的整数而是描述性的键值为下标的地方.</p>
<p>通常用字符串来作为键值, 因为我们常用一个字符串名称来表示一样东西. 这个字典字面量给定各种罗马数字的值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">numerals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用元素选择操作符通过它们的键来查看我们先前应用于序列的对应的值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">numerals</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
<span class="mi">10</span>
</code></pre></td></tr></table>
</div>
</div><p>一个字典中每一个键最多只能有一个对应的值. 添加新的键值对或者通过键来修改已经存在的值都可以通过赋值语句实现.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">numerals</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">numerals</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">50</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">numerals</span>
<span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意到, <code>L</code>的值在前面的输出结果中是没有添加的. 字典是无序的键值对集合. 当我们输出一个字典, 键跟值会以某种顺序渲染, 而作为语言的用户, 我们无法预知将会按照何种顺序渲染. 当多次运行程序时这种顺序可能会改变.</p>
<p>字典也可以在环境图例中出现.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=numerals%20%3D%20%7B'I'%3A%201,%20'V'%3A%205,%20'X'%3A%2010%7D%0Anumerals%5B'L'%5D%20%3D%2050&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>字典类型也支持多种用于迭代它包含的作为一个整体的字典内容的方法, <code>keys</code>, <code>values</code>以及<code>items</code>都返回一个可迭代的值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numerals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="mi">66</span>
</code></pre></td></tr></table>
</div>
</div><p>由键值对形式组成的列表可以通过调用<code>dict</code>构造函数来转化成一个字典.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">dict</span><span class="p">([(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">)])</span>
<span class="p">{</span><span class="mi">3</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">25</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>字典也具有一些限制:</p>
<ul>
<li>字典中的一个键不能对应多个值</li>
<li>对于一个给定的键最多只能有一个值.</li>
</ul>
<p>第一个限制是跟Python字典底层实现相绑定的. 这个限制的细节不是本文的主题. 可以直观地认为键告诉Python在内存中哪里去找这个键值对; 如果这个key值改变了这个对的位置可能就会不见了. 元组通常也是可以在字典中作为键, 因为列表不可以用作键值.</p>
<p>第二个限制是字典抽象的一个必然结果, 那就是设计用一个键来存储以及检索一个值. 如果最多只有一个这样的值存在于字典当中, 我们只能用一个键来检索这个值.</p>
<p>一个由字典来执行的有用的方法是<code>get</code>, 这个方法要么会返回一个存在的键所对应的值, 要么返回一个默认值. 而<code>get</code>方法的参数就是键以及默认值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">numerals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">numerals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">5</span>
</code></pre></td></tr></table>
</div>
</div><p>字典也有一个类似于列表的解析式语法. 一个键表达式以及一个值表达式通过一个冒号隔开, 执行一个字典解析会创建一个新的字典对象.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">)}</span>
<span class="p">{</span><span class="mi">3</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">25</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="244-本地状态">2.4.4 本地状态</h4>
<p>列表跟字典都有本地状态: 它们在程序运行的任意一个点上修改具有特定内容的值. &ldquo;状态&quot;这个词暗示了一个演变的过程, 表示这个状态可能会改变.</p>
<p>函数也可以具有本地状态. 例如, 让我们定义一个函数用于模拟从一个银行账户中提款的过程. 我们会创建一个叫做withdraw的函数, 它把一个数额作为它的参数. 如果这个账户具有足够的金额用于提款, 那么<code>withdraw</code>会返回提款后的剩余余额. 否则, <code>withdraw</code>会返回信息&rsquo;资金不足&rsquo;, 例如, 如果我们开始有$100在账户内, 我们会希望调用<code>withdraw</code>后能够得到下面的一系列的返回值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">withdraw</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>
<span class="mi">75</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">withdraw</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>
<span class="mi">50</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">withdraw</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
<span class="s1">&#39;Insufficient funds&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">withdraw</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="mi">35</span>
</code></pre></td></tr></table>
</div>
</div><p>上面表达式<code>withdraw(25)</code>, 运算了两次, 返回了不同的值. 因此, 这个用户定义函数是不纯的. 调用这个函数不仅返回一个值, 同时还会带有副作用以某种方式来改变这个函数, 因此下一次用相同的参数来调用函数会返回不同的值. 这个副作用是由<code>withdraw</code>函数更改当前环境的一个外部名称值的绑定而造成的.</p>
<p>为了让<code>withdraw</code>函数有意义, 它必须用一个具有余额的初始的账户来创建. 而函数<code>make_withdraw</code>是一个更高层次的函数, 需要一个初始余额作为参数. 而函数withdraw则是它的返回值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">withdraw</span> <span class="o">=</span> <span class="n">make_withdraw</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>make_withdraw</code>的一个实现需要一种新类型的语句: 一个非本地的声明. 当我们调用<code>make_withdraw</code>时, 我们绑定名称<code>balance</code>到一个初始账户中. 然后我们定义并返回一个本地函数<code>withdraw</code>, 当调用这个函数时会更新以及返回<code>balance</code>的值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">make_withdraw</span><span class="p">(</span><span class="n">balance</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a withdraw function that draws down balance with each call.&#34;&#34;&#34;</span>
        <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="n">amount</span><span class="p">):</span>
            <span class="n">nonlocal</span> <span class="n">balance</span>
            <span class="k">if</span> <span class="n">amount</span> <span class="o">&gt;</span> <span class="n">balance</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;Insufficient funds&#39;</span>
            <span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span> <span class="o">-</span> <span class="n">amount</span>
            <span class="k">return</span> <span class="n">balance</span>
        <span class="k">return</span> <span class="n">withdraw</span>
</code></pre></td></tr></table>
</div>
</div><p><code>nonlocal</code>语句声明了无论任何时候我们改变名称<code>balance</code>的绑定值, 都会反映到这个<code>balance</code>第一个找到的绑定值的环境帧里面. 回想一下没有<code>nonlocal</code>声明, 一个赋值语句总是会绑定绑定一个名称到它的当前环境的第一个帧里面. 这个<code>nonlocal</code>语句表示名称出现在环境中除第一(本地)帧或最后(全局)帧之外的某处.</p>
<p>接下来的环境图例演示了多次调用<code>make_withdraw</code>创建的函数的影响.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20make_withdraw(balance%29%3A%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20nonlocal%20balance%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20balance%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20balance%20%3D%20balance%20-%20amount%0A%20%20%20%20%20%20%20%20return%20balance%0A%20%20%20%20return%20withdraw%0A%0Awd%20%3D%20make_withdraw(20%29%0Awd(5%29%0Awd(3%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>第一个def语句具有通常的效果: 它创建了一个新的用户定义函数并在全局环境绑定名称<code>make_withdraw</code>到这个函数. 而随后调用<code>make_withdraw</code>创建并返回了一个本地定义的函数<code>withdraw</code>. 名称<code>balance</code>绑定在这个函数的父级帧中. 至关重要的是, 在该示例的其余部分中将仅存在用于名称<code>balance</code>的单个绑定.</p>
<p>接下来, 我们执行一个表达式来用金额为5的参数来调用这个绑定到名称wd上的函数. <code>withdraw</code>的函数体执行在新的拓展自<code>withdraw</code>被定义的的环境中. 跟踪函数<code>withdraw</code>的运行, 演示了<code>nonlocal</code>语句在Python中的效果: 一个在第一个局部帧外面的的名称能够通过赋值语句来修改.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20make_withdraw(balance%29%3A%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20nonlocal%20balance%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20balance%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20balance%20%3D%20balance%20-%20amount%0A%20%20%20%20%20%20%20%20return%20balance%0A%20%20%20%20return%20withdraw%0A%0Awd%20%3D%20make_withdraw(20%29%0Awd(5%29%0Awd(3%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p><code>nonlocal</code>声明在<code>withdraw</code>的定义内修改所有剩余的赋值语句. 在执行<code>nonlocal balance</code>之后, 任何跟<code>balance</code>相关的把它放在等号左边的赋值语句都不会绑定<code>balance</code>到当前环境的第一帧里去. 相反, 它会找到<code>balance</code>已经被定义的第一个帧然后在这一帧内将把名称进行重新的绑定. 如果<code>balance</code>之前并没有跟一个值进行绑定, 那么<code>nonlocal</code>语句会抛出一个错误.</p>
<p>通过修改<code>balance</code>的绑定, 我们也修改了<code>withdraw</code>函数. 下一次它被调用时, 名称<code>balance</code>会执行15而不是20. 因此, 当我们第二次调用<code>withdraw</code>时, 我们会看到它返回值12而不是17. 第一次调用对<code>balance</code>的修改会反映到第二次调用的结果中去.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20make_withdraw(balance%29%3A%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20nonlocal%20balance%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20balance%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20balance%20%3D%20balance%20-%20amount%0A%20%20%20%20%20%20%20%20return%20balance%0A%20%20%20%20return%20withdraw%0A%0Awd%20%3D%20make_withdraw(20%29%0Awd(5%29%0Awd(3%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>通常来说, 第二次调用<code>withdraw</code>会创建第二个本地帧. 然而, 两个<code>withdraw</code>帧具有相同的父级. 也就是说, 它们都拓展自那个包含有<code>balance</code>的绑定的<code>make_withdraw</code>的环境中. 因此, 它们共享那个特定的名称绑定. 调用<code>withdraw</code>函数具有改变环境的局部影响, 且会把这个影响延展到<code>withdraw</code>未来的调用中去. <code>nonlocal</code>声明允许<code>withdraw</code>函数来改变<code>make_withdraw</code>帧中的名称的绑定.</p>
<p>自从我们第一次遇到嵌套的def语句以来, 我们已经意识到本地定义函数可以访问它本地帧以外的名称. 访问非本地名称不需要<code>nonlocal</code>语句. 相比之下, 只有在<code>nonlocal</code>声明之后, 一个函数才能在这些帧里面修改名称的绑定.</p>
<p>通过介绍<code>nonlocal</code>声明, 我们已经为赋值语句创建了一个双重角色. 不管它们是修改本地绑定, 还是修改<code>nonlocal</code>绑定. 实际上, 赋值语句已经具有了双重性, 它们不仅可以创建新的绑定也可以重新绑定已经存在的名称. 赋值也可以修改列表以及字典的内容. Python中赋值中的许多角色会掩盖执行赋值语句的影响. 这取决于你作为一个程序员是如何文档化你的代码以清晰地表明赋值的影响来让其他人可以明白.</p>
<p><strong>Python细节</strong>. 这种<code>non-local</code>模式的赋值是一个具有高阶函数以及词法作用域的编程语言的一般特性. 大部分其他的编程语言一点都不需要<code>nonlocal</code>声明. 反而, <code>non-local</code>赋值通常是赋值语句的默认行为.</p>
<p>Python对于名称的查找也具有一个不同寻常的限制: 在函数体内, 所有的名称的实例必须要指向同一帧. 因此, Python在一个<code>non-local</code>帧内不能查找到名称的值, 并绑定相同的名称到本地帧内, 因为相同的名称会在两个不同的帧内被同一个程序访问到. 这个限制允许Python在函数体执行前预先计算包含每个名称的帧. 当这个限制被违反时, 会产生混乱的错误结果信息. 作为演示, 下面重复<code>make_withdraw</code>示例, 并去除nonlocal语句.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20make_withdraw(balance%29%3A%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20balance%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20balance%20%3D%20balance%20-%20amount%0A%20%20%20%20%20%20%20%20return%20balance%0A%20%20%20%20return%20withdraw%0A%0Awd%20%3D%20make_withdraw(20%29%0Awd(5%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>出现了这个<code>UnboundLocalError</code>错误是因为<code>balance</code>在第五行被本地分配了一个本地值, 因此Python假设所有对<code>balance</code>的引用也必须出现在本地帧内. 这个错误出现在第五行被执行前, 意味着Python在执行第三行之前已经以某种方式考虑了第五行. 当我们学习解析器设计时, 我们会了解到在函数体执行之前进行预编译是相当普遍的事情. 在这个例子中, Python的预编译限制帧内可能出现<code>balance</code>, 因此预先阻止找到该名称. 添加一个<code>nonlocal</code>声明可以修复这个错误. <code>nonlocal</code>声明在Python 2中是不存在的.</p>
<h4 id="非本地赋值的好处">非本地赋值的好处</h4>
<p>非本地赋值在我们将程序看作是一个独立与自治的对象(也就是对象之间相互交互但各自管理他们自己内部的状态)的路上是重要的一步.</p>
<p>尤其是非本地赋值赋予了我们能力来管理一些函数的内部状态, 但是在调用这个函数时会发展出过度的连续性. <code>balance</code>与特定的<code>withdraw</code>函数相联系并共享于这函数的所有调用中. 然而为<code>balance</code>绑定到相联系的withdraw实例在程序的其余地方是不可访问的. 只有<code>wd</code>在它定义的<code>make_withdraw</code>帧内是可访问的. 如果<code>make_withdraw</code>再次被调用那么它会创建包含一个单独的<code>balance</code>绑定的一个单独的帧.</p>
<p>我们可以扩展我们的例子来演示这一点. 第二次调用<code>make_withdraw</code>返回第二个具有一个不同父级的<code>withdraw</code>函数.我们绑定这第二个函数到全局帧的名称wd2上.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20make_withdraw(balance%29%3A%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20nonlocal%20balance%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20balance%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20balance%20%3D%20balance%20-%20amount%0A%20%20%20%20%20%20%20%20return%20balance%0A%20%20%20%20return%20withdraw%0A%0Awd%20%3D%20make_withdraw(20%29%0Awd2%20%3D%20make_withdraw(7%29%0Awd2(6%29%0Awd(8%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>现在我们可以看到那里其实有两个对<code>balance</code>的绑定在两个不同的帧里面，同时每一个<code>withdraw</code>函数都有一个不同的父级. 名称wd绑定到一个具有<code>balance</code>为20的函数上, 同时wd2绑定到一个具有<code>balance</code>为7的不同函数上.</p>
<p>调用wd2会修改它的非本地绑定名称<code>balance</code>, 但不会影响绑定到<code>withdraw</code>名称的函数. wd之后的调用不会受到wd2中改变的<code>balance</code>的影响, 它的<code>balance</code>依然是20</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20make_withdraw(balance%29%3A%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20nonlocal%20balance%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20balance%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20balance%20%3D%20balance%20-%20amount%0A%20%20%20%20%20%20%20%20return%20balance%0A%20%20%20%20return%20withdraw%0A%0Awd%20%3D%20make_withdraw(20%29%0Awd2%20%3D%20make_withdraw(7%29%0Awd2(6%29%0Awd(8%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>通过这种方式, 每一个<code>withdraw</code>的实例维护着它自己的<code>balance</code>状态, 但是这个状态对于程序中其他任何一个函数来说都是不可访问的. 在高层级来看这种情况, 我们已经创建了一个会管理它自己的内部但是以某种方式活动的生活中的账户模型的银行账户的抽象.</p>
<h4 id="246-非本地赋值的成本">2.4.6 非本地赋值的成本</h4>
<p>我们的计算环境模型清晰地拓展到解释非本地赋值的影响. 然而, 非本地赋值介绍了一些在我们思考名称以及值的方式上的重要的细微差别.</p>
<p>之前, 我们的值是不会修改的; 只有我们的名称以及绑定会修改, 当两个名称a以及b都绑定到一个值 4 上时, 它们是否绑定到相同的或者是不同的 4 是无所谓的, 据我们所知, 只有一个 4 对象且从不改变.</p>
<p>然而, 具有状态的函数不是以这种行为方式. 当两个名称 wd 以及 wd2 都绑定到一个<code>withdraw</code>函数上时, 对于它们是否绑定到同一个函数或者这个函数的不同实例上是有关系的. 考虑一下下面的例子, 它与我们刚刚分析的例子相对比. 在这种情况下, 调用命名为 wd2 的函数会修改命名为 wd 的函数的值, 因为这些名字都是引用同一个函数.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20make_withdraw(balance%29%3A%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20nonlocal%20balance%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20balance%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20balance%20%3D%20balance%20-%20amount%0A%20%20%20%20%20%20%20%20return%20balance%0A%20%20%20%20return%20withdraw%0A%0Awd%20%3D%20make_withdraw(12%29%0Awd2%20%3D%20wd%0Awd2(1%29%0Awd(1%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>世界上用两个名称共同引用同一个值是很常见的, 所以它存在我们的程序当中. 但是, 值会随着时间而变化, 我们必须要小心理解对于修改其他名称而影响到这些名称会带来的结果.</p>
<p>正确地分析带有分本地赋值的代码的关键是要记住, 只有函数调用可以引入新的帧. 赋值语句总是在已存在的帧内修改绑定. 在这种情况下, 除非调用<code>make_withdraw</code>两次, 否则只能绑定一次<code>balance</code>.</p>
<p><strong>相同和改变</strong>. 提出这些细微之处是因为随着会修改分本地环境的非纯函数的引入, 我们已经改变了表达式的性质. 一个表达式只包含纯函数调用的话是可靠透明的; 如果我们用其子表达式的值替换其子表达式之一, 它的值不会修改.</p>
<p>重新绑定操作符违反了透明引用这个条件因为它们除了返回一个值还做了更多的事情; 它们修改了环境. 当我们引入任意重绑定, 我们就遇到了一个棘手的认识论问题: 它意味着两个值是相等的. 在我们的计算环境模型中, 分别定义的两个函数不是相同的, 因为修改一个应该不会关联到另外一个.</p>
<p>一般来说, 只要我们从来没有修改数据对象, 我们可以认为复合数据对象恰好就是它所有部分的总和. 例如, 一个有理数取决于给定它一个分子和分母. 但是这种观点在存在变化的情况下已经不在有效, 也就是一个复合数据对象具有一个&quot;身份标识&rdquo;, 用来跟它组成的片段来进行区分的. 一个银行账户依然是&quot;同一个&quot;银行账户, 即使我们通过支取来修改了余额; 反过来, 我们可以有两个恰巧有相同余额的账户, 但是是两个不同的对象.</p>
<p>尽管它引入了复杂性, 非本地赋值依然是一个创建模块化程序的强力工具. 程序的不同部分对应着不同的环境帧, 能够随着软件的执行来分别演进. 此外, 使用带有本地状态的函数, 我们能够实现可变数据类型. 实际上, 我们可以实现相当于上面提到的內建的list以及dict类型的抽象数据类型.</p>
<h4 id="247-列表以及字典的实现">2.4.7 列表以及字典的实现</h4>
<p>Python语言并不允许我们访问列表的实现, 只是內建了序列抽象以及变动方法到语言里面去. 可以通过具有本地状态的函数来理解可变列表是如何进行表示的, 现在我们将会开发一个可变的链表实现.</p>
<p>我们会通过一个具有链表作为它的本地状态的函数来表现一个可变链表, 列表需要有一个身份, 就像其他任何可变值. 尤其是, 我们不能用 None 来代表一个空的可变列表, 因为两个空的列表不是相同的值(例如: 为其中一个列表插入元素并不会插入到另一个当中), 但是 None 就是 None. 另一方面, 两个都具有<code>empty</code>作为它的本地状态的不同的函数将足以用来区分两个空列表.</p>
<p>如果一个可变链表是一个函数, 它会需要什么传入什么参数呢? 答案展示了编程中的一般模式: 这个函数是一个调度函数同时它的参数首先是一个消息, 后面跟着参数化该方法的其他参数. 这个消息是一个字符串名称表示这个函数应该做什么. 调度函数实际上集合了许多的函数: 用消息确定函数的行为, 以及将额外的参数用在这个行为上.</p>
<p>我们的可变列表会回应5种不同的消息: <code>len</code>, <code>getitem</code>, <code>push_first</code>, <code>pop_first</code>, 以及<code>str</code>. 前两个实现序列抽象的行为. 接下来的两个用于增加或者移除列表的第一个元素. 最后一个消息返回代表整个链表的字符串.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">mutable_link</span><span class="p">():</span>
        <span class="s2">&#34;&#34;&#34;Return a functional implementation of a mutable linked list.&#34;&#34;&#34;</span>
        <span class="n">contents</span> <span class="o">=</span> <span class="n">empty</span>
        <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;len&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">len_link</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;getitem&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">getitem_link</span><span class="p">(</span><span class="n">contents</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;push_first&#39;</span><span class="p">:</span>
                <span class="n">contents</span> <span class="o">=</span> <span class="n">link</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">contents</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;pop_first&#39;</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">first</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
                <span class="n">contents</span> <span class="o">=</span> <span class="n">rest</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">f</span>
            <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;str&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">join_link</span><span class="p">(</span><span class="n">contents</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dispatch</span>
</code></pre></td></tr></table>
</div>
</div><p>我们也可以增加一个简便函数来从任何的內建序列中构造一个实现了功能的链表, 简单地相反的顺序来添加每一个元素.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">to_mutable_link</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a functional list with the same contents as source.&#34;&#34;&#34;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">mutable_link</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="n">s</span><span class="p">(</span><span class="s1">&#39;push_first&#39;</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>
</code></pre></td></tr></table>
</div>
</div><p>在上面的定义中, 函数<code>reversed</code>接受并返回一个可迭代的值; 这是另一个函数处理序列的例子.</p>
<p>到现在, 我们可以构造一个实现了功能的可变链表. 要注意这个链表本身是一个函数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">to_mutable_link</span><span class="p">(</span><span class="n">suits</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">function</span><span class="s1">&#39;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="s1">&#39;str&#39;</span><span class="p">))</span>
<span class="n">heart</span><span class="p">,</span> <span class="n">diamond</span><span class="p">,</span> <span class="n">spade</span><span class="p">,</span> <span class="n">club</span>
</code></pre></td></tr></table>
</div>
</div><p>此外, 我们可以输入信息到列表 <code>s</code> 来改变它的内容, 为实例移除它的第一个元素.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="p">(</span><span class="s1">&#39;pop_first&#39;</span><span class="p">)</span>
<span class="s1">&#39;heart&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="s1">&#39;str&#39;</span><span class="p">))</span>
<span class="n">diamond</span><span class="p">,</span> <span class="n">spade</span><span class="p">,</span> <span class="n">club</span>
</code></pre></td></tr></table>
</div>
</div><p>原则上, <code>push_first</code>以及<code>pop_first</code>足以对列表进行任意更改. 我们可以总是清空整个列表然后用期望的结果来替换它的旧内容.</p>
<p><strong>消息传递</strong>. 给定一些时间, 我们可以实现很多Python列表的有用的变动操作. 例如<code>extend</code>以及<code>insert</code>. 对此我们可以进行选择: 我们可以使用已存在的消息<code>pop_first</code>以及<code>push_first</code>来进行所有的更改将它们都实现在一个函数里面. 或者, 我们可以添加额外的<code>elif</code>条件到<code>dispatch</code>函数体中, 每一个对一种消息进行检查(例如: <code>extend</code>)以及直接应用适当的修改到内容当中.</p>
<p>第二种方法, 就是将所有操作的逻辑封装到响应不同消息的一个函数内的数据值上, 这是一种称为消息传递的规则. 一个使用消息传递来定义调度函数的程序, 每一个这种函数都可以具有局部状态, 以及通过传递&quot;消息&quot;作为第一个参数来组织计算. 消息是对应特殊行为的字符串.</p>
<p><strong>实现字典</strong>. 我们还可以实现一个具有跟字典类似行为的值. 在这种情况下, 我们用一个键值对的列表来保存字典的内容. 每个对是一个两个元素的列表.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">dictionary</span><span class="p">():</span>
        <span class="s2">&#34;&#34;&#34;Return a functional implementation of a dictionary.&#34;&#34;&#34;</span>
        <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">getitem</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">records</span> <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">value</span>
        <span class="k">def</span> <span class="nf">setitem</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="n">nonlocal</span> <span class="n">records</span>
            <span class="n">non_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">records</span> <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">]</span>
            <span class="n">records</span> <span class="o">=</span> <span class="n">non_matches</span> <span class="o">+</span> <span class="p">[[</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">]]</span>
        <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;getitem&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">getitem</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;setitem&#39;</span><span class="p">:</span>
                <span class="n">setitem</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dispatch</span>
</code></pre></td></tr></table>
</div>
</div><p>再一次, 我们用消息传输方法来组织我们的实现. 我们已经支持两个消息: <code>getitem</code>和<code>setitem</code>. 为一个键插入一个值, 我们过滤出任何给定键的存在记录, 然后添加一个. 通过这种方式, 我们保证每一个键值在记录中只出现一次. 要为一个键找出它的值, 我们过滤出符合给定的键的值. 我们现在可以用我们的实现来保存以及检索值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="p">(</span><span class="s1">&#39;setitem&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="p">(</span><span class="s1">&#39;setitem&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="p">(</span><span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">9</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="p">(</span><span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">16</span>
</code></pre></td></tr></table>
</div>
</div><p>这种实现的字典没有为快速查找作优化, 因为每一次调用必须要过滤全部的记录. 內建的字典类型是十分高效的. 它的实现方式超出了本文的范围.</p>
<h4 id="248-调度字典">2.4.8 调度字典</h4>
<p>调度函数是为抽象数据实现消息传递接口的一般方法. 为了实现消息调度, 迄今为止我们使用条件语句来对比消息字符串跟已知消息的固定集.</p>
<p>內建的字典数据类型提供一个一般的方法来查找一个键的值. 而不是使用条件来实现派发, 我们可以用字符串作为字典的键.</p>
<p>下面的可变<code>account</code>数据类型实现为一个字典. 它有一个构造器<code>account</code>以及一个选择器<code>check_balance</code>, 以及用于存储(deposit)或者取出(withdraw)资金的函数. 此外, 账户的本地状态也被保存在字典周围实现它的功能的函数中.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20account(initial_balance%29%3A%0A%20%20%20%20def%20deposit(amount%29%3A%0A%20%20%20%20%20%20%20%20dispatch%5B'balance'%5D%20%2B%3D%20amount%0A%20%20%20%20%20%20%20%20return%20dispatch%5B'balance'%5D%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20dispatch%5B'balance'%5D%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20dispatch%5B'balance'%5D%20-%3D%20amount%0A%20%20%20%20%20%20%20%20return%20dispatch%5B'balance'%5D%0A%20%20%20%20dispatch%20%3D%20%7B'deposit'%3A%20%20%20deposit,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'withdraw'%3A%20%20withdraw,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'balance'%3A%20%20%20initial_balance%7D%0A%20%20%20%20return%20dispatch%0A%0Adef%20withdraw(account,%20amount%29%3A%0A%20%20%20%20return%20account%5B'withdraw'%5D(amount%29%0Adef%20deposit(account,%20amount%29%3A%0A%20%20%20%20return%20account%5B'deposit'%5D(amount%29%0Adef%20check_balance(account%29%3A%0A%20%20%20%20return%20account%5B'balance'%5D%0A%0Aa%20%3D%20account(20%29%0Adeposit(a,%205%29%0Awithdraw(a,%2017%29%0Acheck_balance(a%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p><code>account</code>构造器函数体内的<code>dispatch</code>到一个包含由帐户接受的消息作为键的字典进行绑定. 当存款以及取款消息绑定跟函数绑定, 余额就是一个数字. 这些函数能够访问<code>dispatch</code>字典, 同时, 它们也可以查看以及修改余额. 通过保存余额在dispatch字典中而不是直接保存在在account函数帧中, 我们避免了在<code>deposit</code>以及<code>withdraw</code>中需要用到<code>nonlocal</code>声明.</p>
<p><code>+=</code>以及<code>-=</code>操作是Python(以及其他许多语言)中用于组合查找和重新分配的简便方法. 相当于下面的最后两行.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="249-传播约束">2.4.9 传播约束</h4>
<p>可变数据允许我们去模拟具有改变的系统, 也允许我们去构建新类型的抽象. 在这个扩展例子中, 我们组合非本地声明, 列表, 以及字典来构建一个基础约束的系统, 它支持多种说明的计算. 作为约束的表达式程序是声明性编程的一种类型, 也就是一个程序员声明要去解决的问题的结构, 但是抽象出了究竟如何计算问题的解决方案的细节。.</p>
<p>计算机程序传统上是组织为单方向计算的, 也就是在预先指定的参数上执行操作来生产期望的输出. 另一方面, 我们通常想要以数量的关系来对系统建模. 例如, 我们以前思考过的理想气体定律, 它是通过玻尔兹曼常数(k)来跟压力(p), 体积(v), 数量(n), 以及温度(t)相关的.</p>
<p><code>p * v = n * k * t</code></p>
<p>这样的一个方程不是单项的. 有任意四个给定的数量, 我们可以用这个等式来计算第五个. 然而将这个等式转换到传统的计算机语言中或迫使我们去选择一个数量并用其他四个数量来计算出它. 因此, 一个计算压力的函数无法被用来计算温度, 即使所有需要计算的数量都源自同一个等式.</p>
<p>在本节中, 我们用线性关系来勾勒出一般模型的设计. 我们定义保留在数量之间的原始约束, 例如一个<code>adder(a, b, c)</code>约束会强制得到数学关系<code>a + b = c</code>.</p>
<p>我们还定义了一种组合方法, 因此原始约束可以被组合来表达出更多复杂的关系. 通过这种方式, 我们的程序就类似于一个程序语言. 我们通过构建一个由连接器连接来连接约束的网络来组合约束. 一个连接器是一个持有一个值以及并且可以参与一个或多个约束的对象.</p>
<p>例如, 我们知道华氏度以及摄氏度之间的关系是: <code>9 * c = 5 * (f - 32)</code></p>
<p>这个方程是c和f之间的复杂约束. 这样的一个约束能够想象为一个由原始<code>adder</code>, <code>multiple</code>以及<code>constant</code>约束组成的网络.</p>
<p><img src="http://composingprograms.com/img/constraints.png" alt="constraints" /></p>
<p>在这个图片中, 我们看到左边的乘法器有三个终端, 标记为a, b和c. 这些将乘法器连接到网络的其余部分, 如下所示: a终端是连接到一个连接器<code>celsius</code>, 它将会保存摄氏温度. b终端连接到一个连接器w中, 也就是一个连接到具有9的常量盒子的连接器. c终端是一个乘法器盒子约束为a和b的乘积, 连接到c终端的是另外一个乘法器, 这个乘法器的b终端连接到一个常量5而a终端连接到一个和约束的其中一项上.</p>
<p>这样的网络计算过程如下: 当一个连接器给定了一个值(通过用户或者它连接到的约束盒子), 它将会唤醒它所有关联的约束(除了那个唤醒它的约束)来通知它们它所具有的值. 每一次唤醒约束盒子然后轮询它的连接器来查看这里是否有足够的信息来确定一个连接器的值. 如果有, 这个盒子就设置这个连接器, 这个连接器随后会唤醒所有自己的关联约束等. 例如, 在摄氏度和华氏度之间的转换, w, x以及y都会立即被分别设置为常量盒子9, 5以及32. 连接器唤醒乘法器以及加法器, 它判断得出现在还没有足够的信息来继续执行. 如果用户(或者网络的其他部分)给<code>celsius</code>连接器设定一个值(比如说25), 那么最左边的乘法器会被唤醒, 然后它会设定u为<code>25 * 9 = 225</code>. 然后u会唤醒第二个乘法器, 它会设定v为45, 然后v唤醒加法器, 它会设置<code>fahrenheit</code>连接器为77.</p>
<p><strong>使用约束系统</strong>. 要使用约束系统来执行上面描绘的温度计算, 我们首先通过调用<code>connector</code>构造器来创建两个已命名的连接器, <code>celsius</code>以及<code>fahrenheit</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">celsius</span> <span class="o">=</span> <span class="n">connector</span><span class="p">(</span><span class="s1">&#39;Celsius&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fahrenheit</span> <span class="o">=</span> <span class="n">connector</span><span class="p">(</span><span class="s1">&#39;Fahrenheit&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>然后, 我们连接这些连接器到网络中来做一个上图的镜像实现. 函数<code>convert</code>用来装配网络中的各种连接器以及约束.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">converter</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Connect c to f with constraints to convert from Celsius to Fahrenheit.&#34;&#34;&#34;</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">connector</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
        <span class="n">multiple</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">multiple</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">adder</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">constant</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
        <span class="n">constant</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">constant</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">converter</span><span class="p">(</span><span class="n">celsius</span><span class="p">,</span> <span class="n">fahrenheit</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>我们会用一个消息输入到系统中来协调约束以及连接器. 约束是不具有本地状态的一个字典. 约束不会直接修改连接器的值, 而是会通过发送信息来修改, 因此连接器可以通知其他的约束来响应修改. 通过这种方式, 一个连接器代表一个数字, 同时也封装连接器的行为.</p>
<p>一个我们可以发送到连接器的信息是设置它的值. 这里, 我们(也就是&quot;用户&rdquo;)设置<code>celsius</code>的值为25.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">celsius</span><span class="p">[</span><span class="s1">&#39;set_val&#39;</span><span class="p">](</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">Celsius</span> <span class="o">=</span> <span class="mi">25</span>
<span class="n">Fahrenheit</span> <span class="o">=</span> <span class="mf">77.0</span>
</code></pre></td></tr></table>
</div>
</div><p>不仅仅<code>celsius</code>的值修改为25, 而且它的值通过网络传播, 因此<code>fahrenheit</code>的值也会修改. 这些值会被打印出来因为在构建它们的时候我们命名了这两个连接器.</p>
<p>现在我们可以尝试设定<code>fahrenheit</code>到一个新值, 比如说212.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">fahrenheit</span><span class="p">[</span><span class="s1">&#39;set_val&#39;</span><span class="p">](</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="mi">212</span><span class="p">)</span>
<span class="n">Contradiction</span> <span class="n">detected</span><span class="p">:</span> <span class="mf">77.0</span> <span class="n">vs</span> <span class="mi">212</span>
</code></pre></td></tr></table>
</div>
</div><p>这个连接器会抱怨说它探测到一个矛盾: 它的值是77.0, 然后某个人尝试将它设为212. 如果我们真的想要用新的值重用这个网络, 我们可以告诉<code>celsius</code>去忘记它的旧值:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">celsius</span><span class="p">[</span><span class="s1">&#39;forget&#39;</span><span class="p">](</span><span class="s1">&#39;user&#39;</span><span class="p">)</span>
<span class="n">Celsius</span> <span class="ow">is</span> <span class="n">forgotten</span>
<span class="n">Fahrenheit</span> <span class="ow">is</span> <span class="n">forgotten</span>
</code></pre></td></tr></table>
</div>
</div><p>连接器<code>celsius</code>发现那个本来要设定它值的用户现在正在撤回这个值, 因此<code>celsius</code>同意去丢掉自己的值, 然后它通知网络的剩余部分目前的情况. 这个信息最终传播到<code>fahrenheit</code>中, 它现在发现它没有理由去继续相信它拥有的值是77. 因此, 它也放弃了它自己的值.</p>
<p>现在, <code>fahrenheit</code>已经没有了值, 我们可以自由地设定它为212:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">fahrenheit</span><span class="p">[</span><span class="s1">&#39;set_val&#39;</span><span class="p">](</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="mi">212</span><span class="p">)</span>
<span class="n">Fahrenheit</span> <span class="o">=</span> <span class="mi">212</span>
<span class="n">Celsius</span> <span class="o">=</span> <span class="mf">100.0</span>
</code></pre></td></tr></table>
</div>
</div><p>这个新值, 当其通过网络传播时, 迫使<code>celsius</code>得到一个值100. 我们已经使用这个非常相像的网络来通过给定<code>fahrenheit</code>计算<code>celsius</code>, 通过给定<code>fahrenheit</code>计算<code>celsius</code>. 这种计算的非方向性是基于约束的系统的区别特征。</p>
<p><strong>实现约束系统</strong>. 就像我们看到的, 连接器是一个映射消息名称到函数以及数据值的字典. 我们会实现连接器来响应下面的消息:</p>
<ul>
<li><code>connector['set_val'](source, value)</code>表明<code>source</code>需要连接器来设置它的当前值为<code>value</code>.</li>
<li><code>connector['has_val']()</code>返回是否这个连接器已经具有一个值.</li>
<li><code>connector['val']</code>是connector的当前值.</li>
<li><code>connector['forget'](source)</code>告诉连接器需要它去忘记设定的<code>source</code>的值</li>
<li><code>connector['connect'](source)</code>告诉连接器去加入到一个新的约束中, 也就是<code>source</code>;</li>
</ul>
<p>约束也是字典, 它会从连接器通过两个消息来接收信息:</p>
<ul>
<li><code>constraints['new_val']()</code>表明已经连接到约束并具有一个新的值的一些连接器.</li>
<li><code>constraints['forget']()</code>表明已经连接到约束并具有并忘记它的值的一些连接器.</li>
</ul>
<p>当约束接收到这些信息, 它们恰当地将这些信息传播到其他的连接器.</p>
<p><code>adder</code>函数通过三个连接器来构造了一个加法约束, 就是前两个必须要相加得到第三个: <code>a + b = c</code>. 要支持多向约束传播, 加法器也必须要能够指定从c减去a得到b以及同样的从c减去b得到a.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span><span class="p">,</span> <span class="n">sub</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">adder</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;The constraints that a + b = c.&#34;&#34;&#34;</span>
        <span class="k">return</span> <span class="n">make_ternary_constraint</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>我们也愿意去实现一个通用的三元(三个方向)约束, 也就是用三个连接器以及三个函数从<code>adder</code>来创建一个约束来接受<code>new_val</code>以及<code>forget</code>信息. 响应消息的是被放置在一个字典中称为<code>constraint</code>的本地函数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">make_ternary_constraint</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ab</span><span class="p">,</span> <span class="n">ca</span><span class="p">,</span> <span class="n">cb</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;The constraint that ab(a, b)=c and ca(c, a)=b and cb(c, b)=a.&#34;&#34;&#34;</span>
        <span class="k">def</span> <span class="nf">new_value</span><span class="p">():</span>
            <span class="n">av</span><span class="p">,</span> <span class="n">bv</span><span class="p">,</span> <span class="n">cv</span> <span class="o">=</span> <span class="p">[</span><span class="n">connector</span><span class="p">[</span><span class="s1">&#39;has_val&#39;</span><span class="p">]()</span> <span class="k">for</span> <span class="n">connector</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">av</span> <span class="ow">and</span> <span class="n">bv</span><span class="p">:</span>
                <span class="n">c</span><span class="p">[</span><span class="s1">&#39;set_val&#39;</span><span class="p">](</span><span class="n">constraint</span><span class="p">,</span> <span class="n">ab</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">av</span> <span class="ow">and</span> <span class="n">cv</span><span class="p">:</span>
                <span class="n">b</span><span class="p">[</span><span class="s1">&#39;set_val&#39;</span><span class="p">](</span><span class="n">constraint</span><span class="p">,</span> <span class="n">ca</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">bv</span> <span class="ow">and</span> <span class="n">cv</span><span class="p">:</span>
                <span class="n">a</span><span class="p">[</span><span class="s1">&#39;set_val&#39;</span><span class="p">](</span><span class="n">constraint</span><span class="p">,</span> <span class="n">cb</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]))</span>
        <span class="k">def</span> <span class="nf">forget_value</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">connector</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
                <span class="n">connector</span><span class="p">[</span><span class="s1">&#39;forget&#39;</span><span class="p">](</span><span class="n">constraint</span><span class="p">)</span>
        <span class="n">constraint</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;new_val&#39;</span><span class="p">:</span> <span class="n">new_value</span><span class="p">,</span> <span class="s1">&#39;forget&#39;</span><span class="p">:</span> <span class="n">forget_value</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">connector</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
            <span class="n">connector</span><span class="p">[</span><span class="s1">&#39;connect&#39;</span><span class="p">](</span><span class="n">constraint</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">constraint</span>
</code></pre></td></tr></table>
</div>
</div><p>称为<code>constraint</code>的字典是一个调度字典, 但它本身也是一个约束对象. 它响应约束接收的两个信息, 但它在调用它的连接器时也作为<code>source</code>参数来传输.</p>
<p>无论任何时候约束被通知有一个它的连接器得到了一个值时, 约束的本地函数<code>new_value</code>就会被调用. 这个函数首先检查看是否a和b都有值. 如果有, 它会告诉c去设定值自己为函数ab的返回值, 在<code>adder</code>的情况下就是相加的结果. 约束将它自己(constraint)作为source参数来传输到connector中, 也就是adder对象. 如果a和b不是全都有值, 那么constraint会检查a以及c, 等等.</p>
<p>如果约束被通知到它的其中一个连接器已经忘记它的值, 它会要求它所有的连接器马上遗忘自己的值. (只有这些值是由约束设置的会真的丢失掉.)</p>
<p>一个乘法器跟一个加法器十分的相似.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">mul</span><span class="p">,</span> <span class="n">truediv</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">multiple</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;The constraint that a * b = c.&#34;&#34;&#34;</span>
        <span class="k">return</span> <span class="n">make_ternary_constraint</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">mul</span><span class="p">,</span> <span class="n">truediv</span><span class="p">,</span> <span class="n">truediv</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>一个常量也是一个约束, 但是一个永远不会发送任何信息的约束, 因为在它设置构建的时候只涉及到单一的一个连接器.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;The constraint that connector = value.&#34;&#34;&#34;</span>
        <span class="n">constraint</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">connector</span><span class="p">[</span><span class="s1">&#39;set_val&#39;</span><span class="p">](</span><span class="n">constraint</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">constraint</span>
</code></pre></td></tr></table>
</div>
</div><p>这三个约束足以实现我们的温度转换网络.</p>
<p><strong>表示连接器</strong>. 一个连接器是作为一个包含一个值的字典来表示的, 但也有本地状态的响应函数. 这连接器必须跟踪给予其当前值的信息提供者以及它参与的约束的列表.</p>
<p>这个<code>connector</code>构造器有本地的函数来设置以及遗忘值, 它们是来自约束的消息的响应.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">connector</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;A connector between constraints.&#34;&#34;&#34;</span>
        <span class="n">informant</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="n">nonlocal</span> <span class="n">informant</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">connector</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">informant</span><span class="p">,</span> <span class="n">connector</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">inform_all_except</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s1">&#39;new_val&#39;</span><span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Contradiction detected:&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="s1">&#39;vs&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">forget_value</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
            <span class="n">nonlocal</span> <span class="n">informant</span>
            <span class="k">if</span> <span class="n">informant</span> <span class="o">==</span> <span class="n">source</span><span class="p">:</span>
                <span class="n">informant</span><span class="p">,</span> <span class="n">connector</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;is forgotten&#39;</span><span class="p">)</span>
                <span class="n">inform_all_except</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s1">&#39;forget&#39;</span><span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
        <span class="n">connector</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;val&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
            <span class="s1">&#39;set_val&#39;</span><span class="p">:</span> <span class="n">set_value</span><span class="p">,</span>
            <span class="s1">&#39;forget&#39;</span><span class="p">:</span> <span class="n">forget_value</span><span class="p">,</span>
            <span class="s1">&#39;has_val&#39;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">connector</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span>
            <span class="s1">&#39;connect&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">source</span><span class="p">:</span> <span class="n">constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">connector</span>
</code></pre></td></tr></table>
</div>
</div><p>连接器再一次作为五个消息的调度字典用来通过约束去与连接器通信. 有四个是响应函数, 最后的一个是响应的值本身.</p>
<p>当有请求来设置连接器的值时本地函数<code>set_value</code>会被调用. 如果连接器当前不具有值, 它将设置其值并记住请求要设置的值的源约束为<code>informant</code>. 接着连接器会通知所有它参与的约束除了请求要设置值的约束. 这是使用以下的迭代函数完成的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">inform_all_except</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">constraints</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Inform all constraints of the message, except source.&#34;&#34;&#34;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">source</span><span class="p">:</span>
                <span class="n">c</span><span class="p">[</span><span class="n">message</span><span class="p">]()</span>
</code></pre></td></tr></table>
</div>
</div><p>如果一个连接器被要求遗忘它的值, 它会调用本地的<code>forget_value</code>函数, 这函数首先检查确认请求最初设置的值是从相同的约束中来的. 如果是连接器通知它的关联约束关于值的丢失.</p>
<p>响应<code>has_val</code>消息指示出连接器是否有一个值. 响应<code>connect</code>消息会添加约束源到约束列表中.</p>
<p>我们已经设计好的约束程序介绍了许多思想将会在面向对象编程里面再次出现. 约束以及连接器都是通过消息操纵的抽象. 当连接器的值被修改, 它是通过消息改变的而且不仅仅改变值, 还验证它(检查源)以及传播它的影响(通知其他的约束). 实际上, 在这章之后, 我们会用一个相似的字典架构, 它包含字符串值作为键以及函数值来实现一个面向对象系统.</p>
<h3 id="25-面向对象编程">2.5 面向对象编程</h3>
<p>面向对象编程(OOP)是一种组织程序的方法, 在这一章中它汇集并带来了许多思想. 比如在数据抽象中的函数, 类在数据使用和实现之间创建的抽象屏障. 比如调度字典, 对象回应行为请求, 比如可变数据结构, 具有本地状态的对象并不可以直接在全局环境访问. Python的对象系统提供了便利的语法来促进使用这些技术来组织程序. 许多这些语法都在其他的面向对象编程语言中共享.</p>
<p>对象系统提供的不仅仅是便利. 它为设计程序启用了新的隐喻, 也就是其中几个独立的代理在计算机中的交互. 每一个对象以提取两者复杂性的方式将局部状态以及行为捆绑在一起. 对象之间相互通信, 并且有用的结果从它们之间交互的成果中得出. 对象不仅仅传递消息, 它们也在相同类型的其他对象间共享行为以及在相关类型中继承特性</p>
<p>面向对象编程范例有它自己的词汇用来支持对象隐喻. 我们已经见识过一个对象就是一个具有方法以及属性通过点语法访问的数据值. 每一个对象都有一个类型, 叫做它的类. 要创建一个新的数据类型, 我们需要实现一个新的类.</p>
<h4 id="251-对象以及类">2.5.1 对象以及类</h4>
<p>一个类就是所有类型是这个类的对象的一个模板. 每个对象都是某种特定类型的类的一个实例. 到目前为止我们用过的所有对象都具有內建的类, 但是新的用户定义的类型也可以被创建. 一个类的定义指定了属性以及方法在这种类的对象之间共享. 我们会通过重看银行账户的例子来介绍类声明.</p>
<p>当介绍局部状态, 我们看到银行账户被自然地以具有<code>balance</code>的可变数据值来建模. 一个银行账户对象应该有一个<code>withdraw</code>方法来更新账户的余额以及在更新后的余额有效的情况下返回请求的金额. 要完成抽象, 一个银行账户应该可以返回它当前的余额(balance), 返回账户持有者(holder)的名称, 以及存款金额(deposit).</p>
<p>一个账户类允许我们去创建多个银行账户的实例. 创建一个新对象实例的动作被称为类的实例化. 在Python中实例化一个类的语法跟调用一个函数的语法是一样的. 在这种情况下, 我们用参数&rsquo;Kirk&rsquo;即账户持有者的名称来调用<code>Account</code>类.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Account</span><span class="p">(</span><span class="s1">&#39;Kirk&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>一个对象的一个属性就是一个跟对象关联的名值对, 并且它能够通过点语法来访问. 特定对象的特定属性(与类的所有对象相对而言)称为实例属性. 每一个<code>Account</code>都有它的自己的余额以及账户持有者名称, 也就是例子的实例属性. 在更加广泛的编程社区, 实例属性也会叫做<em>字段</em>, <em>特性</em>, 或者实例变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">holder</span>
<span class="s1">&#39;Kirk&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">balance</span>
<span class="mi">0</span>
</code></pre></td></tr></table>
</div>
</div><p>在对象或者执行特定对象计算的函数被称为方法. 方法的返回值以及副作用可以取决于对象的其他属性且改变它. 例如, <code>deposit</code>(存款)是Account类对象a的一个方法. 它接收一个参数, 就是存款的金额, 修改对象的<code>balance</code>(余额)属性, 然后返回余额的结果.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="mi">15</span>
</code></pre></td></tr></table>
</div>
</div><p>我们称方法在特定的对象上被调用. 作为调用<code>withdraw</code>(取出)方法调用的结果, 要么取款会被批准并扣除总额, 要么请求被拒绝然后方法返回一个错误信息.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">balance</span>
<span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="s1">&#39;Insufficient funds&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>如上所述, 方法的行为可以取决于对象属性的修改. 对<code>withdraw</code>(取款)的两次相同的调用返回了不同的结果.</p>
<h4 id="252-定义类">2.5.2 定义类</h4>
<p>用户定义类型是通过包含一个单一条款的<code>class</code>声明来创建的, 一个<code>class</code>声明定义一个类的名称, 然后包含一系列语句来定义类的属性:</p>
<pre><code>class &lt;name&gt;:
    &lt;suite&gt;
</code></pre><p>当一个类声明被执行, 一个新的类就会创建并在当前环境的第一帧内绑定到<code>&lt;name&gt;</code>. 内部的一系列语句会执行. 任何在class声明的<code>&lt;suite&gt;</code>范围内的通过def或者赋值语句定义的名称会创建或修改类的属性.</p>
<p>类通常围绕操纵类的属性, 也就是跟这个类的每个实例相关联的名值对. 这个类通过定义用于初始化新对象的方法来指定其对象的实例属性. 例如, 初始化<code>Account</code>类的对象的其中一个部分是分配给它一个初始的余额值0.</p>
<p>类声明中的<code>&lt;suite&gt;</code>包含有def声明, 它会定义为这种类的对象定义新的方法. 在Python中初始化对象的方法具有一个特别的名字, <code>__init__</code>(在单词init的两边都有两个下划线), 这方法称为这个类的构造器.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Account</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">account_holder</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">holder</span> <span class="o">=</span> <span class="n">account_holder</span>
</code></pre></td></tr></table>
</div>
</div><p>Account类的<code>__init__</code>方法有两个形式参数. 第一个是<code>self</code>, 它绑定到的是最新创建的<code>Account</code>对象. 第二个参数是<code>account_holder</code>, 它在调用类来实例化对象的时候绑定为的传输给类的参数.</p>
<p>构造器将实例名为<code>balance</code>的属性绑定为值0. 它同时也将名为<code>holder</code>的属性绑定到名为<code>account_holder</code>具有的值. 形式参数<code>account_holder</code>在<code>__init__</code>方法中是本地名称. 另一方面, 最终通过赋值语句进行绑定的名称<code>holder</code>依然存在, 因为它通过点语法存储为<code>self</code>的属性.</p>
<p>在定义了<code>Account</code>类之后, 我们可以实例化它</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Account</span><span class="p">(</span><span class="s1">&#39;Kirk&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这种&quot;调用&quot;<code>Account</code>类创建出来的新对象是<code>Account</code>的一个实例, 然后用两个参数: 最新创建的对象以及字符串<code>Kirk</code>来调用构造器函数<code>__init__</code>. 按照惯例, 我们用参数名self代表构造器的第一个参数, 因为它是绑定到已被实例化的对象上的. 这个惯例实际上在所有Python代码中被采用.</p>
<p>现在我们可以用点语法访问对象的<code>balance</code>以及<code>holder</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">balance</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">holder</span>
<span class="s1">&#39;Kirk&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>身份</strong>. 每一个新的账户实例都有它自己的<code>balance</code>属性, 这个值独立于其他相同类型的对象.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Account</span><span class="p">(</span><span class="s1">&#39;Spock&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="mi">200</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">acc</span><span class="o">.</span><span class="n">balance</span> <span class="k">for</span> <span class="n">acc</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>为了强制这种分离, 每一个用户定义类的实例对象都有一个唯一的标识, 对象标识可以用<code>is</code>或者<code>is not</code>操作符来进行比较.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="ow">is</span> <span class="n">a</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">b</span>
<span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p>尽管都是从相同的调用中构造, 绑定到a的对象跟绑定到b的对象是不相同的. 而同样地, 用赋值语句绑定一个对象到新的名字不会创建新的对象.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="ow">is</span> <span class="n">a</span>
<span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p>新的用户定义类的对象只当一个类(例如<code>Account</code>)通过表达式语法调用进行实例化的时候才会被创建.</p>
<p><strong>方法</strong>. 对象方法通常也通过类语句的套件内的<code>def</code>语句来定义. 下面, <code>deposit</code>以及<code>withdraw</code>都是作为<code>Account</code>类的方法来定义的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Account</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">account_holder</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">holder</span> <span class="o">=</span> <span class="n">account_holder</span>
        <span class="k">def</span> <span class="nf">deposit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">+</span> <span class="n">amount</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span>
        <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">amount</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;Insufficient funds&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">-</span> <span class="n">amount</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span>
</code></pre></td></tr></table>
</div>
</div><p>虽然一个方法的定义跟一个函数的定义在如何声明上并没有什么不同, 但方法定义在它们执行的时候会带来不同的效果. 通过在<code>class</code>语句内部<code>def</code>语句创建的函数值会绑定到声明的名称上, 同时也会局部绑定作为类的属性. 这个值会从一个类的实例中通过点语法作为方法被调用.</p>
<p>每一个方法的定义再一次包含有特殊的第一参数<code>self</code>, 它是绑定到调用方法的对象上的. 例如, 我们会说<code>deposit</code>是在特定的<code>Account</code>对象上被调用的, 同时需要传单个参数值: 存款的金额. 对象本身被绑定到<code>self</code>上, 而参数绑定到<code>amount</code>上. 所有调用的方法都可以通过<code>self</code>参数访问对象, 同时, 它们全部都可以访问以及操纵对象的状态.</p>
<p>要调用这些方法, 我们再一次要用到点语法, 如下所示:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">spock_account</span> <span class="o">=</span> <span class="n">Account</span><span class="p">(</span><span class="s1">&#39;Spock&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">spock_account</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="mi">100</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">spock_account</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
<span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">spock_account</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
<span class="s1">&#39;Insufficient funds&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">spock_account</span><span class="o">.</span><span class="n">holder</span>
<span class="s1">&#39;Spock&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>当一个方法通过点语法被调用, 对象本身(在这个例子中是绑定到<code>spock_account</code>上的对象)扮演一个双重角色. 第一, 它确定名称<code>withdraw</code>的含义; <code>withdraw</code>不是当前环境下的名称, 而是Account类的本地名称. 第二, 当<code>withdraw</code>方法被调用时它会绑定到第一个参数<code>self</code>.</p>
<h4 id="253-消息传递与点表达式">2.5.3 消息传递与点表达式</h4>
<p>那些定义在类里面的方法以及通常在构造器里面分配的实例属性, 都是面向对象编程的基本要素. 这两个概念在消息传递数据值的实现中复制了调度字典的大多数行为. 对象用点语法携带消息, 但那些消息不是任意字符串值作为键, 它们是作为类的局部名称而存在的. 对象也有命名的本地状态(实例属性), 但是这个状态可以使用点语法进行访问以及操纵, 而不用在实现中使用<code>nonlocal</code>语句.</p>
<p>消息传递的中心思想是数据值应该通过响应它们所代表的抽象类型的相关消息具有行为. 点符号是Python的一个句法特征, 用来形式化消息传递的隐喻. 使用具有內建对象系统的语言的好处是消息传递可以与语言的其他特性无缝互动, 例如赋值语句, 我们无需请求不同的消息来&quot;获取(get)&ldquo;或者&quot;设置(set)&ldquo;跟本地属性名称相关联的值; 语言的语法允许我们直接使用消息名称.</p>
<p><strong>点表达式</strong>. 代码片段<code>spock_account.deposit</code>被称为点表达式. 一个点表达式由一个表达式, 一个点, 以及一个名称组成.</p>
<p><code>&lt;expression&gt;.&lt;name&gt;</code></p>
<p><code>&lt;expression&gt;</code>可以是任意有效的Python表达式, 但是<code>&lt;name&gt;</code>必须是一个简单名称(不是一个运行后得到一个名称的表达式). 点表达式对<code>&lt;expression&gt;</code>的值代表的对象运算出给定的<code>&lt;name&gt;</code>属性的值.</p>
<p>內建函数<code>getattr</code>也通过一个名称返回一个对象的属性. 这是一个相当于点符号的函数. 使用<code>getattr</code>函数, 我们可以用字符串查看一个属性, 就像在调度字典中那样做.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">spock_account</span><span class="p">,</span> <span class="s1">&#39;balance&#39;</span><span class="p">)</span>
<span class="mi">10</span>
</code></pre></td></tr></table>
</div>
</div><p>我们也可以用<code>hasattr</code>测试一个对象是否具有某个属性.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spock_account</span><span class="p">,</span> <span class="s1">&#39;deposit&#39;</span><span class="p">)</span>
<span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p>对象的是属性包括所有的实例属性, 以及在其类中定义的所有属性(包括方法). 方法是类中需要特殊处理的属性</p>
<p><strong>方法和函数</strong>. 当一个方法在一个对象上被调用, 对象会隐含地作为方法的第一个参数进行传输. 也就是说, 对象是点号左边的<code>&lt;expression&gt;</code>的值自动地作为第一个参数传输给点号表达式右边的方法名代表的函数. 结果就是对象绑定到参数<code>self</code>上.</p>
<p>要实现自动绑定<code>self</code>, Python将我们自本文开始以来一直创建的函数和绑定方法区分开来了, 这些方法将函数和要调用该方法的对象耦合在了一起. 绑定方法的值已经和它的第一个参数(也就是调用它的实例, 那个将在方法被调用时会命名为<code>self</code>的对象)关联在一起.</p>
<p>我们可以通过在交互式解析器上调用<code>type</code>来处理点语法的返回值来看出差异. 作为一个类的属性, 一个方法只是一个函数, 但是作为一个实例的属性, 它就是一个绑定了的方法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">Account</span><span class="o">.</span><span class="n">deposit</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">function</span><span class="s1">&#39;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">spock_account</span><span class="o">.</span><span class="n">deposit</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">method</span><span class="s1">&#39;&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>这两个结果的不同事实上在于第一个是标准的带有两个形参<code>self</code>以及<code>account</code>的函数. 而第二个是具有单个形参的方法, 在方法被调用时名称<code>self</code>会被自动地绑定到名为<code>spock_account</code>的对象上, 而形参<code>amount</code>会被绑定到传入方法的参数上. 所有这些值, 无论是函数值或者绑定方法值, 都跟相同的<code>deposit</code>函数体相关联.</p>
<p>我们可以用两种方式调用<code>deposit</code>: 作为函数以及作为绑定方法. 在前一种情况下, 我们必须明确地提供一个参数给<code>self</code>形参, 在后一种情况下, <code>self</code>形参会自动绑定.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">Account</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="n">spock_account</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>  <span class="c1"># The deposit function takes 2 arguments</span>
<span class="mi">1011</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">spock_account</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>           <span class="c1"># The deposit method takes 1 argument</span>
<span class="mi">2011</span>
</code></pre></td></tr></table>
</div>
</div><p>函数<code>getattr</code>的行为跟点符号完全类似: 如果它的第一个参数是一个对象, 但是名称是一个已经在类中定义的方法. 那么<code>getattr</code>返回一个绑定的方法值. 另一方面, 如果第一个参数是一个类, 那么<code>getattr</code>直接返回属性值, 也就是一个纯函数.</p>
<p><strong>命名约定</strong>. 传统上命名类是使用<code>CapWords</code>惯例(也就是称为驼峰式, 因为在名称中间的单词首部看起来像是一个驼峰). 方法名跟随命名函数所使用的标准惯例也就是使用小写单词并用下划线作分割.</p>
<p>在某些情况下, 对象上跟维护性与一致性相关的一些实例变量以及方法我们是不希望对象的用户看到或者使用的. 它们不是类的抽象定义的一部分, 而是实现的一部分. Python的惯例规定如果一个属性名以下划线开始, 它就应该只能被类自身内部的方法访问到, 而不是使用这个类的用户.</p>
<h4 id="254-类属性">2.5.4 类属性</h4>
<p>一些属性值是共享给指定类的所有对象访问的. 这样的属性是跟类本身而不是任何个别类的实例相关联的. 例如, 让我们假设一个银行以固定利率支付账户余额的利息. 利率可能会变动, 但是这是一个在所有账户中共享的单一值.</p>
<p>类属性通过赋值语句在类的套件语句中且在所有方法定义的外面创建. 在更广泛的开发者社区中, 类属性可能也会叫做类变量或静态变量. 接下来的类语句中为<code>Account</code>类创建一个名为<code>interest</code>的属性.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Account</span><span class="p">:</span>
        <span class="n">interest</span> <span class="o">=</span> <span class="mf">0.02</span>  <span class="c1"># 一个类属性</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">account_holder</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">holder</span> <span class="o">=</span> <span class="n">account_holder</span>
        <span class="c1"># 额外的方法会在这里定义</span>
</code></pre></td></tr></table>
</div>
</div><p>这个属性依然可以从类的任何实例中访问到.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">spock_account</span> <span class="o">=</span> <span class="n">Account</span><span class="p">(</span><span class="s1">&#39;Spock&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kirk_account</span> <span class="o">=</span> <span class="n">Account</span><span class="p">(</span><span class="s1">&#39;Kirk&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">spock_account</span><span class="o">.</span><span class="n">interest</span>
<span class="mf">0.02</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kirk_account</span><span class="o">.</span><span class="n">interest</span>
<span class="mf">0.02</span>
</code></pre></td></tr></table>
</div>
</div><p>但是, 对类属性的单个赋值语句会更改该类的所有实例的属性值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">Account</span><span class="o">.</span><span class="n">interest</span> <span class="o">=</span> <span class="mf">0.04</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">spock_account</span><span class="o">.</span><span class="n">interest</span>
<span class="mf">0.04</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kirk_account</span><span class="o">.</span><span class="n">interest</span>
<span class="mf">0.04</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>属性名</strong>. 我们已经在对象系统中引入了足够的复杂度, 以至于我们必须要指定如何将名称解析为特殊的属性. 毕竟, 我们可以轻易地拥有一个相同名称的类属性以及实例属性.</p>
<p>就像我们已经见识过的, 一个点表达式包含一个表达式, 一个点, 以及一个名称:</p>
<p><code>&lt;expression&gt;.&lt;name&gt;</code></p>
<p>去执行一个点表达式:</p>
<ol>
<li>执行在点符号左边的<code>&lt;expression&gt;</code>语句, 它返回的一个对象给点表达式.</li>
<li><code>&lt;name&gt;</code>跟对象的实例属性相匹配; 如果有一个这样名称的属性, 就会返回它的值.</li>
<li>如果<code>&lt;name&gt;</code>没有出现在实例属性之中, 那么会去类中查找<code>&lt;name&gt;</code>, (如果找到)并返回类属性的值.</li>
<li>除非这个值是一个函数, 那么将会返回一个绑定了的方法. 否则属性值将被返回.</li>
</ol>
<p>在执行过程当中, 实例属性的查找会在类属性之前, 就像本地名称对于全局环境名称所具有的优先权. 在类中定义的方法会跟点表达式中的对象结合通过执行第四步的过程形成一个绑定方法. 这个查找类中的名称的过程会有附加的细微差别, 一旦我们介绍类继承之后将会很快出现.</p>
<p><strong>属性赋值</strong>. 在其左侧包含点表达式的所有赋值语句都会影响该点表达式对象的属性. 如果对象是一个实例, 那么赋值会设定一个实例属性. 如果对象是一个类, 那么赋值会设定一个类属性. 这个规则带来的后果是, 为一个对象赋值一个属性不能影响到它的类的属性. 下面的例子演示了这个区别.</p>
<p>如果我们为一个账户实例赋值一个名为<code>interest</code>的属性, 我们就创建了一个新的跟已经存在的类属性名称一样的实例属性.</p>
<p><code>&gt;&gt;&gt; kirk_account.interest = 0.08</code></p>
<p>然后这个属性值会在点表达式中被返回</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">kirk_account</span><span class="o">.</span><span class="n">interest</span>
<span class="mf">0.08</span>
</code></pre></td></tr></table>
</div>
</div><p>然而, 类属性<code>interest</code>仍然保留它的原始值, 提供给所有其他的账户返回.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">spock_account</span><span class="o">.</span><span class="n">interest</span>
<span class="mf">0.04</span>
</code></pre></td></tr></table>
</div>
</div><p>更改类属性<code>interest</code>会影响到<code>spock_account</code>, 但是对<code>kirk_account</code>的实例属性不会有影响.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">Account</span><span class="o">.</span><span class="n">interest</span> <span class="o">=</span> <span class="mf">0.05</span>  <span class="c1"># changing the class attribute</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">spock_account</span><span class="o">.</span><span class="n">interest</span>     <span class="c1"># changes instances without like-named instance attributes</span>
<span class="mf">0.05</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kirk_account</span><span class="o">.</span><span class="n">interest</span>     <span class="c1"># but the existing instance attribute is unaffected</span>
<span class="mf">0.08</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="255-继承">2.5.5 继承</h4>
<p>当在面向对象模式下工作时，我们常常发现不同的类型是有关系的。尤其是，我们会发现相似类的在专有化程度上有所不同。两个类可能会有相同的属性，但是其中一个代表的是另一个的特殊例子。</p>
<p>例如，我们可能会想要实现一个支票账户，它跟标准账户有所不同。一个支票账户每次取钱都需要额外的$1手续费且具有更低的利率。这里，我们演示期望的行为。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">CheckingAccount</span><span class="p">(</span><span class="s1">&#39;Spock&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ch</span><span class="o">.</span><span class="n">interest</span> <span class="c1"># 支票账户具有更低的利率</span>
<span class="mf">0.01</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ch</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># 存款是一样的</span>
<span class="mi">20</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ch</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1"># 取款需要减去额外的费用</span>
<span class="mi">14</span>
</code></pre></td></tr></table>
</div>
</div><p>一个<code>CheckingAccount</code>是一个专有化的<code>Account</code>。在OOP术语中，一般的账户会作为<code>CheckingAccount</code>的基类，而<code>CheckingAccount</code>会成为<code>Account</code>的子类（术语父类以及超类通常也用来表示基类，而子类通常也用来表示子集。）</p>
<p>一个子类继承它的基类的属性，但可能会重载某些属性，包括某些方法。有了继承，我们只需要指出子类与基类之间的不同。任何我们在子类中没有特别指明的都会自动假定它的行为跟基类一样。</p>
<p>继承除了是一个有用的组织性特性，在对象隐喻中也具有作用。继承代表的意思是类中&quot;是一个&quot;的关系，可与&quot;有一个&quot;的关系相类比。一个支票账户&quot;是一个&quot;特殊类型的账户，因此继承自<code>Account</code>的<code>CheckingAccount</code>账户就是继承的恰当使用。另一方面，一个银行&quot;有一个&quot;列的银行账户给它管理着，因此，都不应该继承其他，而是，账户对象列表会自然地表示为一个银行账户对象的实例属性。</p>
<h4 id="256-使用继承">2.5.6 使用继承</h4>
<p>首先，我们给出<code>Account</code>的完整实现，包括类的文档字符串以及它的方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Account</span><span class="p">:</span>
        <span class="s2">&#34;&#34;&#34;A bank account that has a non-negative balance.&#34;&#34;&#34;</span>
        <span class="n">interest</span> <span class="o">=</span> <span class="mf">0.02</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">account_holder</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">holder</span> <span class="o">=</span> <span class="n">account_holder</span>
        <span class="k">def</span> <span class="nf">deposit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
            <span class="s2">&#34;&#34;&#34;Increase the account balance by amount and return the new balance.&#34;&#34;&#34;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">+</span> <span class="n">amount</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span>
        <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
            <span class="s2">&#34;&#34;&#34;Decrease the account balance by amount and return the new balance&#34;&#34;&#34;</span>
            <span class="k">if</span> <span class="n">amount</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;Insufficient funds&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">-</span> <span class="n">amount</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span>
</code></pre></td></tr></table>
</div>
</div><p>下面显示的是<code>CheckingAccount</code>的完整实现。我们通过在类名后的括号中放置一个运算后为基类的表达式来指定继承。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">CheckingAccount</span><span class="p">(</span><span class="n">Account</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;A bank account that charges for withdrawals.&#34;&#34;&#34;</span>
        <span class="n">withdraw_charge</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">interest</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Account</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">withdraw_charge</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这里，我们引入一个在类<code>CheckingAccount</code>中指定的属性<code>withdraw_charge</code>。我们分配一个较低的值给<code>interest</code>属性。我们同样也定义一个新的<code>withdraw</code>方法来重新定义在<code>Account</code>类中的行为。在类中没有进一步的声明，所有其他的行为都是继承自基类<code>Account</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">checking</span> <span class="o">=</span> <span class="n">CheckingAccount</span><span class="p">(</span><span class="s1">&#39;Sam&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">checking</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">checking</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">checking</span><span class="o">.</span><span class="n">interest</span>
<span class="mf">0.01</span>
</code></pre></td></tr></table>
</div>
</div><p>表达式<code>checking.deposit</code>运算绑定的取款方法, 也就是定义在<code>Account</code>类内的方法. 当Python解析点表达式内不是实例属性的名称的时候, 它会在类内部查找名称. 实际上, 在类内&quot;查找&quot;的行为尝试去查找原始类继承链中的每个基类中的名称. 我们可以递归地定义这个过程. 来查找类中的名称.</p>
<ol>
<li>如果它在一个类中命名了一个属性, 返回属性的值.</li>
<li>否则, 在基类中查找名称, 如果里面有一个的话.</li>
</ol>
<p>在<code>deposit</code>的例子中, Python首先必定会在实例中查找名称, 然后在<code>CheckingAccount</code>类中查找. 最后会在<code>Account</code>类中查找, 也就是<code>deposit</code>定义的地方. 根据我们的点表达式运算规则, 由于<code>deposit</code>是在<code>checking</code>实例中查找类得到的函数, 即运算点表达式绑定方法的值. 此方法用参数10来调用, 会用绑定了<code>checking</code>对象的<code>self</code>以及绑定了10的<code>amount</code>调用<code>deposit</code>方法.</p>
<p>对象的类会一直保持不变. 即使<code>deposit</code>方法是在<code>Account</code>类中找到的, <code>deposit</code>调用时<code>self</code>绑定的实例还是属于<code>CheckingAccount</code>而不是<code>Account</code>.</p>
<p><strong>调用祖先</strong>. 已经被重载的属性依然能够通过类对象来访问. 例如, 我们通过一个含有<code>withdraw_charge</code>的参数来调用<code>Account</code>的<code>withdraw</code>方法从而实现<code>CheckingAccount</code>类的<code>withdraw</code>方法.</p>
<p>注意到我们调用<code>self.withdraw_charge</code>而不是等价的<code>CheckingAccount.withdraw_charge</code>. 前者相对于后者的好处是一个继承自<code>CheckingAccount</code>的类可能会重写体现的手续费. 如果是这样的情况, 我们会想要让我们实现的<code>withdraw</code>找到的是新的值, 而不是旧的值.</p>
<p><strong>接口</strong>. 在面向对象编程当中, 不同的类型的对象相互之间共享相同的属性名称是十分常见的. 一个对象接口是一个由属性以及建立在这些属性之上的条件的集合. 例如, 所有账户必须要有接受数值的<code>deposit</code>以及<code>withdraw</code>方法, 也有一个<code>balance</code>属性. 而类<code>Account</code>以及<code>CheckingAccount</code>都实现了这些接口. 在这种方式下继承尤其会促进命名共享. 在一些编程语言比如Java, 接口实现必须明确地被声明. 在其他如Python, Ruby以及Go中, 任何具有恰当名称的对象就是一个接口.</p>
<p>在你的程序中使用对象(而不是实现它们)的部分如果对于对象的类型没有作出任何假设, 而是只定义了它们的属性名称那么对于未来的修改这是最健壮的. 换句话说, 它们使用对象抽象而不是假设任何关于它的实现.</p>
<p>例如, 假如说我们运行一个彩票, 同时我们希望存入$5到账户列表的每一个账户中. 接下来的实现没有假设任何关于这些账户的类型, 因此, 能够在任何类型的具有<code>deposit</code>方法的对象下同等运行.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">deposit_all</span><span class="p">(</span><span class="n">winners</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">winners</span><span class="p">:</span>
            <span class="n">account</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>函数<code>deposit_all</code>只假设每一个<code>account</code>满足账户对象的抽象, 因此它会与任何其他也实现了这个接口的账户类工作. 假设一个特定的账户类会违反这个账户对象抽象的抽象屏障. 例如, 接下来的实现不一定能跟新类型的账户一起工作.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">deposit_all</span><span class="p">(</span><span class="n">winners</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">winners</span><span class="p">:</span>
            <span class="n">Account</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>稍后, 我们将会在这一章详细讲述关于这个主题的更多细节.</p>
<h4 id="257-多重继承">2.5.7 多重继承</h4>
<p>Python支持子类从多个基类中继承属性的概念, 这一语言特性被称为_多重继承_.</p>
<p>假设我们有一个继承自<code>Account</code>的<code>SavingsAccount</code>, 这个账户每次存款都会收取客户一点小费用.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">SavingsAccount</span><span class="p">(</span><span class="n">Account</span><span class="p">):</span>
        <span class="n">deposit_charge</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">def</span> <span class="nf">deposit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Account</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">deposit_charge</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>然后, 一个聪明的执行官构思了一个<code>AsSeenOnTVAccount</code>账户, 它具有<code>CheckingAccount</code>以及<code>SavingsAccount</code>账户的最好的特性: 取款费用, 存款费用, 以及低利率. 这是集存款以及取款账户于一身的账户! 执行官的理由是: &ldquo;如果我们构建它的话, 有人愿意建立账户并支付这些费用, 我们甚至会给他们一美元&rdquo;.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">AsSeenOnTVAccount</span><span class="p">(</span><span class="n">CheckingAccount</span><span class="p">,</span> <span class="n">SavingsAccount</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">account_holder</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">holder</span> <span class="o">=</span> <span class="n">account_holder</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 免费的1美元</span>
</code></pre></td></tr></table>
</div>
</div><p>实际上, 这个实现是复杂的. 分别使用定义在<code>CheckingAccount</code>以及<code>SavingsAccount</code>中的函数来取款以及存款都会产生费用.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">such_a_deal</span> <span class="o">=</span> <span class="n">AsSeenOnTVAccount</span><span class="p">(</span><span class="s2">&#34;John&#34;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">such_a_deal</span><span class="o">.</span><span class="n">balance</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">such_a_deal</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>         <span class="c1"># 来自SavingsAccount.deposit的费用 $2</span>
<span class="mi">19</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">such_a_deal</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>         <span class="c1"># 来自CheckingAccount.withdraw的费用 $1</span>
<span class="mi">13</span>
</code></pre></td></tr></table>
</div>
</div><p>无二义性引用能够按期望被处理:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">such_a_deal</span><span class="o">.</span><span class="n">deposit_charge</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">such_a_deal</span><span class="o">.</span><span class="n">withdraw_charge</span>
<span class="mi">1</span>
</code></pre></td></tr></table>
</div>
</div><p>但是当引用有歧义时会怎样呢, 例如在<code>Account</code>以及<code>CheckingAccount</code>都定义了的<code>withdraw</code>方法的引用? 下面的图例描绘了<code>AsSeenOnTVAccount</code>类的继承图. 每一个箭头都是从子类指向父类.</p>
<p><img src="http://www.composingprograms.com/img/multiple_inheritance.png" alt="多重继承图例" /></p>
<p>像这样一个的简单的菱形形状, Python是从左到右, 然后向上处理名称. 在这个例子中, Python按照以下类的排序来检查一个属性名称, 直到找到具有这样名称的属性:</p>
<p>AsSeenOnTVAccount, CheckingAccount, SavingsAccount, Account, object</p>
<p>这不是一个正确处理继承顺序问题的办法, 有一些例子中我们可能更倾向于给更高的优先级给某些继承的类而不是其他的. 然而, 任何支持多重继承的编程语言都必须要选择某些一致的顺序方式, 来让使用这个语言的用户可以预知他们的程序的行为.</p>
<p><strong>进一步阅读</strong>. Python使用称作C3排序解决方法的递归算法来处理这个名称. 任何类方法的解决顺序可以在所有类中使用<code>mro</code>方法查询.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">AsSeenOnTVAccount</span><span class="o">.</span><span class="n">mro</span><span class="p">()]</span>
<span class="p">[</span><span class="s1">&#39;AsSeenOnTVAccount&#39;</span><span class="p">,</span> <span class="s1">&#39;CheckingAccount&#39;</span><span class="p">,</span> <span class="s1">&#39;SavingsAccount&#39;</span><span class="p">,</span> <span class="s1">&#39;Account&#39;</span><span class="p">,</span> <span class="s1">&#39;object&#39;</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>解决顺序的查找方法的精确算法不是本文的主题, 但是它被<a href="http://python-history.blogspot.com/2010/06/method-resolution-order.html">描述在Python的第一作者</a>的原著论文的引用中.</p>
<h4 id="258-对象的作用">2.5.8 对象的作用</h4>
<p>Python对象系统是为了使数据抽象以及消息传递方便和灵活而设计的. 类, 方法, 继承, 以及点表达式的专有语法都是允许我们在程序中形象化对象的比喻, 也就是提升我们组织大型程序的能力.</p>
<p>特别地, 我们会希望我们的对象系统促进程序不同关注点的分离. 程序中的每个对象都封装并管理某部分的程序的状态, 同时每个类声明内定义的函数都实现了程序总体逻辑的一部分. 抽象屏障在大型程序的不同方面形成界限.</p>
<p>面向对象编程尤其适合去编写分离但是也有交互部分的模型系统. 例如, 不同用户在社交网络中交互, 不同的角色在游戏中交互, 以及不同的形状在物理仿真系统中交互. 当要表现这样的一个系统时, 在程序中的对象常常自然地映射到系统中已经建模的对象上, 同时类描绘它们的类型以及关系.</p>
<p>另一方面, 类可能不会提供最好的机制来实现某些抽象. 功能抽象为输入输出之间的关系表现提供更自然的隐喻. 不应该迫使在类中程序的每一点都符合逻辑, 尤其是当为了更自然地操作数据时定义的独立函数. 函数也可以实习分离关注点.</p>
<p>多范例语言如Python允许程序员对适当的问题来使用恰当的模式. 学习识别什么时候应该引入一个新的类, 或者与之对照的新函数为了简化或者模块化一个程序, 在软件工程中是一个重要的设计技能值得认真关注.</p>
<h3 id="26-实现类以及对象">2.6 实现类以及对象</h3>
<p>当在面向对象编程范式下工作时, 我们使用对象隐喻去指导我们程序的组织. 在类声明当中表达的大多数逻辑是关于如何表示以及操作数据的. 在这一节当中, 我们会看到类以及对象本身可以仅仅使用函数以及字典来表示. 用这种方法实现一个对象系统的目的是阐明用对象隐喻不需要特别的编程语言. Python可以是面向对象的, 甚至一个没有内建对象系统的编程语言也可以.</p>
<p>为了实现对象, 我们会抛弃点符号(需要内建的语言支持), 但是会创建一个调度字典, 它的行为跟内建的对象系统元素的大致一样. 我们已经见识过如何通过调度字典实现消息传递行为. 为了完全实现一个对象系统, 我们在实例, 类以及基类以及所有含有属性的字典当中发送消息.</p>
<p>我们不会实现整个Python对象系统, 其中包括在本文中没有覆盖到的特性(例如, 元类以及静态方法). 相反, 我们会专注于没有多继承也没有自省行为(例如返回一个类的实例)的用户定义类. 我们的实现并不意味着按照Python类型系统的精确规范. 相反, 这么做的目的是实现对象隐喻的核心功能.</p>
<h4 id="261-实例">2.6.1 实例</h4>
<p>我们从实例开始. 一个实例具有命名的属性, 例如一个账户内的余额, 可以被设置以及恢复. 我们用一个调度字典实现一个可以响应&quot;get&quot;以及&quot;set&quot;属性值的实例. 属性本身被保存在一个叫做<code>attributes</code>的本地字典当中.</p>
<p>就像我们在之前的章节中看到的, 字典本身是抽象数据类型. 我们用列表实现一个字典, 我们用数据对来实现列表, 同时我们用函数来实现数据对. 当我们依据字典来实现一个对象系统时, 要记住的是我们也可以只用函数来实现对象.</p>
<p>要开始我们的实现, 我们假设我们有一个类的实现可以查找任何不是实例的一部分的名称. 我们进入一个传入参数<code>cls</code>的类<code>make_instance</code>当中.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">make_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a new object instance, which is a dispatch dictionary.&#34;&#34;&#34;</span>
        <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="n">name</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">bind_method</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="n">attributes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;get&#39;</span><span class="p">:</span> <span class="n">get_value</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">:</span> <span class="n">set_value</span><span class="p">}</span>
            <span class="k">return</span> <span class="n">instance</span>
</code></pre></td></tr></table>
</div>
</div><p><code>instance</code>是一个调度字典用来响应<code>get</code>以及<code>set</code>消息. <code>set</code>消息相当于Python的对象系统的属性赋值: 所有分配了的属性都直接保存在对象的本地属性字典当中. 在<code>get</code>方法中, 如果<code>name</code>不出现在本地的<code>attributes</code>字典中, 那么它会在类当中查找. 如果通过<code>cls</code>返回的<code>value</code>是一个函数, 它必须跟一个实例绑定.</p>
<p><strong>绑定值方法</strong>. 在<code>make_instance</code>中的<code>get_value</code>函数通过类的<code>get</code>(方法)来找到一个命名属性, 然后调用<code>bind_method</code>方法. 绑定方法只用于函数值, 同时它通过插入实例作为第一个参数从一个函数值中创建一个绑定方法值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">bind_method</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a bound method if value is callable, or value otherwise.&#34;&#34;&#34;</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">value</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">method</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
</code></pre></td></tr></table>
</div>
</div><p>当一个方法是可调用时, 通过这个定义第一个参数self会被绑定为值<code>instance</code>.</p>
<h4 id="262-类">2.6.2 类</h4>
<p>一个类也是一个对象, 都存在于Python的对象系统以及现在我们这里实现的系统. 为了简单起见, 我们的类并没有它们自己的类型. (在Python中, 类都是有它们自己的类型的; 几乎所有的类都共享相同的类型, 叫做<code>type</code>.) 一个类可以响应<code>get</code>以及<code>set</code>消息, 也可以响应<code>new</code>消息:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">make_class</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a new class, which is a dispatch dictionary.&#34;&#34;&#34;</span>
        <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">base_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">base_class</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="n">name</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="n">attributes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">init_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;get&#39;</span><span class="p">:</span> <span class="n">get_value</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">:</span> <span class="n">set_value</span><span class="p">,</span> <span class="s1">&#39;new&#39;</span><span class="p">:</span> <span class="n">new</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">cls</span>
</code></pre></td></tr></table>
</div>
</div><p>不像一个实例, 当找不到一个属性的时候类型的<code>get</code>函数不会查询它的类, 取而代之的是查询它的基类. 类不需要进行方法绑定.</p>
<p><strong>初始化</strong>. 在<code>make_class</code>的<code>new</code>函数调用<code>init_instance</code>, 首先会创建一个新的实例, 然后调用叫做<code>__init__</code>的方法.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">init_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a new object with type cls, initialized with args.&#34;&#34;&#34;</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="n">make_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">init</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="s1">&#39;__init__&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">init</span><span class="p">:</span>
            <span class="n">init</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">instance</span>
</code></pre></td></tr></table>
</div>
</div><p>这最后的函数完成了我们的对象系统. 我们现在有会在局部<code>set</code>但是<code>get</code>时可回退到它们的类的实例. 一个实例在它的类中查找名称之后, 它绑定它自己本身到一个函数值来创建一个方法. 最后, 类可以创建新(<code>new</code>)实例, 然后它们在实例创建之后立即应用它们的<code>__init__</code>构造器函数.</p>
<p>在这个对象系统, 唯一应该通过用户调用的函数是<code>make_class</code>. 所有其他的功能通过消息传递来激活. 同样地, Python的对象系统是通过<code>class</code>声明来调用, 以及所有它的其他功能通过点语法以及调用类来激活.</p>
<h4 id="263-使用已经实现的对象">2.6.3 使用已经实现的对象</h4>
<p>我们现在回到之前章节的使用银行账户的例子. 使用我们实现了的对象系统, 我们会创建一个<code>Account</code>类, 一个<code>CheckingAccount</code>子类, 以及一个各自的实例.</p>
<p><code>Account</code>类是通过<code>make_account_class</code>函数创建的, 也就是跟在Python中的<code>class</code>声明有相似结构的函数, 但是以调用<code>make_class</code>结束.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">make_account_class</span><span class="p">():</span>
        <span class="s2">&#34;&#34;&#34;Return the Account class, which has deposit and withdraw methods.&#34;&#34;&#34;</span>
        <span class="n">interest</span> <span class="o">=</span> <span class="mf">0.02</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">account_holder</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;set&#39;</span><span class="p">](</span><span class="s1">&#39;holder&#39;</span><span class="p">,</span> <span class="n">account_holder</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;set&#39;</span><span class="p">](</span><span class="s1">&#39;balance&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">deposit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
            <span class="s2">&#34;&#34;&#34;Increase the account balance by amount and return the new balance.&#34;&#34;&#34;</span>
            <span class="n">new_balance</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="s1">&#39;balance&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">amount</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;set&#39;</span><span class="p">](</span><span class="s1">&#39;balance&#39;</span><span class="p">,</span> <span class="n">new_balance</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="s1">&#39;balance&#39;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
            <span class="s2">&#34;&#34;&#34;Decrease the account balance by amount and return the new balance.&#34;&#34;&#34;</span>
            <span class="n">balance</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="s1">&#39;balance&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">amount</span> <span class="o">&gt;</span> <span class="n">balance</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;Insufficient funds&#39;</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;set&#39;</span><span class="p">](</span><span class="s1">&#39;balance&#39;</span><span class="p">,</span> <span class="n">balance</span> <span class="o">-</span> <span class="n">amount</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="s1">&#39;balance&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">make_class</span><span class="p">(</span><span class="nb">locals</span><span class="p">())</span>
</code></pre></td></tr></table>
</div>
</div><p>最后调用<code>locals</code>返回一个有字符串为键的字典, 它在局部帧中包含新的名值绑定.</p>
<p><code>Account</code>类最后是通过赋值来实例化的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">Account</span> <span class="o">=</span> <span class="n">make_account_class</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>然后, 一个账户实例通过<code>new</code>消息来创建, 也就是需要一个名称来给新创建的账户.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">kirk_account</span> <span class="o">=</span> <span class="n">Account</span><span class="p">[</span><span class="s1">&#39;new&#39;</span><span class="p">](</span><span class="s1">&#39;Kirk&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>然后, <code>get</code>消息传递给<code>kirk_account</code>来检索属性以及方法. 方法可以被调用来更新账户的余额.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">kirk_account</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="s1">&#39;holder&#39;</span><span class="p">)</span>
<span class="s1">&#39;Kirk&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kirk_account</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="s1">&#39;interest&#39;</span><span class="p">)</span>
<span class="mf">0.02</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kirk_account</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="s1">&#39;deposit&#39;</span><span class="p">)(</span><span class="mi">20</span><span class="p">)</span>
<span class="mi">20</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kirk_account</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="s1">&#39;withdraw&#39;</span><span class="p">)(</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">15</span>
</code></pre></td></tr></table>
</div>
</div><p>就像Python的对象系统, 设置一个实例的属性不会修改它对应的类的属性.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">kirk_account</span><span class="p">[</span><span class="s1">&#39;set&#39;</span><span class="p">](</span><span class="s1">&#39;interest&#39;</span><span class="p">,</span> <span class="mf">0.04</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Account</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="s1">&#39;interest&#39;</span><span class="p">)</span>
<span class="mf">0.02</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>继承</strong>. 我们可以通过重载一个类的属性的子集来创建一个子类<code>CheckingAccount</code>. 在这个例子中, 我们修改<code>withdraw</code>方法去征收费用, 同时我们降低利率.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">make_checking_account_class</span><span class="p">():</span>
        <span class="s2">&#34;&#34;&#34;Return the CheckingAccount class, which imposes a $1 withdrawal fee.&#34;&#34;&#34;</span>
        <span class="n">interest</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="n">withdraw_fee</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
            <span class="n">fee</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="s1">&#39;withdraw_fee&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Account</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="s1">&#39;withdraw&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span> <span class="o">+</span> <span class="n">fee</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">make_class</span><span class="p">(</span><span class="nb">locals</span><span class="p">(),</span> <span class="n">Account</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个实现中, 我们从子类的<code>withdraw</code>函数调用基类<code>Account</code>的<code>withdraw</code>函数, 就像在Python的内建对象系统中一样. 我们可以像之前一样创建子类本身以及一个实例.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">CheckingAccount</span> <span class="o">=</span> <span class="n">make_checking_account_class</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">jack_acct</span> <span class="o">=</span> <span class="n">CheckingAccount</span><span class="p">[</span><span class="s1">&#39;new&#39;</span><span class="p">](</span><span class="s1">&#39;Spock&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>存款的行为完全相同, 跟构造函数一样. 取款从特殊的<code>withdraw</code>方法征收$1的费用, 同时<code>interest</code>有来自于<code>CheckingAccount</code>的新的更低的值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">jack_acct</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="s1">&#39;interest&#39;</span><span class="p">)</span>
<span class="mf">0.01</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">jack_acct</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="s1">&#39;deposit&#39;</span><span class="p">)(</span><span class="mi">20</span><span class="p">)</span>
<span class="mi">20</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">jack_acct</span><span class="p">[</span><span class="s1">&#39;get&#39;</span><span class="p">](</span><span class="s1">&#39;withdraw&#39;</span><span class="p">)(</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">14</span>
</code></pre></td></tr></table>
</div>
</div><p>我们的建立在字典之上的对象系统跟Python内建的对象系统的实现是十分类似的. 在Python中, 任何一个用户定义类的实例都具有一个特别的属性<code>__dict__</code>用于在字典中为这个对象存储本地实例属性. 就像我们的字典<code>attributes</code>. Python的不同在于它区分某些跟内建函数交互的特别方法以确保这些函数行为对很多不同类型的参数是正确的. 在不同类型上操作的函数是下一节的主题.</p>
<h3 id="27-对象抽象">2.7 对象抽象</h3>
<p>对象系统允许程序员去高效地建立以及使用抽象数据表示. 它同样也设计为允许在同一程序内共存多重数据抽象表示.</p>
<p>对象抽象的一个中心概念是泛型函数, 也就是一个可以接受多种不同类型值的函数, 在实现泛型函数中我们会考虑三种不同的技术: 共享实例, 类型派发, 以及强制类型. 在建立这些概念的过程中, 我们也会发现Python的对象系统中的特性也就是支持泛型的创建.</p>
<h4 id="271-字符串转换">2.7.1 字符串转换</h4>
<p>为了有效地表示数据, 一个对象值应该表现得像它所代表的类型的数据, 包括产出它自身所代表的字符串. 数据值的字符串表示在交互式语言中是十分重要的, 例如Python会自动地展示交互式会话中的表达式的值的字符串表示.</p>
<p>字符串值提供了在人之间进行传达信息的基本介质. 字符序列可以被渲染到屏幕上, 打印到纸上, 大声读, 转换成盲文, 或者以摩尔斯密码广播. 字符串同样也是编程的根本因为它们可以表示Python的表达式.</p>
<p>Python规定所有的对象应该产出两种不同的字符串表示: 一种是可以被人类解释的文本以及一种是可以被Python解释的表达式. 字符串的构造函数<code>str</code>, 返回一个可以被人类阅读的字符串. 在可能的情况下, <code>repr</code>函数返回一个Python表达式, 其运算结果为相等的对象. <code>repr</code>的文档字符串解释了这个属性:</p>
<pre><code>repr(object) -&gt; string
</code></pre><p>返回对象表示的标准字符串.<br />
对大多数对象类型来说, eval(repr(object)) == object.</p>
<p>对一个表达式的值调用<code>repr</code>的结果就是Python打印在交互式回话中所打印的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="mf">12e12</span>
<span class="mf">12000000000000.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="mf">12e12</span><span class="p">))</span>
<span class="mf">12000000000000.0</span>
</code></pre></td></tr></table>
</div>
</div><p>在原始值没有表达存在的情况下, Python通常会产出一个被角括号包围的描述.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span>
<span class="s1">&#39;&lt;built-in function min&gt;&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>str</code>构造器通常跟<code>repr</code>重合, 但是在某些情况下会提供更多的可解释文本的表示. 例如, 我们会看到在<code>dates</code>对象上<code>str</code>与<code>repr</code>之间的不同.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tues</span> <span class="o">=</span> <span class="n">date</span><span class="p">(</span><span class="mi">2011</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">repr</span><span class="p">(</span><span class="n">tues</span><span class="p">)</span>
<span class="s1">&#39;datetime.date(2011, 9, 12)&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span><span class="p">(</span><span class="n">tues</span><span class="p">)</span>
<span class="s1">&#39;2011-09-12&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>定义<code>repr</code>函数提出了一个新的挑战: 我们想要它在所有类型的日期下都能够正确应用, 即使这些类型在<code>repr</code>实现的时候还不存在. 我们会想要让它成为一个通用或者多态性函数, 一个可以被应用在很多(聚合/poly)不同类型(变形/morph)的数据.</p>
<p>在这种情况下, 对象系统提供一个优雅的解决办法: <code>repr</code>函数总是调用它参数上的一个叫做<code>__repr__</code>的方法.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">tues</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
<span class="s1">&#39;datetime.date(2011, 9, 12)&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>通过在用户定义类上实现这一相同的方法, 我们可以拓展<code>repr</code>的适用性到未来我们创建的任何类上. 总的来说, 这一例子强调了点表达式的其他好处, 就是它们提供了将现有函数的域扩展为新对象类型的机制.</p>
<p><code>str</code>构造器也是以相似的方式实现: 它调用参数上的一个叫做<code>__str__</code>的方法.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">tues</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
<span class="s1">&#39;2011-09-12&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>这些多态函数用于演示更一般的原理: 某些函数应该应用到多种数据类型上. 此外, 创建此类函数的一种方式是在每个类上使用不同定义的共享属性名称.</p>
<h4 id="272-特殊方法">2.7.2 特殊方法</h4>
<p>在Python中, 某些特殊方法是通过Python解析器在特殊情况下调用的. 例如, 无论什么时候一个对象被创建时类的<code>__init__</code>方法会自动被调用. 当进行打印时<code>__str__</code>会自动被调用, 以及<code>__repr__</code>在互动式回话中被调用来显示值.</p>
<p>Python中有许多其他行为的特殊名称. 其中一些最常使用的已经描述在下面.</p>
<p><strong>真假值</strong>. 前面我们看到在Python中数字具有真实值; 更进一步来说, 0代表假值而其他所有数字代表真值. 实际上, 在Python中的所有对象具有真值. 默认地, 用户定义的类的对象都认为是真值, 但是特殊方法<code>__bool__</code>可以用来重载这个行为. 如果一个对象定义了<code>__bool__</code>方法, 那么Python将调用这个方法来判断它的真实值.</p>
<p>举个例子, 假设我们想要让一个余额为0的银行账户是假值. 我们可以添加一个<code>__bool__</code>方法到<code>Account</code>类来创造这个行为.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">Account</span><span class="o">.</span><span class="n">__bool__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">!=</span> <span class="mi">0</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以调用布尔构造器来查看一个对象的真实值, 然后我们可以使用布尔上下文中的任何对象.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">bool</span><span class="p">(</span><span class="n">Account</span><span class="p">(</span><span class="s1">&#39;jack&#39;</span><span class="p">))</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">Account</span><span class="p">(</span><span class="s1">&#39;jack&#39;</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;jack has nothing&#39;</span><span class="p">)</span>
<span class="n">jack</span> <span class="n">has</span> <span class="n">nothing</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>序列操作</strong>. 我们已经知道可以使用<code>len</code>函数来确定序列的长度.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="s1">&#39;Go Bears!&#39;</span><span class="p">)</span>
<span class="mi">9</span>
</code></pre></td></tr></table>
</div>
</div><p><code>len</code>函数调用它的参数的<code>__len__</code>方法来判断参数的长度. 所有內建序列类型都实现这一方法.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="s1">&#39;Go Bears!&#39;</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>
<span class="mi">9</span>
</code></pre></td></tr></table>
</div>
</div><p>如果一个序列没有提供<code>__bool__</code>方法, Python会使用一个序列的长度来判断它的真实值. 空序列为假值, 而非空序列则为真值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">bool</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bool</span><span class="p">([])</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bool</span><span class="p">(</span><span class="s1">&#39;Go Bears!&#39;</span><span class="p">)</span>
<span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p><code>__getitem__</code>方法通过元素选择操作符来调用, 但它也可以被直接调用.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="s1">&#39;Go Bears!&#39;</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="s1">&#39;B&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s1">&#39;Go Bears!&#39;</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="s1">&#39;B&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>可调用对象</strong>. 在Python, 函数是一等对象, 因此它们可以作为数据进行传递以及可以像其他对象一样具有属性值. Python也允许我们通过引入一个<code>__call__</code>方法来定义一个像函数一样可以&quot;调用&quot;的对象. 使用这种方法, 我们可以定义一个行为像高阶函数的类.</p>
<p>举个例子, 考虑下接下来的高阶函数, 它会返回一个函数这个函数会添加一个常量值到它的参数上.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">make_adder</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">adder</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">k</span>
        <span class="k">return</span> <span class="n">adder</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">add_three</span> <span class="o">=</span> <span class="n">make_adder</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">add_three</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="mi">7</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以创建一个定义了<code>__call__</code>方法并提供相同功能的<code>Adder</code>类.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Adder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">add_three_obj</span> <span class="o">=</span> <span class="n">Adder</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">add_three_obj</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="mi">7</span>
</code></pre></td></tr></table>
</div>
</div><p>这里, <code>Adder</code>类的行为跟高阶函数<code>make_adder</code>相似, <code>add_three_obj</code>对象的行为跟<code>add_three</code>函数的行为相似. 我们进一步地模糊了数据与函数之间的界限.</p>
<p><strong>算术</strong>. 特殊方法还可以定义应用于用户定义对象的内置运算符的行为. 为了提供这种一般性, Python遵循特殊协议来应用每一个操作符. 例如, 要运行含有<code>+</code>操作符的表达式, Python检查特殊方法表达式左右两边的操作数. 首先, Python检查左操作数的<code>__add__</code>方法的值, 然后检查右操作数的<code>__radd__</code>方法的值. 如果任意一个能找到, 这个方法会以其他操作数的值作为参数被调用. 一些例子将在下面的章节中给出. 对于想要进一步了解细节的读者, Python文档描述了完整的<a href="http://docs.python.org/py3k/reference/datamodel.html#special-method-names">操作符名称集</a>. Dive into Python 3 也有一个<a href="http://getpython3.com/diveintopython3/special-method-names.html">特殊方法名称集</a>章节, 它描述了有多少这些特殊方法名称被使用.</p>
<h4 id="273-多重表示">2.7.3 多重表示</h4>
<p>抽象屏障允许我们分离数据的使用以及表示. 然而, 在大型程序中, 对程序中的数据类型表示为&quot;底层表示&quot;并不总是有意义的. 一方面, 对数据对象可能有多个有用的表示, 同时我们可能喜欢去设计可以处理多重表示的系统</p>
<p>举个简单的例子, 复数可能会用两种相等的方式来表示: 以直角坐标形式(实部和虚部)以及以极坐标形式(幅度和角度). 有时候直角坐标形式更加适合, 而有时候极坐标形式更加适合. 实际上, 考虑这样的一个需要表示两种形式的复数系统以及能在其中一种表示下操纵复数来工作的函数是十分合理的. 我们会在下面实现这样的一个系统. 作为附注, 我们正在开发一个系统, 它会对复数执行算术运算来作为使用通用操作的程序的简单但不现实的例子. <a href="http://docs.python.org/py3k/library/stdtypes.html#typesnumeric">复数类型</a>在Python中是內建类型, 但对于这个例子我们会实现自己的复数类型.</p>
<p>允许数据进行多重表示的想法常常会出现. 大型软件系统通常由许多长期工作的人设计, 且受制于随时间变化的要求. 在这样的环境下, 允许为每个人提前选择好数据的表示是根本不可能的. 此外, 数据抽象屏障从使用中隔离了表示, 我们需要隔离彼此不同的设计选择的抽象屏障并允许不同设计选择在单个程序中共存.</p>
<p>我们会在高层次的抽象以及朝实现具体表示上来设计自己的实现. 一个<code>Complex</code>是一个<code>Number</code>, 而数字可以加或者乘在一起. 抽象了的数字如何能够通过名为<code>add</code>以及<code>mul</code>的方法被加或者乘在一起.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Number</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这个类要求数字对象具有<code>add</code>以及<code>mul</code>方法, 但是没有定义它们. 它甚至没有提供一个<code>__init__</code>方法. <code>Number</code>的目的不是用来直接实例化, 而是作为超类为各种指定数字类型提供服务. 我们的下一个任务是定义适合于复数的<code>add</code>以及<code>mul</code>方法.</p>
<p>一个复数可以想象成是由两个正交轴形成的二维空间中的一个点, 实轴以及虚轴. 从这个角度看, 复数<code>c = real + imag * i(这里的i * i = -1)</code>可以认为是一个平面上的点, 它的水平坐标是<code>real</code>, 垂直坐标是<code>imag</code>. 复数加法涉及到增加它们各自的<code>real</code>轴以及<code>imag</code>轴的坐标.</p>
<p>当乘以复数时, 将其想象成一个极坐标上以幅度和角度表示的复数会更加自然. 两个复数的乘积的结果就是的到一个向量值, 由其中一个复数的向量值跟另一个复数的向量值长度因子的乘积的得到, 然后加上一个角度值, 由其中一个复数的角度, 旋转值为另一个向量的角度得到.</p>
<p><code>Complex</code>类继承自<code>Number</code>类, 并描述了复数的算术.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Complex</span><span class="p">(</span><span class="n">Number</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="n">magnitude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">magnitude</span>
            <span class="k">return</span> <span class="n">ComplexMA</span><span class="p">(</span><span class="n">magnitude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这个实现假设对于复数存在两个类, 跟复数的两个自然表示相对应:</p>
<ul>
<li><code>ComplexRI</code>从实部和虚部来构造一个复数</li>
<li><code>ComplexMA</code>从向量和角度来构造一个复数</li>
</ul>
<p><strong>接口</strong>. 对象属性是消息传递的一种形式, 允许不同数据类型以不同的方式来响应相同的消息. 从不同类中引出相同行为的一组共享消息是一种强大的抽象方法. 一个_接口_就是一个共享属性名以及它们的行为规范的集合. 在复数的例子中, 接口需要实现由四个属性组成的算法: <code>real</code>, <code>imag</code>, <code>magnitude</code>和<code>angle</code>.</p>
<p>想要在复杂的算术上是正确的, 这些属性必须要一致. 也就是说, 直角坐标系(real, imag)以及极坐标系(magnitude, angle)必须在复平面上是描述相同的点. <code>Complex</code>类通过决定这些属性如何用于跟一个复数来进行<code>add</code>以及<code>mul</code>从而隐式定义这个接口.</p>
<p><strong>属性</strong>. 要求两个或多个属性值保持彼此之间的固定关系是一个新的问题. 一个解决办法是只为其中一个表示保存属性值然后其他表示则在它们需要的时候计算出来.</p>
<p>Python具有一个简单功能用于从零参数函数即时计算属性. <code>@property</code>装饰器允许调用函数而不调用表达式语法(跟随表达式后的括号). <code>ComplexRI</code>类保存<code>real</code>以及<code>imag</code>属性, 同时一经请求则计算<code>magnitude</code>和<code>angle</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">atan2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">ComplexRI</span><span class="p">(</span><span class="n">Complex</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">real</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">imag</span>
        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">magnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">atan2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
        <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;ComplexRI({0:g}, {1:g})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这个实现的结果是, 全部的四个复数算法需要的属性都可以不用任何调用表达式就访问到, 同时修改<code>real</code>以及<code>imag</code>都会反映到<code>magnitude</code>以及<code>angle</code>中.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">ri</span> <span class="o">=</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ri</span><span class="o">.</span><span class="n">real</span>
<span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ri</span><span class="o">.</span><span class="n">magnitude</span>
<span class="mf">13.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ri</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="mi">9</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ri</span><span class="o">.</span><span class="n">real</span>
<span class="mi">9</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ri</span><span class="o">.</span><span class="n">magnitude</span>
<span class="mf">15.0</span>
</code></pre></td></tr></table>
</div>
</div><p>同样地, <code>ComplexMA</code>类保存<code>magnitude</code>以及<code>angle</code>, 但当<code>real</code>以及<code>imag</code>被查找时会立马计算得出.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">pi</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">ComplexMA</span><span class="p">(</span><span class="n">Complex</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="n">magnitude</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span>
        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
        <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;ComplexMA({0:g}, {1:g} * pi)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="o">/</span><span class="n">pi</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>修改<code>magnitude</code>或者<code>angle</code>都会立马反映到<code>real</code>以及<code>imag</code>属性上.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">ma</span> <span class="o">=</span> <span class="n">ComplexMA</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ma</span><span class="o">.</span><span class="n">imag</span>
<span class="mf">2.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ma</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">pi</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ma</span><span class="o">.</span><span class="n">real</span>
<span class="o">-</span><span class="mf">2.0</span>
</code></pre></td></tr></table>
</div>
</div><p>我们现在已经完成了复数的实现. 实现了复数的任意类可以在任意<code>Complex</code>的算法上使用任意的参数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">ComplexMA</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ComplexRI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ComplexMA</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>编码多个表示的借口方法具有吸引人的属性. 类可以为每个表示单独开发; 它们必须也只需商定共享的属性的名称, 以及这些属性的任何行为条件. 接口是额外附加的. 如果其他程序员想要添加第三个复数的表示到相同的程序中, 它们只需要创建另外一个具有相同属性的类.</p>
<p>数据的多重表示跟我们这章的一开始的数据抽象的思想密切相关. 使用数据抽象, 我们能够去修改数据类型的实现而不修改程序的含义. 通过接口以及消息传递, 我们可以在相同的程序内有多种不同的表示. 这两种情况下, 名称集合以及对应的行为条件定义了实现这种灵活性的抽象.</p>
<h4 id="274-通用函数">2.7.4 通用函数</h4>
<p>通用函数是一个可应用在不同类型参数上的方法或者函数. 我们已经见识过很多的例子. <code>Complex.add</code>方法是通用的, 因为它采用<code>ComplexRI</code>或者<code>ComplexMA</code>作为<code>other</code>的值. 这个灵活性是通过确保<code>ComplexRI</code>以及<code>ComplexMA</code>的共享同一个接口来获得的. 使用接口以及消息传递只是一些用来实现通用函数的方法其中的一种. 在这一节中, 我们会考虑其他两个: 类型调度以及类型强制.</p>
<p>假设, 除了我们的复数类型, 我们实现了一个<code>Rational</code>类来代表准确的分数. <code>add</code>以及<code>mul</code>方法跟本章之前的<code>add_rational</code>以及<code>mul_rational</code>表示相同的计算.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">gcd</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Rational</span><span class="p">(</span><span class="n">Number</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">):</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numer</span> <span class="o">=</span> <span class="n">numer</span> <span class="o">//</span> <span class="n">g</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denom</span> <span class="o">=</span> <span class="n">denom</span> <span class="o">//</span> <span class="n">g</span>
        <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;Rational({0}, {1})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">denom</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">denom</span>
            <span class="n">ny</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">numer</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">denom</span>
            <span class="k">return</span> <span class="n">Rational</span><span class="p">(</span><span class="n">nx</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">+</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="n">numer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">numer</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">denom</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">denom</span>
            <span class="k">return</span> <span class="n">Rational</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>我们通过给超类包含<code>add</code>记忆<code>mul</code>方法已经实现了接口. 结果是, 我们可以用熟悉的操作来加上以及相乘有理数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>然而, 我们还是不能将一个有理数加到一个复数上, 即使在数学上已经明确定义了这样的组合. 我们想要以一些小心控制的方式来介绍这种跨类型操作, 因此我们可以假设它没有严重违反我们的抽象屏障. 这跟我们所期望的结果之前存在紧密的关系: 我们想要能够将一个复数添加到一个有理数上, 以及我们想要一般方法<code>__add__</code>能够对所有的数字类型都做正确的事情. 同时, 为了维护程序的模块化, 我们想要尽可能分离复数与有理数的关注.</p>
<p><strong>类型调度</strong>. 一种实现跨类型操作的方式是基于函数或方法的参数的类型来选择行为. 类型调度的思想是去写一个函数来检查它们接收的参数的类型, 然后为这些类型执行合适的代码.</p>
<p>內建函数<code>isinstance</code>接受一个对象以及一个类. 如果对象所具有的类是这个类或者是继承自这个类的话就返回真值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ComplexRI</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Complex</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ComplexMA</span><span class="p">)</span>
<span class="bp">False</span>
</code></pre></td></tr></table>
</div>
</div><p>类型派发的一个简单的例子是一个为不同类型的复数使用不同的实现的<code>is_real</code>函数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">is_real</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return whether c is a real number with no imaginary part.&#34;&#34;&#34;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ComplexRI</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">imag</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ComplexMA</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">angle</span> <span class="o">%</span> <span class="n">pi</span> <span class="o">==</span> <span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">is_real</span><span class="p">(</span><span class="n">ComplexRI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">is_real</span><span class="p">(</span><span class="n">ComplexMA</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="p">))</span>
<span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p>类型派发并不总是使用<code>isinstance</code>来执行的. 对于算术, 我们会为字符类型的<code>Rational</code>以及<code>Complex</code>的实例提供一个<code>type_tag</code>属性, 这个属性是一个字符串值. 当两个值x以及y都具有<code>type_tag</code>, 那么我们就可以用<code>x.add(y)</code>直接合并它们. 如果没有, 我们需要一个跨类型操作.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">Rational</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">=</span> <span class="s1">&#39;rat&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Complex</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">=</span> <span class="s1">&#39;com&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">==</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">type_tag</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">==</span> <span class="n">ComplexMA</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">type_tag</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">==</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">type_tag</span>
<span class="bp">False</span>
</code></pre></td></tr></table>
</div>
</div><p>要将复数跟有理数结合, 我们需要编写同时依赖它们表现类型的函数. 接下来, 我们依赖一个事实, 那就是一个<code>Rational</code>可以近似转换为一个实数的<code>float</code>类型值. 这个结果可以用复数来进行组合.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">add_complex_and_rational</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="n">number</span><span class="o">/</span><span class="n">r</span><span class="o">.</span><span class="n">denom</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>乘法涉及到相似的转换, 在极坐标下, 在复平面上的实数总是具有一个正的向量. 角度0表示一个正数, 角度pi表示一个负数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">mul_complex_and_rational</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="n">r_magnitude</span><span class="p">,</span> <span class="n">r_angle</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">numer</span><span class="o">/</span><span class="n">r</span><span class="o">.</span><span class="n">denom</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">r_magnitude</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r_magnitude</span><span class="p">,</span> <span class="n">r_angle</span> <span class="o">=</span> <span class="o">-</span><span class="n">r_magnitude</span><span class="p">,</span> <span class="n">pi</span>
        <span class="k">return</span> <span class="n">ComplexMA</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">*</span> <span class="n">r_magnitude</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="n">r_angle</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>乘法跟加法都是可交换的, 因此交换参数顺序可以用这些跨类型操作的相同实现.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">add_rational_and_complex</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">add_complex_and_rational</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">mul_rational_and_complex</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mul_complex_and_rational</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>类型调度扮演的角色是去确保这些跨类型操作在适当的时候使用. 下面, 我们重写<code>Number</code>超类为其<code>__add__</code>以及<code>__mul__</code>来使用类型调度.</p>
<p>我们使用<code>type_tag</code>属性来区分参数的类型. 也可以直接使用內建的<code>isinstance</code>方法, 但是<code>tags</code>简化了实现. 使用类型标签也表明了类型调度不需要跟Python的类型系统相链接, 而是用于在异构域上创建通用函数的一般技术.</p>
<p><code>__add__</code>方法考虑两种情况. 首先, 如果两个参数具有相同的类型的标签, 那么它假设第一个参数的<code>add</code>方法可以以第二个参数作为它的参数. 否则, 它检查是否一个跨类型的字典实现, 叫做<code>adders</code>, 包含一个可以对具有这些类型标签的参数进行相加的函数. 如果有这样的一个函数, <code>cross_apply</code>方法并应用它. <code>__mul__</code>方法具有相似的结构.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Number</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adders</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_apply</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">adders</span><span class="p">)</span>
        <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_apply</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">cross_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">cross_fns</span><span class="p">):</span>
            <span class="n">cross_fn</span> <span class="o">=</span> <span class="n">cross_fns</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">cross_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="n">adders</span> <span class="o">=</span> <span class="p">{(</span><span class="s2">&#34;com&#34;</span><span class="p">,</span> <span class="s2">&#34;rat&#34;</span><span class="p">):</span> <span class="n">add_complex_and_rational</span><span class="p">,</span>
                  <span class="p">(</span><span class="s2">&#34;rat&#34;</span><span class="p">,</span> <span class="s2">&#34;com&#34;</span><span class="p">):</span> <span class="n">add_rational_and_complex</span><span class="p">}</span>
        <span class="n">multipliers</span> <span class="o">=</span> <span class="p">{(</span><span class="s2">&#34;com&#34;</span><span class="p">,</span> <span class="s2">&#34;rat&#34;</span><span class="p">):</span> <span class="n">mul_complex_and_rational</span><span class="p">,</span>
                       <span class="p">(</span><span class="s2">&#34;rat&#34;</span><span class="p">,</span> <span class="s2">&#34;com&#34;</span><span class="p">):</span> <span class="n">mul_rational_and_complex</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在新的<code>Number</code>类中, 所有跨类型实现都通过一对类型标签标记在<code>adders</code>以及<code>multipliers</code>字典中.</p>
<p>这种基于字典的类型调度方法是可拓展的. 新的<code>Number</code>子类型可以通过声明一个类型标签以及添加跨类型操作到<code>Number.adders</code>以及<code>Number.multipliers</code>从而安装到系统中. 它们也可以定义在子类中定义自己的<code>adders</code>以及<code>multipliers</code>.</p>
<p>虽然我们引入了一些复杂性到系统中, 但我们现在可以混合类型在加法以及乘法表达式中.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">ComplexRI</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Rational</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">ComplexMA</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ComplexMA</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>强制转换</strong>. 一般情况下完全不相关的操作作用于完全无关的类型上, 实现明确的跨类型操作也许是可以期望的最好的方式, 虽然它可能会很麻烦. 幸运的是, 有时我们可以通过利用在我们的系统中潜在的附加结构来做得更好. 不同的数据类型通常是不完全独立的, 并且这里或许存在将一种类型的对象看做是另外一种类型对象的方式. 这过程叫做强制转换. 例如, 如果我们被要求以算术将有理数和复数进行结合, 我们可以将有理数看作是复数且它的虚部是0. 这样做了之后, 我们可以用<code>Complex.add</code>以及<code>Complex.mul</code>来结合它们.</p>
<p>一般情况下, 我们可以通过设计强制转换函数实现这个想法, 这个函数可以转换一种类型的对象到另一种类型的等量对象. 这里是一个典型的强制转换函数, 它可以转换一个有理数为一个虚部是0的复数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">rational_to_complex</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">numer</span><span class="o">/</span><span class="n">r</span><span class="o">.</span><span class="n">denom</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>Number</code>类的替代定义通过尝试强制转换两个参数为相同的类型来执行跨类型操作. <code>coercions</code>字典通过类型标签元组对索引所有可能的强制类型, 指示相对应的值将所述第一种类型的值强制转换为第二种类型的值.</p>
<p>通常不可能每种数据类型的任意数据对象强制转换成其他所有类型. 例如, 没有办法将强制转换一个任意复数为有理数, 因此没有这样的强制转换实现会出现在<code>coercions</code>字典中.</p>
<p><code>coerce</code>方法返回两个具有相同类型标签的值. 它检查它的参数的类型标签的值, 将它们跟<code>coercions</code>字典的条目对比, 然后用<code>coerce_to</code>转换一个参数类型为另一个参数的类型. 在<code>coercions</code>中只需要一个条目来完成我们的跨类型算术系统, 并替换类型调度版本的<code>Number</code>中的四个跨类型函数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Number</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">coerce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coercions</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coerce_to</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">),</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coercions</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">coerce_to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span><span class="p">))</span>
        <span class="k">def</span> <span class="nf">coerce_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_tag</span><span class="p">):</span>
            <span class="n">coercion_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coercions</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span><span class="p">,</span> <span class="n">other_tag</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">coercion_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">coercions</span> <span class="o">=</span> <span class="p">{(</span><span class="s1">&#39;rat&#39;</span><span class="p">,</span> <span class="s1">&#39;com&#39;</span><span class="p">):</span> <span class="n">rational_to_complex</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个强制类型方案跟定义显示跨类型操作的方法相比有一些优点. 虽然我们还是需要编写强制转换函数来关联类型, 但我们只需要为每一对类型编写一个函数, 而不是为每个类型集合以及每个通用操作使用不同的函数. 我们在这里期望要指出的事实是, 类型之间的适当转换仅依赖于类型本身, 而不是以来要应用的特定操作.</p>
<p>更进一步的好处来自于扩展强制转换. 一些更复杂的强制转换方案并不是仅仅是尝试去强制转换一种类型到另一种, 而是可能会尝试去强制转换每个不同的类型到第三种常见类型. 考虑一个菱形以及一个矩形: 两者都不是彼此类型的额外情况, 但是都可以被看作是四边形. 另一个强制转换的扩展是强制转换迭代, 一种数据类型通过中间类型被强制转换成另一种类型. 思考一下一个整数可以被转换成一个实数只要首先将它转换成一个有理数, 然后将这个有理数转换成实数. 以这种方式的链接强制转换可以减少程序所需的强制函数的总数.</p>
<p>尽管强制转换具有好处, 但也有潜在的缺点. 一个是强制函数在应用它们时可能会丢失信息. 在我们的例子中, 有理数是精确表示, 但是当它们被转换成复数时就成了近似值.</p>
<p>一些编程语言有內建自动的强制转换系统. 实际上, 早期版本的Python有一个<code>__coerce__</code>特殊方法在对象上. 最后, 内置强制系统的复杂性没有证明它的使用是有理的, 因此它被移除了. 而是, 特定运算根据需要对它们的参数应用强制转换.</p>
<h3 id="28-效率">2.8 效率</h3>
<p>决定如何表示以及传输数据常常收可供选择的效率影响. 效率指的是表示或处理过程使用的计算资源, 例如函数计算结果或者表示一个对象需要用到多少时间以及内存. 这些数量根据实现的细节可以有很大的差异.</p>
<h4 id="281-测量效率">2.8.1 测量效率</h4>
<p>精确地测量一个程序需要多长时间来运行或者消耗多少内存是一个挑战, 因为结果取决于很多电脑配置的细节. 一个更可靠的方式去描绘程序效率特征的方式是去测量某些事件发生了多少次, 例如函数的调用.</p>
<p>让我们回到第一个数递归函数, <code>fib</code>函数用于计算斐波那契数列中的数字.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fib</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">5</span>
</code></pre></td></tr></table>
</div>
</div><p>思考一下下面描述的来自于计算<code>fib(6)</code>的结果的计算模式. 去计算<code>fib(5)</code>, 我们需要计算<code>fib(3)</code>以及<code>fib(4)</code>. 要计算<code>fib(3)</code>, 我们需要计算<code>fib(1)</code>以及<code>fib(2)</code>. 一般来说, 演进的过程看起来像一棵树. 每个蓝色点表示一个完整的计算斐波那契数的这棵树的遍历.</p>
<p><img src="http://www.composingprograms.com/img/fib.png" alt="斐波那契树" /></p>
<p>这棵树是典型的用于指导树递归的例子, 但是这是一个非常没有效率的计算斐波那契数的方式, 因为它做了许多冗余的计算. <code>fib(3)</code>的整个计算过程是多余的.</p>
<p>我们可以测量这种低效率. 高等级的<code>count</code>函数返回一个跟它的参数(也维持一个<code>call_count</code>属性)的等效函数. 用这种方法, 我们可以检查<code>fib</code>调用了多少次.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">counted</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="n">counted</span><span class="o">.</span><span class="n">call_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">counted</span><span class="o">.</span><span class="n">call_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">counted</span>
</code></pre></td></tr></table>
</div>
</div><p>通过统计调用<code>fib</code>的次数, 我们可以看到需要的调用次数增长得比斐波那契数字本身要快很多. 这种快速增长的调用次数就是树递归函数的特征.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">fib</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="n">fib</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fib</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>
<span class="mi">4181</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fib</span><span class="o">.</span><span class="n">call_count</span>
<span class="mi">13529</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>空间</strong>. 要明白函数对空间的要求, 我们必须要指出在我们的计算环境模型中一般会有多少空间被使用, 保存以及回收. 在计算表达式时, 解析器保存所有的活动环境以及被这些环境所引用的所有的值和帧. 一个环境如果它需要为某些需要将要运行的表达式提供执行上下文那么它就是活动的. 任何时候当创建函数调用的第一个帧最后返回的时候, 这个环境就变为非活动状态.</p>
<p>例如, 当计算<code>fib</code>, 解析器按照前面展示的顺序对每个值进行计算, 遍历树结构. 这样做, 只需要在计算树中的任何节点时对当前节点的上一个节点保持跟踪. 用于执行剩下的分支的内存是可回收的, 因为它不能影响到未来的计算. 一般来说, 树递归函数需要的空间跟树的最大深度成正比.</p>
<p>下面的图例描绘了执行<code>fib(3)</code>时创建的环境. 在执行最初的<code>fib</code>程序的返回的表达式的过程中, 表达式<code>fib(n-2)</code>被运行, 产生值0. 一旦这个值计算完成, 相应的环境帧(灰色淡出的那个)就不再需要了: 它不再是活动环境的一部分. 因此, 一个设计良好的解析器可以回收用于存储这个帧的内存. 另一方面, 如果这个解析器当前正在执行<code>fib(n-1)</code>, 那么一个环境会通过<code>fib</code>程序(在这里的n是2)创建且是活动的. 反过来, 原来创建的应用3的<code>fib</code>环境依然是活动的, 因为它的返回值还没有被计算出来.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20fib%28n%29%3A%0A%20%20%20%20if%20n%20%3D%3D%200%3A%0A%20%20%20%20%20%20%20%20return%200%0A%20%20%20%20if%20n%20%3D%3D%201%3A%0A%20%20%20%20%20%20%20%20return%201%0A%20%20%20%20return%20fib%28n-2%29%20%2B%20fib%28n-1%29%0A%0Aresult%20%3D%20fib%282%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>高阶的<code>count_frames</code>函数追踪<code>open_count</code>函数, 调用函数函数f的次数依然没有返回. <code>max_count</code>属性是通过<code>open_count</code>而获得的最大值, 而且它跟在计算过程中同时处于活动状态的帧的最大数相对应.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">count_frames</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">counted</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="n">counted</span><span class="o">.</span><span class="n">open_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">counted</span><span class="o">.</span><span class="n">max_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">counted</span><span class="o">.</span><span class="n">max_count</span><span class="p">,</span> <span class="n">counted</span><span class="o">.</span><span class="n">open_count</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="n">counted</span><span class="o">.</span><span class="n">open_count</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">counted</span><span class="o">.</span><span class="n">open_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">counted</span><span class="o">.</span><span class="n">max_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">counted</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fib</span> <span class="o">=</span> <span class="n">count_frames</span><span class="p">(</span><span class="n">fib</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fib</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>
<span class="mi">4181</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fib</span><span class="o">.</span><span class="n">open_count</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fib</span><span class="o">.</span><span class="n">max_count</span>
<span class="mi">19</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fib</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="mi">46368</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fib</span><span class="o">.</span><span class="n">max_count</span>
<span class="mi">24</span>
</code></pre></td></tr></table>
</div>
</div><p>总的来说, 在活动帧中测量的<code>fib</code>函数需要的空间小于输入, 其趋势是趋向更小的. 在总的递归调用中测量的时间需求是大于输出的, 其趋势是趋向更大的.</p>
<h4 id="282-记忆化">2.8.2 记忆化</h4>
<p>树递归计算过程通常可以通过记忆化技术来提高效率, 一个强有力的提高递归函数重复计算的效率的技术. 一个记忆化函数会对之前收到的任何参数的返回值进行存储. 第二次调用<code>fib(25)</code>不会再次递归计算返回值, 而是返回已经被构造而存在的那个值.</p>
<p>记忆化可以很自然地以高阶函数来表示, 也可以作为一个装饰器来使用. 下面的定义为之前的计算结果创建一个<code>cache</code>, 并以计算它们的参数作为索引. 字典的使用需要传给记忆化函数的参数是不可变的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">memo</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">def</span> <span class="nf">memoized</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">memoized</span>
</code></pre></td></tr></table>
</div>
</div><p>如果我们应用<code>memo</code>到斐波那契数的递归计算当中, 就演变出一种新的计算模式, 如下所示.</p>
<p><img src="http://composingprograms.com/img/fib_memo.png" alt="记忆化斐波那契数计算" /></p>
<p>在<code>fib(5)</code>的计算当中, 在树右侧的分支上<code>fib(2)</code>以及<code>fib(3)</code>的计算结果在计算<code>fib(4)</code>时被重用. 结果就是, 树递归的许多计算结果是不必要的.</p>
<p>使用<code>count</code>, 我们可以看到<code>fib</code>函数实际上只对于<code>fib</code>的每个唯一输入调用一次.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">counted_fib</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="n">fib</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fib</span>  <span class="o">=</span> <span class="n">memo</span><span class="p">(</span><span class="n">counted_fib</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fib</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>
<span class="mi">4181</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counted_fib</span><span class="o">.</span><span class="n">call_count</span>
<span class="mi">20</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fib</span><span class="p">(</span><span class="mi">34</span><span class="p">)</span>
<span class="mi">5702887</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counted_fib</span><span class="o">.</span><span class="n">call_count</span>
<span class="mi">35</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="283-增长的顺序">2.8.3 增长的顺序</h4>
<p>进程在消耗计算机时间以及空间资源上可以有巨大的不同, 就像先前的例子演示的那样. 然而, 当调用函数时精准地确定多少空间或时间会被使用是非常困难的任务, 这依赖于很多因素. 一个分析进程的有用的方式是将其分类为一组具有类似需求的进程组. 有效的分类是以进程的_增长顺序_来进行, 简单来说就是进程的资源需求随着函数的输入而如何增长.</p>
<p>作为增长的顺序的介绍, 我们会在下面分析函数<code>count_factors</code>, 它会统计可以将输入均分的整数的个数. 这个函数会尝试去把n跟每个小于或者等于它的平方根的数进行相除. 这个实现利用<code>如果k可以整除n同时k &lt; 根号n, 那么就有另一个因子j = n / k, 这样的j &gt; 根号n</code>这一事实.</p>
<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=from%20math%20import%20sqrt%0Adef%20count_factors%28n%29%3A%0A%20%20%20%20sqrt_n%20%3D%20sqrt%28n%29%0A%20%20%20%20k,%20factors%20%3D%201,%200%0A%20%20%20%20while%20k%20%3C%20sqrt_n%3A%0A%20%20%20%20%20%20%20%20if%20n%20%25%20k%20%3D%3D%200%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20factors%20%2B%3D%202%0A%20%20%20%20%20%20%20%20k%20%2B%3D%201%0A%20%20%20%20if%20k%20*%20k%20%3D%3D%20n%3A%0A%20%20%20%20%20%20%20%20factors%20%2B%3D%201%0A%20%20%20%20return%20factors%0A%0Aresult%20%3D%20count_factors%28576%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>
<p>执行<code>count_factors</code>需要多少时间? 精确的回答会随着机器的不同而变化, 但是我们可以做一些有用的涉及到计算量的一般性观察. 这个进程执行内部的<code>while</code>语句主体的总次数是小于根号n的最大整数. 在while语句之前或者之后的语句都只执行一次. 因此, 总的执行语句的次数是<code>w * 根号n + v</code>, 这里的w是指在while体内的语句的数量, 而v是指在while语句外面的语句. 虽然这样并不精确, 这个公式通常能够表明执行以n为输入的<code>count_factors</code>函数需要多少时间.</p>
<p>一个更加准确的描述是很难实现的. 常量w以及v并不是真正的常量, 因为赋值语句有时候会对因子执行有时候不会. 增长的顺序分析允许我们去掩饰这些细节从而分析增长的总体形态. 尤其是, <code>count_factors</code>增长的顺序精确地表示为一个术语, 那就是计算<code>count_factors</code>需要的时间量与根号n等比例缩放, 外加一些常量因数.</p>
<p><strong>Theta符号</strong>. 让n成为一个参数用来衡量输入到某些过程的大小, 同时让$R(n)$成为输入大小为n的过程所需要用到的资源的总数. 在我们之前的例子中, 我们让n作为我们的给定的函数需要去计算的数字, 但也有其他的可能性. 例如, 如果我们的目标是去计算一个数字的平方根的近似值, 我们可能会取n为所需精度的位数.</p>
<p>$R(n)$可能会测量所需要使用的内存, 执行的基本机器步骤的数量等等. 在计算机中每一步只用固定的时间来执行, 运行表达式所用的时间将与在运行过程中执行的基本机器步骤的数量成比例.</p>
<p>我们说$R(n)$增长的顺序为$R(n)$, 写作$R(n) = \Theta(f(n))$ (读作&quot;theta f(n)&quot;), 如果有正的常数<code>k1</code>以及<code>k2</code>独立于<code>n</code>像下面这样:</p>
<p>$$<br />
\begin{equation*}<br />
k_1 \cdot f(n) \leq R(n) \leq k_2 \cdot f(n)<br />
\end{equation*}<br />
$$</p>
<p>对于任何大于某个最小值m的值n. 换句话说, 对于大n, 值$R(n)$总是夹在两个以$f(n)$为规模增长的区间当中:</p>
<ul>
<li>一个下限$k_1 \cdot f(n)$以及</li>
<li>一个上限$k_2 \cdot f(n)$</li>
</ul>
<p>我们可以用应用这个定义来展示运行<code>count_factors(n)</code>所需要的步骤数, 通过检查函数可知其增长为$\Theta(\sqrt{n})$.</p>
<p>首先, 我们选择$k_1=1$以及$m=0$, 使得<code>count_factors(n)</code>的下限状态为对于给定的$n&gt;0$需要执行至少$1 \cdot\sqrt{n}$步. 这里至少有4行是在<code>while</code>声明之外执行的, 每一行至少需要一个步骤来执行. 这里至少有两行是在<code>while</code>体内执行的, 包括while头部本身. 所有这些至少需要一个步骤. <code>while</code>体至少执行$\sqrt{n}-1$次. 将这些下限进行合并, 我们可以看到, 过程至少需要$4 + 3\cdot (\sqrt{n}-1)$步, 也就是总是大于$k_1 \cdot\sqrt{n}$.</p>
<p>其次, 我们可以确认上限. 我们假设在<code>count_factors</code>体内的任何单一的一行最多需要p个步骤. 这个假设对于Python中的每一行都不是真的, 但可以适用于这种情况. 然后, 执行<code>count_factors(n)</code>至多需要$p \cdot(5 + 4 \sqrt{n})$步, 因为这里有5行在<code>while</code>声明之外, 以及4行(包括头部)在<code>while</code>之内. 这个上限能够保证即使<code>if</code>头部执行为真的情况也适用. 最后, 如果我们选择$k_2=5p$, 那么需要的步骤总是小于$k_2 \cdot \sqrt{n}$. 我们的论点是完整的.</p>
<h4 id="284-例子-指数">2.8.4 例子: 指数</h4>
<p>思考一下计算一个给定数字的指数的问题. 我们会想要一个函数来接受一个基础值b以及一个正整数的指数n然后计算$b^n$. 一个解决方式是通过一个递归定义来实现.</p>
<p>$$<br />
\begin{align*}<br />
b^n &amp;= b \cdot b^{n-1} \<br />
b^0 &amp;= 1<br />
\end{align*}<br />
$$</p>
<p>这很容易转换成为递归函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">b</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这是一个线性递归过程, 需要$\Theta(n)$部以及$\Theta(n)$的空间. 正如阶乘一样, 我们可以容易地制定一个相等的线性迭代函数, 它需要相似数量的步数, 但只需要固定的空间.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">exp_iter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以通过连续平方以更少的步数来计算指数. 例如, 不是这样计算$b^8$:</p>
<p>$$<br />
\begin{equation*}<br />
b \cdot (b \cdot (b \cdot (b \cdot (b \cdot (b \cdot (b \cdot b))))))<br />
\end{equation*}<br />
$$</p>
<p>我们可以用三个乘法来计算它:</p>
<p>$$<br />
\begin{align*}<br />
b^2 &amp;= b \cdot b \<br />
b^4 &amp;= b^2 \cdot b^2 \<br />
b^8 &amp;= b^4 \cdot b^4<br />
\end{align*}<br />
$$</p>
<p>这个方法在指数是2的倍数的时候可以很好地工作. 一般来说, 如果我们使用递归规则, 我们也可以在计算指数上利用连续平方.</p>
<p>$$<br />
\begin{equation*}<br />
b^n = \begin{cases} (b^{\frac{1}{2} n})^2 &amp; \text{if $n$ is even} \<br />
b \cdot b^{n-1}     &amp; \text{if $n$ is odd}<br />
\end{cases}<br />
\end{equation*}<br />
$$</p>
<p>我们也可以以一个递归函数来表示这个方法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">fast_exp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">square</span><span class="p">(</span><span class="n">fast_exp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span> <span class="o">*</span> <span class="n">fast_exp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fast_exp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="mi">1267650600228229401496703205376</span>
</code></pre></td></tr></table>
</div>
</div><p>演化为<code>fast_exp</code>的过程其空间以及步数都以n的对数的规模来增长. 为了看到这一点, 观察用<code>fast_exp</code>计算$b^{2n}$只需要比$b^n$多计算一个乘法. 因此, 我们可以计算的指数的大小被允许是每个新的乘法的翻倍(大约). 由此, 乘法的次数需要一个指数n, 这乘法的次数的增长跟以2为底数的n的对数增长得一样快. 这过程增长为$\Theta(\log n)$. $\Theta(\log n)$增长与$\Theta(n)$增长的不同随着n的增大而变得明显. 例如, <code>fast_exp</code>对于n为1000的情况只需要14次乘法而不是1000次.</p>
<h4 id="285-增长类别">2.8.5 增长类别</h4>
<p>增长顺序的设计旨在计算简化计算过程的分析以及比较. 很多不同的计算过程都可以具有相同的增长顺序, 这表示它们规模增长的方式是相似的. 计算机科学家必须知道并识别常见的增长顺序以及鉴别具有相同顺序的过程.</p>
<p><strong>常量</strong>. 常量并不会影响过程的增长顺序. 因此, 例如, $\Theta(n)$以及$\Theta(500 \cdot n)$具有相同的增长顺序. 这个属性遵循<code>theta</code>符号的定义, 也就是允许我们去为上下限选择任意常量$k_1$以及$k_2$(例如$\frac{1}{500}$). 为了简单起见, 常量在增长序列中总是被省去的.</p>
<p><strong>对数</strong>. 对数的基数并不会影响增长顺序的过程, 例如, $\log_2 n$以及$\log_{10} n具有相同的增长顺序. 修改对数的基数等于乘以常数因子.</p>
<p><strong>嵌套</strong>. 当一个内部计算过程在外部计算过程的每一步中都重复(执行), 那么整个过程的增长的顺序就是内部和外部过程的中的步骤数的乘积.</p>
<p>例如, 下面的函数<code>overlap</code>计算共同存在于列表a以及列表b中的元素的个数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">overlap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">count</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">overlap</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="mi">3</span>
</code></pre></td></tr></table>
</div>
</div><p><code>in</code>操作符对于列表而言需要$\Theta(n)$的运行时间, 这里的n是列表b的长度. 它出现了$\Theta(m)$次, 这里的m指的是列表a的长度. 表达式<code>item in b</code>是一个内部的过程, 而表达式<code>for item in a</code>循环是外部过程. 这个函数的总的增长顺序是$\Theta(m \cdot n)$.</p>
<p><strong>低阶项</strong>. 随着对过程输入的增长, 计算中增长最快的部分主宰着总的资源的消耗. <code>Theta</code>符号能捕捉这种直觉. 总的来说, 除了增长最快的部分, 其他部分都可以抛弃掉而不会对增长的顺序有什么影响.</p>
<p>例如, 考虑一下<code>one_more</code>函数, 它会返回列表a中有多少个元素是比a中的其中一个元素多一的情况. 也就是说, 列表<code>[3, 14, 15, 9]</code>, 元素15比14多一, 因此<code>one_more</code>会返回1.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">one_more</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">overlap</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">one_more</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="mi">1</span>
</code></pre></td></tr></table>
</div>
</div><p>这个计算有两个部分: 列表解析以及调用<code>overlap</code>. 对于长度为n的列表a, 列表解析式需要$\Theta(n)$个步骤, 而调用<code>overlap</code>需要$\Theta(n^2)$个步骤. 总的步数是$\Theta(n + n^2)$, 但这不是表达增长顺序的最简单的方法.</p>
<p>$\Theta(n^2 + k \cdot n)$以及$\Theta(n^2)$对于任意的常量k都是相等的, 因为$n^2$项对任何k最终都会支配总量. 事实上建立这种等价性边界必须要保持n大于某个最小值m. 为了简单起见, 低阶项总是在增长顺序中舍去, 因此我们永远不会在一个theta表达式中看到总和.</p>
<p><strong>常见类别</strong>. 给定这种等价性, 出现了一小组常见类别的集合用于描述大多数常见的计算过程. 最常见的已经按照最慢的增长到最快的增长顺序列举在下面, 以及随着输入的增长而增长的描述. 下面是每个类别的例子.</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Theta Notation</th>
<th>Growth Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Constant</td>
<td>$\Theta(1)$</td>
<td>Growth is independent of the input</td>
<td>abs</td>
</tr>
<tr>
<td>Logarithmic</td>
<td>$\Theta(\log{n})$</td>
<td>Multiplying input increments resources</td>
<td>fast_exp</td>
</tr>
<tr>
<td>Linear</td>
<td>$\Theta(n)$</td>
<td>Incrementing input increments resources</td>
<td>exp</td>
</tr>
<tr>
<td>Quadratic</td>
<td>$\Theta(n^2)$</td>
<td>Incrementing input adds n resources</td>
<td>one_more</td>
</tr>
<tr>
<td>Exponential</td>
<td>$\Theta(b^n)$</td>
<td>Incrementing input multiplies resources</td>
<td>fib</td>
</tr>
</tbody>
</table>
<p>也存在其他的类别, 例如<code>count_factors</code>的增长$\Theta(\sqrt{n})$. 这些类别也是特别常见的.</p>
<p>指数增长描述了许多不同的增长顺序, 因为修改基数b会影响增长的顺序. 例如, 我们的树递归斐波那契计算函数<code>fib</code>的步数随着它的输入n以指数级增长. 特别地, 可以证明第n个斐波那契数是最接近下面等式的整数:</p>
<p>$$<br />
\begin{equation*}<br />
\frac{\phi^{n-2}}{\sqrt{5}}<br />
\end{equation*}<br />
$$</p>
<p>这里的$\phi$是黄金分割比率:</p>
<p>$$<br />
\begin{equation*}<br />
\phi = \frac{1 + \sqrt{5}}{2} \approx 1.6180<br />
\end{equation*}<br />
$$</p>
<p>我们还指出所需的步骤数与结果成比例, 因此树递归过程需要$\Theta(\phi^n)$个步骤, 这是随着n指增长的函数.</p>
<h3 id="29-递归对象">2.9 递归对象</h3>
<p>对象可以具有其他对象来作为属性值, 当某个类的对象具有一个属性值, 这个属性值也属于相同的类, 那么这就是一个递归对象.</p>
<h4 id="291-链接列表类">2.9.1 链接列表类</h4>
<p>链接列表, 在之前的章节里面介绍过, 由一个元素以及列表其余的部分组成. 列表的其余部分本身也是一个链接列表 &ndash; 一个递归定义. 空列表是链表中的一个特殊的情况, 它没有第一个元素以及其他元素. 一个链表是一个序列: 它具有有限的长度以及支持通过索引来选择元素.</p>
<p>现在我们可以实现一个具有相同行为的类. 在这个版本中, 我们会使用特殊方法名来定义它的行为从而允许我们的类能跟內建的<code>len</code>函数以及在Python中的元素选择操作符(方括号或者<code>operator.getitem</code>)工作. 这些內建函数调用类中的特殊方法名: 长度是通过<code>__len__</code>来计算的, 同时, 元素选择是通过<code>__getitem__</code>来计算的. 空链表是通过一个空的元组来表示, 也就是具有的长度是0同时没有元素.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Link</span><span class="p">:</span>
        <span class="s2">&#34;&#34;&#34;A linked list with a first element and the rest.&#34;&#34;&#34;</span>
        <span class="n">empty</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="n">empty</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">rest</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">Link</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rest</span> <span class="o">=</span> <span class="n">rest</span>
        <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Link</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">4</span>
</code></pre></td></tr></table>
</div>
</div><p><code>__len__</code>以及<code>__getitem__</code>的定义事实上是递归的. 当以用户定义的对象作为参数应用到內建的Python函数<code>len</code>上时会调用一个叫做<code>__len__</code>的方法. 同样的还有元素选择操作符会调用叫做<code>__getitem__</code>的方法. 因此, 这两种方法的主体内会间接地调用它们自己. 对于<code>__len__</code>, 当<code>self.rest</code>等于一个空的元组时就到达基本情况了, 也就是<code>Link.empty</code>具有的长度为0.</p>
<p>內建的<code>isinstance</code>函数返回第一个参数是否是第二个参数的类型或者继承自第二个参数的判断结果. 如果<code>rest</code>是一个<code>Link</code>的实例或者是一个<code>Link</code>子类的实例, 那么<code>isinstance(rest, Link)</code>的结果就是真值.</p>
<p>我们的实现已经完成了, 但是目前却很难检查一个实例是不是<code>Link</code>类. 为了有助于调试, 我们也可以定义一个函数来将<code>Link</code>转换成一个字符串表达式.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">link_expression</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a string that would evaluate to s.&#34;&#34;&#34;</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">rest</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">rest</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rest</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span> <span class="o">+</span> <span class="n">link_expression</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;Link({0}{1})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">link_expression</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="s1">&#39;Link(3, Link(4, Link(5)))&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>这种展现<code>Link</code>列表的方式是如此的方便以至于我们想要在任何时候都使用它来展现<code>Link</code>的实例. 我们可以通过设定<code>link_expression</code>函数作为特殊的类属性<code>__repr__</code>的的值来确保这个行为. Python通过调用实例的<code>__repr__</code>方法来展现用户定义类的实例.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">Link</span><span class="o">.</span><span class="fm">__repr__</span> <span class="o">=</span> <span class="n">link_expression</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span>
<span class="n">Link</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
</code></pre></td></tr></table>
</div>
</div><p><code>Link</code>类具有闭合属性. 就像一个列表中的元素本身可以是一个列表, 一个<code>Link</code>可以包含一个<code>Link</code>作为它的第一个元素.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">s_first</span> <span class="o">=</span> <span class="n">Link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s_first</span>
<span class="n">Link</span><span class="p">(</span><span class="n">Link</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">5</span><span class="p">))),</span> <span class="n">Link</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p><code>s_first</code>链接列表室友两个元素, 而它的第一个元素是一个包含三个元素的链接列表.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_first</span><span class="p">)</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_first</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s_first</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="mi">5</span>
</code></pre></td></tr></table>
</div>
</div><p>递归函数尤其适合用来操作链表. 例如, 递归函数<code>extend_link</code>函数构建了一个包含一个<code>Link</code>类的实例s紧跟着另一个<code>Link</code>类的实例t的元素的链表. 将这个函数作为<code>__add__</code>方法安装到<code>Link</code>类来模拟内部列表的添加行为.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">extend_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Link</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">extend_link</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">extend_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="n">Link</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">5</span><span class="p">))))))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Link</span><span class="o">.</span><span class="fm">__add__</span> <span class="o">=</span> <span class="n">extend_link</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="n">s</span>
<span class="n">Link</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">5</span><span class="p">))))))</span>
</code></pre></td></tr></table>
</div>
</div><p>除了列表表达式, 可以使用两个高阶函数来从一个链表生成另一个链表: <code>map_link</code>以及<code>filter_link</code>函数. 下面定义的<code>map_link</code>函数应用一个函数<code>f</code>到链表s的每个元素上同时构造一个链表来包含结果.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">map_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Link</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">),</span> <span class="n">map_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">map_link</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="n">Link</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">25</span><span class="p">)))</span>
</code></pre></td></tr></table>
</div>
</div><p><code>filter_link</code>函数返回一个包含所有链表s中经f函数处理并返回真值的元素的链表. <code>map_link</code>以及<code>filter_link</code>的组合可以表达与列表表达式相同的逻辑.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">filter_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filtered</span> <span class="o">=</span> <span class="n">filter_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">Link</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">filtered</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">filtered</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">odd</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">map_link</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">filter_link</span><span class="p">(</span><span class="n">odd</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
<span class="n">Link</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">25</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="k">if</span> <span class="n">odd</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p><code>join_link</code>函数递归构造一个字符串, 它包含链表元素并以某些<code>separator</code>字符串来分隔开. 结果比<code>link_expression</code>的输出更加紧凑.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">join_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">separator</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&#34;&#34;</span>
        <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">rest</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">)</span> <span class="o">+</span> <span class="n">separator</span> <span class="o">+</span> <span class="n">join_link</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">,</span> <span class="n">separator</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">join_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">&#34;, &#34;</span><span class="p">)</span>
<span class="s1">&#39;3, 4, 5&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>递归构造</strong>. 当需要递增地构造序列的时候链表尤其有用. 这在递归计算中经常会出现这种情况.</p>
<p>第一章的<code>count_partitions</code>函数通过树递归过程统计用最大递增到m的整数来划分整数n的方法的总数. 使用序列, 我们也可以用类似的过程来显式地枚举这些区间.</p>
<p>我们按照与计数时相同的逻辑来递归分析这些问题: 使用最大递增为m的整数划分整数n涉及下面两者之一:</p>
<ol>
<li>区间<code>n-m</code>使用最大递增到m的整数, 或者</li>
<li>区间<code>n</code>使用最大递增到m-1的整数</li>
</ol>
<p>对于最基本的情况, 我们发现0具有空的划分, 当划分一个负整数或者使用小于1的部分是不可能的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a linked list of partitions of n using parts of up to m.
</span><span class="s2">        Each partition is represented as a linked list.
</span><span class="s2">        &#34;&#34;&#34;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Link</span><span class="p">(</span><span class="n">Link</span><span class="o">.</span><span class="n">empty</span><span class="p">)</span> <span class="c1"># A list containing the empty partition</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">using_m</span> <span class="o">=</span> <span class="n">partitions</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">with_m</span> <span class="o">=</span> <span class="n">map_link</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">Link</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="n">using_m</span><span class="p">)</span>
            <span class="n">without_m</span> <span class="o">=</span> <span class="n">partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">with_m</span> <span class="o">+</span> <span class="n">without_m</span>
</code></pre></td></tr></table>
</div>
</div><p>在递归的情况下, 我们构造了两个分区子列表. 第一个使用m, 同时我们添加m到来自于<code>with_m</code>的结果<code>using_m</code>的每一个元素中.</p>
<p><code>partitions</code>的结果是高度嵌套的: 链表的链表. 通过用恰当的分割符来使用<code>join_link</code>, 我们可以以人类可读的方式来显示分区.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">print_partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">lists</span> <span class="o">=</span> <span class="n">partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">strings</span> <span class="o">=</span> <span class="n">map_link</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">join_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">&#34; + &#34;</span><span class="p">),</span> <span class="n">lists</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">join_link</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="s2">&#34;</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">print_partitions</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span>
<span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span>
<span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
<span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="292-树类">2.9.2 树类</h4>
<p>树也可以用用户定义的类来表示, 而不是嵌套內建的序列类型的实例. 一棵树可以是任何的数据类型, 它具有一个同样也是树的属性来作为的分支.</p>
<p><strong>内部值</strong>. 之前, 我们以这样的方式来定义树, 那就是所有值都出现在树的叶子节点中. 这也是通常用来定义每个子树的根节点具有内部值的树的常见方法. 一个内部值在树内被称为<code>entry</code>. 下面的<code>Tree</code>类展示了这样的一棵树, 其中每棵树具有一个序列分支, 这个分支同样也是树.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Tree</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">branches</span><span class="o">=</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span>
            <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">branches</span> <span class="o">=</span> <span class="n">branches</span>
        <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;Tree({0}, {1})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;Tree({0})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">))</span>
        <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span>
</code></pre></td></tr></table>
</div>
</div><p>树类可以进行表示, 例如, 在表达式树中表达<code>fib</code>这个计算斐波那契数的函数递归实现的计算值, 下面的<code>fib_tree(n)</code>函数返回一个<code>Tree</code>, 这个值具有第n个斐波那契数作为它的<code>entry</code>属性的值以及在其分支内保持一个对先前所有计算的斐波那契数的跟踪.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">fib_tree</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">fib_tree</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">fib_tree</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">entry</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">entry</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fib_tree</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Tree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">Tree</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">Tree</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Tree</span><span class="p">(</span><span class="mi">1</span><span class="p">))),</span> <span class="n">Tree</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">Tree</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Tree</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">Tree</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Tree</span><span class="p">(</span><span class="mi">1</span><span class="p">)))))))</span>
</code></pre></td></tr></table>
</div>
</div><p>以这种方式表示的树也是用递归函数来处理的. 例如, 我们可以合计树的条目. 最基本的情况, 我们会返回一个空的没有条目的分支.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">sum_entries</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Sum the entries of a Tree instance, which may be None.&#34;&#34;&#34;</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">entry</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="n">sum_entries</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">branches</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sum_entries</span><span class="p">(</span><span class="n">fib_tree</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="mi">10</span>
</code></pre></td></tr></table>
</div>
</div><p>我们也可以应用<code>memo</code>来构造一个斐波那契树, 这个树中重复的子树只会通过记忆化版本的<code>fib_tree</code>创建一遍, 但是会被不同的更大的树多次使用.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">fib_tree</span> <span class="o">=</span> <span class="n">memo</span><span class="p">(</span><span class="n">fib_tree</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">big_fib_tree</span> <span class="o">=</span> <span class="n">fib_tree</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">big_fib_tree</span><span class="o">.</span><span class="n">entry</span>
<span class="mi">5702887</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">big_fib_tree</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">big_fib_tree</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sum_entries</span> <span class="o">=</span> <span class="n">memo</span><span class="p">(</span><span class="n">sum_entries</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sum_entries</span><span class="p">(</span><span class="n">big_fib_tree</span><span class="p">)</span>
<span class="mi">142587180</span>
</code></pre></td></tr></table>
</div>
</div><p>在这些情况下, 通过记忆保存的计算时间和存储器的量是相当大的. 不是创建18,454,929个<code>Tree</code>类型的实例, 我们现在只需要创建35个.</p>
<h4 id="293-集合">2.9.3 集合</h4>
<p>除了列表, 元组以及字典, Python还有第四种內建容器类型叫做<code>set</code>(集合). 集合字面量遵循的数学符号是用大括号包裹元素. 重复的元素将会在构造时被移除. 集合是一个无序集, 因此打印出来的顺序可能与集合字面量中设置的顺序不同.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span>
<span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Python集合支持各种操作, 包括成员测试, 长度计算, 以及取交集和并集这样的标准集合操作.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="mi">3</span> <span class="ow">in</span> <span class="n">s</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">union</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">})</span>
<span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">intersection</span><span class="p">({</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>
<span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>除了并集以及交集, Python集合还支持几个其他的方法. 断言<code>isdisjoint</code>, <code>issubset</code>以及<code>issuperset</code>提供集合比较(能力). 集合是可变的, 可以通过<code>add</code>, <code>remove</code>以及<code>pop</code>一次修改一个元素. 其余的方法提供多元素改动, 例如<code>clear</code>以及<code>update</code>. 在课程讲述的这个点上, Python的<a href="http://docs.python.org/py3k/library/stdtypes.html#set">集合文档</a>应该足够用来理解并填充细节了.</p>
<p><strong>实现集合</strong>. 抽象地, 一个集合是一个不同对象的集, 它支持成员测试, 并集, 交集, 以及附加. 附加一个元素同时集合会返回一个新的集合, 这个新集合包含所有的原来集合的元素以及新的元素, 前提是这些新的元素不同于原来集合的元素的话. 并集和交集返回一个集合包含的元素是分别出现在任一集合或者两个集合都出现的元素. 与任何数据抽象一样, 我们可以自由地在任意集合的表示之上实现任何函数来提供这个集合的行为.</p>
<p>在这一节剩下的内容当中, 我们考虑三种不同的方法来实现一个集合的不同的表现形式. 我们会通过分析集合操作增长的顺序来描述这些不同表示的效率. 我们会使用到来自于本章前面部分的<code>Link</code>以及<code>Tree</code>类型, 这些类型允许实现简单而且优雅的递归解决方案用于初级的集合操作.</p>
<p><strong>集合作为无序序列</strong>. 一种表示集合的方式是作为一个没有元素出现多于一次的序列. 空集合是通过空序列表示. 成员测试则是以递归的方式遍历列表.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">set_contains</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return True if and only if set a constains v.&#34;&#34;&#34;</span>
        <span class="k">if</span> <span class="n">empty</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p>这个<code>set_contains</code>的实现平均需要$\Theta(n)$的时间来测试成员是否包含元素, 这里的n是指集合s的大小. 对包含的成员使用这个线性时间的函数, 我们可以连接一个元素到集合中, 这个操作也是线性的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">adjoin_set</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a set containing all elements of s and element v.&#34;&#34;&#34;</span>
        <span class="k">if</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Link</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">adjoin_set</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span>
<span class="n">Link</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">5</span><span class="p">))))</span>
</code></pre></td></tr></table>
</div>
</div><p>在设计表示时, 一个我们需要考虑到的问题是效率. 对两个集合<code>set1</code>以及<code>set2</code>进行取交集也需要用到成员测试, 但是这一次, 每一个在<code>set1</code>中的元素必须在<code>set2</code>中进行成员测试, 这导致指令的增长为步数的二次方, $\Theta(n^2)$, n是两个集合的大小.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">intersect_set</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a set containing all elements common to set1 and set2.&#34;&#34;&#34;</span>
        <span class="k">return</span> <span class="n">keep_if_link</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">set2</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">intersect_set</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">apply_to_all_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">square</span><span class="p">))</span>
<span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>当计算两个集合的并集, 我们必须要小心不要去包含任何元素两次. <code>union_set</code>函数也需要线性次数的隶属测试, 创建一个过程也包含$\Theta(n^2)$个步骤.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">union_set</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Return a set containing all elements either in set1 or set2.&#34;&#34;&#34;</span>
        <span class="n">set1_not_set2</span> <span class="o">=</span> <span class="n">keep_if_link</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="ow">not</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">set2</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">extend_link</span><span class="p">(</span><span class="n">set1_not_set2</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">union_set</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="n">Link</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">5</span><span class="p">))))</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>集合作为有序序列</strong>. 一个提高我们集合操作的方式是修改表示以便让集合元素以递增的顺序列出. 要做到这个, 我们需要一些方法来比较两个对象以便于让我们可以说出那个更大. 在Python, 很多不同类型的对象可以用<code>&lt;</code>以及<code>&gt;</code>来进行比较, 但是在这个例子中我们会集中在数字上. 我们会通过递增的方式来列出它的元素来通过一个数字表示一个集合.</p>
<p>按顺序的一个好处出现在<code>set_contains</code>里面: 在检查一个对象是否出现上, 我们不用再去扫描整个集合. 如果我们拿到一个集合的元素, 它大于我们需要的元素, 那么我们就知道元素不在这个集合中:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">set_contains</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">empty</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">first</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span> <span class="o">=</span> <span class="n">Link</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p>这样的做法节省了多少步骤呢? 在最糟糕的情况下, 我们查找的项可能是在集合中最大的那项, 因此步骤数跟无序表示方式用的步骤数一样. 另一方面, 如果我们查找的项有很多不同的大小我们可以预期有时我们能够在列表的开始之初就停止搜索, 而其他时间我们还是需要检查列表的大部分. 平均来说, 我们可以预期需要检查结合中的半数. 因此, 平均需要的步数会近乎$\frac{n}{2}$. 这依然是$\Theta(n)$级增长, 但是它在实践中比以前的实现节省了我们一些时间.</p>
<p>我们可以通过重新实现<code>intersect_set</code>来取得更好的速度上的提升. 在无序表示中, 这个操作需要$\Theta(n^2)$个步骤, 因为我们的实现是为<code>set1</code>的每个元素来对<code>set2</code>进行完全扫描. 但是在有序表示中, 我们可以用一个更加聪明的办法. 我们同时迭代两个集合, 跟踪在<code>set1</code>中的元素<code>e1</code>以及<code>set2</code>中的元素<code>e2</code>. 当<code>e1</code>和<code>e2</code>相等时, 我们将这个元素囊括在交集中.</p>
<p>然而假设, <code>e1</code>比<code>e2</code>小. 因为<code>e2</code>比<code>set2</code>中的剩下的元素都要小, 我们可以立马得出结论<code>e1</code>不可能出现在<code>set2</code>中剩余的任何元素中, 因此, 它就不会在交集中出现. 由此, 我们就不需要再考虑<code>e1</code>; 我们丢弃它并开始处理下一个<code>set1</code>的元素. 也可以用相似的逻辑来处理<code>set2</code>当<code>e2</code> &lt; <code>e1</code>时. 这里是函数实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">intersect_set</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">empty</span><span class="p">(</span><span class="n">set1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">empty</span><span class="p">(</span><span class="n">set2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">set1</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">set2</span><span class="o">.</span><span class="n">first</span>
            <span class="k">if</span> <span class="n">e1</span> <span class="o">==</span> <span class="n">e2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Link</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">intersect_set</span><span class="p">(</span><span class="n">set1</span><span class="o">.</span><span class="n">rest</span><span class="p">,</span> <span class="n">set2</span><span class="o">.</span><span class="n">rest</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">e1</span> <span class="o">&lt;</span> <span class="n">e2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">intersect_set</span><span class="p">(</span><span class="n">set1</span><span class="o">.</span><span class="n">rest</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">e2</span> <span class="o">&lt;</span> <span class="n">e1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">intersect_set</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="o">.</span><span class="n">rest</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">intersect_set</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">)</span>
<span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>去预估这个过程所需的步骤, 可以观察到在每一步中我们至少缩小集合一个元素的大小. 因此, 需要的步数最多就是<code>set1</code>以及<code>set2</code>加起来的总和, 而不是像无序表示那样结果为两个集合大小的乘积. 这是$\Theta(n)$的增长速度而不是$\Theta(n^2)$的增长速度, 甚至对中等大小的集合而言, 这也是一个可观的速度提升. 例如, 取两个大小为100的集合的交集会需要200步, 而不是无序表示的10,000步.</p>
<p>以有序序列表示的集合的连接和联合也可以用线性时间计算出来. 这些实现就留作练习用.</p>
<p><strong>以搜索树表示的集合</strong>. 我们比有序表示做得更好, 通过排列集合元素形成一个只具有两个分支的树中. 树的根节点<code>entry</code>持有一个集合的元素. 这个条目中左边的分支内包含所有小于根节点的元素. 右边的分支包含所有大于在根节点的元素. 下面的图像展示了一些树用来表示结合<code>{1, 3, 5, 7, 9, 11}</code>. 相同的集合可能会通过树以多种不同的方式来表示. 在所有的二叉搜索树中, 所有在左边的元素必须小于根节点的条目, 而所有在右边的子树必须比根节点条目大.</p>
<p><img src="http://composingprograms.com/img/set_trees.png" alt="集合二叉树表示" /></p>
<p>树表示的好处有这些: 假设我们想要检查一个值v是否包含在集合中, 我们通过比较v与进入点<code>entry</code>开始. 如果v是比它小的话, 我们就知道我们只需要搜索左边的子树; 如果v是比它大的话, 我们只需要搜索右边的子树. 现在, 如果这个树是&quot;均衡的&rdquo;, 每一个这些子树会大约是原始尺寸的一半. 那么, 在一个步骤中, 我们就已经将搜索大小为n的树的问题减少为搜索大小为$\frac{n}{2}$的问题. 因此树的大小在每一步都缩减一半, 我们应该可以遇见需要去搜索树的步骤数增长为$\Theta(\log n)$. 对于大型的集合, 这将会比前面的表示有更加显著的加速. 这个<code>set_contains</code>函数采用树结构集的排序结构.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">set_contains</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">entry</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">entry</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">entry</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>链接一个项到集合中的实现也是类似的, 同时它需要的步数也是$\Theta(\log n)$. 去链接一个值v, 我们将v与entry进行比较来判断v是否应该添加到左边或者右边的分支上, 以及链接v到恰当的分支后, 我们将这些新的构造分支跟原始的entry项以及其他分支拼凑在一起. 如果v等于入口entry项, 我们就只是返回节点就可以了. 如果我们被要求链接v到一个空的树, 我们就构造一个具有v并以其作为entry入口的左右分支为空的Tree. 这里是它的函数实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">adjoin_set</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">entry</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">entry</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">entry</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">adjoin_set</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">entry</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">entry</span><span class="p">,</span> <span class="n">adjoin_set</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">adjoin_set</span><span class="p">(</span><span class="n">adjoin_set</span><span class="p">(</span><span class="n">adjoin_set</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Tree</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Tree</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Tree</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>我们声称搜索这些树可以以对数的步骤数来执行是基于树是&quot;均衡的&quot;这一个假设, 即每棵树的左以及右子树具有大约相同的数量的元素, 因此每棵子树包含有它的父级的一半的元素. 但是现在我们可以确定我们构造的树会是均衡的吗? 即使我们由一个均衡的子树开始, 通过<code>adjoin_set</code>添加元素后也可能会产出一个不均衡的结果. 因为新链接的元素的位置取决于元素是如何与已经存在集合中的项目进行比较, 我们可以预期如果我们添加元素是&quot;随机的&rdquo;, 那么平均来说, 树会趋于均衡.</p>
<p>但并不能够保证一定是这样的. 例如, 如果我们开始于一个空的集合, 然后按顺序链接1到7到集合中, 我们最终会得到一个高度不均衡的树, 它的所有左子树都是空的, 因此它相比于简单的顺序列表没有任何优势, 一个解决办法是去定义一个操作来转换一个任意的树为具有相同的元素的一个平衡树. 我们可以在每几个<code>adjoin_set</code>操作之后执行这个转换来保持集合的平衡.</p>
<p>交集和并集操作可以以线性时间在树结构的集合上执行, 通过转换它们为有序列表然后转换回来. 细节实现就留作练习.</p>
<p><strong>Python集合实现</strong>. <code>set</code>类型是內建在Python中且没有在内部使用任何这些表示. 相反地, Python使用一个表示, 查找以及链接操作只需要恒定时间执行, 其实现基于一个被称为_哈希_的技术, 而这是另外的一个课程的主题. 內建Python集合不能包含可变数据类型, 例如, 列表, 字典, 或者其他集合. 为了允许集合嵌套, Python也包含了一个內建的不可变<code>frozenset</code>类, 它共享<code>set</code>类型的方法, 除了可变方法以及操作.</p>
    </article>
    
    <script>
  'use strict';
  
  function wrap(el, wrapper) {
    el.parentNode.insertBefore(wrapper, el);
    wrapper.appendChild(el);
  }

  (function () {
    var singleContentsElem = document.querySelector('.single__contents');
    singleContentsElem ? 
    singleContentsElem.querySelectorAll('pre > code').forEach(function(elem) {
      var dataLang = elem.getAttribute('data-lang');
      var dataLangWrapper = document.createElement('div');
      var code = null;
      var codeTitle = null;

      if (dataLang && dataLang.includes(':')) {
        code = dataLang.split(':')[0];
        codeTitle = dataLang.split(':')[1];

        dataLangWrapper.className = 'language-' + code;
        dataLangWrapper.setAttribute('data-lang', codeTitle);

        elem.className = 'language-' + code;
        elem.setAttribute('data-lang', codeTitle);
        elem.setAttribute('id', codeTitle);
      } else if (!dataLang) {
        dataLangWrapper.setAttribute('data-lang', 'Code');
        dataLangWrapper.className = 'language-code';
      }

      if (!dataLang || codeTitle) {
        wrap(elem.parentNode, dataLangWrapper);
      }

    }) : null;
  })();

  var langCodeElem = document.querySelectorAll('.language-code');
  langCodeElem ? langCodeElem.forEach(function (elem) {
    var newElem = document.createElement('span');
    newElem.className = 'copy-to-clipboard';
    newElem.setAttribute('title', 'Copy to clipboard');
    elem.append(newElem);
  }) : null;
  
</script>
    
<div class="donation">
  <div class="donation__message">
    Share on
  </div>
  <div class="donation__icons">
    
    
    
      
        <a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fjmwill.github.io%2fblog%2f2017%2f06%2f11%2f%25E7%25A8%258B%25E5%25BA%258F%25E6%259E%2584%25E6%2588%2590-%25E7%25AC%25AC%25E4%25BA%258C%25E7%25AB%25A0%2f" title="Facebook" aria-label="Facebook Share Button" class="donation__item" target="_blank" rel="noreferrer" data-type="share">
          <svg data-name="facebook" enable-background="new 0 0 24 24" viewBox="0 0 24 24" width="35" height="35" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="m15.997 3.985h2.191v-3.816c-.378-.052-1.678-.169-3.192-.169-3.159 0-5.323 1.987-5.323 5.639v3.361h-3.486v4.266h3.486v10.734h4.274v-10.733h3.345l.531-4.266h-3.877v-2.939c.001-1.233.333-2.077 2.051-2.077z"/></svg>
        </a>
      
    
      
        <a href="https://twitter.com/intent/tweet?text=%e7%a8%8b%e5%ba%8f%e6%9e%84%e6%88%90-%e7%ac%ac%e4%ba%8c%e7%ab%a0&url=https%3a%2f%2fjmwill.github.io%2fblog%2f2017%2f06%2f11%2f%25E7%25A8%258B%25E5%25BA%258F%25E6%259E%2584%25E6%2588%2590-%25E7%25AC%25AC%25E4%25BA%258C%25E7%25AB%25A0%2f&hashtags=%e8%af%91%e6%96%87%2cDesign%20Programs&via=" title="Twitter" aria-label="Twitter Share Button" class="donation__item" target="_blank" rel="noreferrer" data-type="share">
          <svg data-name="twitter" enable-background="new 0 0 24 24" viewBox="0 0 24 24" width="35" height="35" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="m21.534 7.113c.976-.693 1.797-1.558 2.466-2.554v-.001c-.893.391-1.843.651-2.835.777 1.02-.609 1.799-1.566 2.165-2.719-.951.567-2.001.967-3.12 1.191-.903-.962-2.19-1.557-3.594-1.557-2.724 0-4.917 2.211-4.917 4.921 0 .39.033.765.114 1.122-4.09-.2-7.71-2.16-10.142-5.147-.424.737-.674 1.58-.674 2.487 0 1.704.877 3.214 2.186 4.089-.791-.015-1.566-.245-2.223-.606v.054c0 2.391 1.705 4.377 3.942 4.835-.401.11-.837.162-1.29.162-.315 0-.633-.018-.931-.084.637 1.948 2.447 3.381 4.597 3.428-1.674 1.309-3.8 2.098-6.101 2.098-.403 0-.79-.018-1.177-.067 2.18 1.405 4.762 2.208 7.548 2.208 8.683 0 14.342-7.244 13.986-14.637z"/></svg>
        </a>
      
    
  </div>
</div>

    
    
<div class="whoami__gutter"></div>
<hr class="hr-slash whoami-hr"/>
<section class="whoami">
  <div class="whoami__image-wrapper">
    
    
      
        <img data-src="/blog/images/whoami/avatar.jpg" src="data:image/svg+xml,%0A%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='none' d='M0 0h24v24H0V0z'/%3E%3Cpath fill='%23aaa' d='M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-1 16H6c-.55 0-1-.45-1-1V6c0-.55.45-1 1-1h12c.55 0 1 .45 1 1v12c0 .55-.45 1-1 1zm-4.44-6.19l-2.35 3.02-1.56-1.88c-.2-.25-.58-.24-.78.01l-1.74 2.23c-.26.33-.02.81.39.81h8.98c.41 0 .65-.47.4-.8l-2.55-3.39c-.19-.26-.59-.26-.79 0z'/%3E%3C/svg%3E" alt="Will" class="lazyload whoami__image"/>
      
    
  </div>
  <div class="whoami__contents">
    <div class="whoami__written-by">
      WRITTEN BY
    </div>
    <div class="whoami__title">
      
        Will
      
    </div>
    <div class="whoami__desc">
      
        Web Developer
      
    </div>
    <div class="whoami__social">
      
      
      
      
      
      
      
      
      <a href="mailto:willsurpriseyou@foxmail.com" title="email" aria-label="email">
        <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-.4 4.25l-7.07 4.42c-.32.2-.74.2-1.06 0L4.4 8.25c-.25-.16-.4-.43-.4-.72 0-.67.73-1.07 1.3-.72L12 11l6.7-4.19c.57-.35 1.3.05 1.3.72 0 .29-.15.56-.4.72z"/></svg>
      </a>
      
      
      
      <a href="http://example.org/" title="facebook" aria-label="facebook">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewBox="0 0 24 24" version="1.1">
<g id="surface2747">
<path fill="currentColor" d="M 11.664062 2.003906 C 6.621094 2.171875 2.375 6.25 2.023438 11.289062 C 1.65625 16.617188 5.46875 21.121094 10.507812 21.878906 L 10.507812 14.648438 L 8.890625 14.648438 C 8.164062 14.648438 7.578125 14.0625 7.578125 13.335938 C 7.578125 12.609375 8.164062 12.023438 8.890625 12.023438 L 10.503906 12.023438 L 10.503906 10.273438 C 10.503906 7.378906 11.914062 6.105469 14.324219 6.105469 C 14.679688 6.105469 14.984375 6.113281 15.242188 6.128906 C 15.878906 6.15625 16.371094 6.6875 16.371094 7.324219 C 16.371094 7.988281 15.835938 8.523438 15.171875 8.523438 L 14.730469 8.523438 C 13.710938 8.523438 13.351562 9.492188 13.351562 10.585938 L 13.351562 12.023438 L 15.222656 12.023438 C 15.8125 12.023438 16.265625 12.550781 16.175781 13.132812 L 16.066406 13.835938 C 15.992188 14.304688 15.589844 14.652344 15.113281 14.652344 L 13.351562 14.652344 L 13.351562 21.898438 C 18.234375 21.234375 22 17.0625 22 12 C 22 6.367188 17.339844 1.820312 11.664062 2.003906 Z M 11.664062 2.003906 "/>
</g>
</svg>

      </a>
      
      
      
      
      
      <a href="https://github.com/jmwill" title="github" aria-label="github">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewBox="0 0 24 24" version="1.1">
<g id="surface3680">
<path fill="currentColor" d="M 10.898438 2.101562 C 6.300781 2.601562 2.601562 6.300781 2.101562 10.800781 C 1.601562 15.5 4.300781 19.699219 8.398438 21.300781 C 8.699219 21.398438 9 21.199219 9 20.800781 L 9 19.199219 C 9 19.199219 8.601562 19.300781 8.101562 19.300781 C 6.699219 19.300781 6.101562 18.101562 6 17.398438 C 5.898438 17 5.699219 16.699219 5.398438 16.398438 C 5.101562 16.300781 5 16.300781 5 16.199219 C 5 16 5.300781 16 5.398438 16 C 6 16 6.5 16.699219 6.699219 17 C 7.199219 17.800781 7.800781 18 8.101562 18 C 8.5 18 8.800781 17.898438 9 17.800781 C 9.101562 17.101562 9.398438 16.398438 10 16 C 7.699219 15.5 6 14.199219 6 12 C 6 10.898438 6.5 9.800781 7.199219 9 C 7.101562 8.800781 7 8.300781 7 7.601562 C 7 7.199219 7 6.601562 7.300781 6 C 7.300781 6 8.699219 6 10.101562 7.300781 C 10.601562 7.101562 11.300781 7 12 7 C 12.699219 7 13.398438 7.101562 14 7.300781 C 15.300781 6 16.800781 6 16.800781 6 C 17 6.601562 17 7.199219 17 7.601562 C 17 8.398438 16.898438 8.800781 16.800781 9 C 17.5 9.800781 18 10.800781 18 12 C 18 14.199219 16.300781 15.5 14 16 C 14.601562 16.5 15 17.398438 15 18.300781 L 15 20.898438 C 15 21.199219 15.300781 21.5 15.699219 21.398438 C 19.398438 19.898438 22 16.300781 22 12.101562 C 22 6.101562 16.898438 1.398438 10.898438 2.101562 Z M 10.898438 2.101562 "/>
</g>
</svg>

      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://twitter.com/j_mwill" title="twitter" aria-label="twitter">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewBox="0 0 32 32" version="1.1">
<g id="surface676">
<path fill="currentColor" d="M 28 8.558594 C 27.117188 8.949219 26.167969 9.214844 25.171875 9.332031 C 26.1875 8.722656 26.96875 7.757812 27.335938 6.609375 C 26.386719 7.171875 25.332031 7.582031 24.210938 7.804688 C 23.3125 6.847656 22.03125 6.246094 20.617188 6.246094 C 17.898438 6.246094 15.691406 8.453125 15.691406 11.171875 C 15.691406 11.558594 15.734375 11.933594 15.820312 12.292969 C 11.726562 12.089844 8.097656 10.128906 5.671875 7.148438 C 5.246094 7.875 5.003906 8.722656 5.003906 9.625 C 5.003906 11.332031 5.871094 12.839844 7.195312 13.722656 C 6.386719 13.695312 5.628906 13.476562 4.964844 13.105469 C 4.964844 13.128906 4.964844 13.148438 4.964844 13.167969 C 4.964844 15.554688 6.660156 17.546875 8.914062 17.996094 C 8.5 18.109375 8.066406 18.171875 7.617188 18.171875 C 7.300781 18.171875 6.988281 18.140625 6.691406 18.082031 C 7.316406 20.039062 9.136719 21.460938 11.289062 21.503906 C 9.605469 22.824219 7.480469 23.609375 5.175781 23.609375 C 4.777344 23.609375 4.386719 23.585938 4 23.539062 C 6.179688 24.9375 8.765625 25.753906 11.546875 25.753906 C 20.605469 25.753906 25.558594 18.25 25.558594 11.742188 C 25.558594 11.53125 25.550781 11.316406 25.542969 11.105469 C 26.503906 10.410156 27.339844 9.542969 28 8.558594 Z M 28 8.558594 "/>
</g>
</svg>

      </a>
      
      
      
      
      
      
      
      
      
      
      
      
    </div>
  </div>
</section>
<hr class="hr-slash whoami-hr" />


    <section class="related">
    
    
    <h1 class="related__title">
      <hr class="hr-dots"/>
      <div>
        See Also
      </div>
      <hr class="hr-dots"/>
    </h1>
    <ul class="related-ul">
        
        <li>
          <a href="/blog/2017/03/09/%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90-%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="related__link">程序构成-第一章</a>
        </li>
        
        <li>
          <a href="/blog/2016/12/16/%E8%AF%91es6%E7%9A%84350%E4%B8%AA%E8%A6%81%E7%82%B9%E6%A6%82%E8%BF%B0/" class="related__link">【译】ES6的350个要点概述</a>
        </li>
        
    </ul>
    
  </section>
    <div class="grow"></div>
<nav class="pagination-single">
  
    
      <a href="https://jmwill.github.io/blog/2017/03/09/%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90-%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="pagination-single__left">
        <div class="pagination-single__icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M19 11H7.83l4.88-4.88c.39-.39.39-1.03 0-1.42-.39-.39-1.02-.39-1.41 0l-6.59 6.59c-.39.39-.39 1.02 0 1.41l6.59 6.59c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L7.83 13H19c.55 0 1-.45 1-1s-.45-1-1-1z"/></svg>
        </div>
        <div class="pagination-single__left-title">程序构成-第一章</div>      
      </a>
    
    <div class="grow"></div>
    
      <a href="https://jmwill.github.io/blog/2017/06/11/%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90-%E7%AC%AC%E4%B8%89%E7%AB%A0/" class="pagination-single__right">      
        <div class="pagination-single__right-title">程序构成-第三章</div>
        <div class="pagination-single__icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M5 13h11.17l-4.88 4.88c-.39.39-.39 1.03 0 1.42.39.39 1.02.39 1.41 0l6.59-6.59c.39-.39.39-1.02 0-1.41l-6.58-6.6c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41L16.17 11H5c-.55 0-1 .45-1 1s.45 1 1 1z"/></svg>
        </div>
      </a>
    
  
</nav>
    
  

    <div class="modal micromodal-slide" id="modal" aria-hidden="true">
  <div class="modal__overlay" tabindex="-1" data-micromodal-close>
    <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="modal-title">
      
      <div class="modal__content" id="modal-content">
        <div id="mySwipe" class="swipe">
          <div class="swipe-wrap">
          </div>
        </div>
      </div>

      <span class="modal__items">
        
        <span class="modal__header">
          <div class="modal__paging" title="Page Info" aria-label="Current Page">
          </div>
          <div class="modal__icon modal__toolbar modal__toolbar--close" title="Close" aria-label="Close Button" data-micromodal-close>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="25" height="25"><path fill="currentColor" d="M 21.734375 19.640625 L 19.636719 21.734375 C 19.253906 22.121094 18.628906 22.121094 18.242188 21.734375 L 13 16.496094 L 7.761719 21.734375 C 7.375 22.121094 6.746094 22.121094 6.363281 21.734375 L 4.265625 19.640625 C 3.878906 19.253906 3.878906 18.628906 4.265625 18.242188 L 9.503906 13 L 4.265625 7.761719 C 3.882813 7.371094 3.882813 6.742188 4.265625 6.363281 L 6.363281 4.265625 C 6.746094 3.878906 7.375 3.878906 7.761719 4.265625 L 13 9.507813 L 18.242188 4.265625 C 18.628906 3.878906 19.257813 3.878906 19.636719 4.265625 L 21.734375 6.359375 C 22.121094 6.746094 22.121094 7.375 21.738281 7.761719 L 16.496094 13 L 21.734375 18.242188 C 22.121094 18.628906 22.121094 19.253906 21.734375 19.640625 Z"/></svg>
          </div>
          <div class="modal__icon modal__toolbar modal__toolbar--full" title="Full Screen" aria-label="Full Screen Button">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="25" height="25"><path fill="currentColor" d="M 5 3 C 3.9069372 3 3 3.9069372 3 5 L 3 8 A 1.0001 1.0001 0 1 0 5 8 L 5 5 L 8 5 A 1.0001 1.0001 0 1 0 8 3 L 5 3 z M 16 3 A 1.0001 1.0001 0 1 0 16 5 L 19 5 L 19 8 A 1.0001 1.0001 0 1 0 21 8 L 21 5 C 21 3.9069372 20.093063 3 19 3 L 16 3 z M 3.984375 14.986328 A 1.0001 1.0001 0 0 0 3 16 L 3 19 C 3 20.093063 3.9069372 21 5 21 L 8 21 A 1.0001 1.0001 0 1 0 8 19 L 5 19 L 5 16 A 1.0001 1.0001 0 0 0 3.984375 14.986328 z M 19.984375 14.986328 A 1.0001 1.0001 0 0 0 19 16 L 19 19 L 16 19 A 1.0001 1.0001 0 1 0 16 21 L 19 21 C 20.093063 21 21 20.093063 21 19 L 21 16 A 1.0001 1.0001 0 0 0 19.984375 14.986328 z"/></svg>
          </div>
          <div class="modal__icon modal__toolbar modal__toolbar--normal" title="Normal Screen" aria-label="Normal Screen Button">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="25" height="25"><path fill="currentColor" d="M 16.96875 4.972656 C 15.867188 4.988281 14.984375 5.894531 15 7 L 15 15 L 7 15 C 6.277344 14.988281 5.609375 15.367188 5.246094 15.992188 C 4.878906 16.613281 4.878906 17.386719 5.246094 18.007813 C 5.609375 18.632813 6.277344 19.011719 7 19 L 19 19 L 19 7 C 19.007813 6.460938 18.796875 5.941406 18.414063 5.558594 C 18.03125 5.175781 17.511719 4.964844 16.96875 4.972656 Z M 32.96875 4.972656 C 31.921875 4.988281 31.0625 5.8125 31.003906 6.859375 C 31 6.90625 31 6.953125 31 7 L 31 19 L 43 19 C 43.066406 19 43.132813 19 43.199219 18.992188 C 44.269531 18.894531 45.070313 17.972656 45.015625 16.902344 C 44.964844 15.828125 44.074219 14.988281 43 15 L 35 15 L 35 7 C 35.007813 6.460938 34.796875 5.941406 34.414063 5.558594 C 34.03125 5.175781 33.511719 4.964844 32.96875 4.972656 Z M 7 31 C 6.277344 30.988281 5.609375 31.367188 5.246094 31.992188 C 4.878906 32.613281 4.878906 33.386719 5.246094 34.007813 C 5.609375 34.632813 6.277344 35.011719 7 35 L 15 35 L 15 43 C 14.988281 43.722656 15.367188 44.390625 15.992188 44.753906 C 16.613281 45.121094 17.386719 45.121094 18.007813 44.753906 C 18.632813 44.390625 19.011719 43.722656 19 43 L 19 31 Z M 31 31 L 31 43 C 30.988281 43.722656 31.367188 44.390625 31.992188 44.753906 C 32.613281 45.121094 33.386719 45.121094 34.007813 44.753906 C 34.632813 44.390625 35.011719 43.722656 35 43 L 35 35 L 43 35 C 43.722656 35.011719 44.390625 34.632813 44.753906 34.007813 C 45.121094 33.386719 45.121094 32.613281 44.753906 31.992188 C 44.390625 31.367188 43.722656 30.988281 43 31 Z"/></svg>
          </div>
        </span>
        
        <div class="modal__icon modal__arrow modal__arrow--left" title="Arrow Left" aria-label="Arrow Left Button">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="28" height="28"><path fill="currentColor" d="M 23.28125 11 L 10 10 L 10 6.851563 C 10 6.523438 9.839844 6.277344 9.519531 6.03125 C 9.199219 5.949219 8.878906 5.949219 8.640625 6.113281 C 5.359375 8.410156 2.238281 12.257813 2.160156 12.421875 C 2.082031 12.578125 2.007813 12.8125 2.003906 12.976563 C 2.003906 12.980469 2 12.988281 2 12.992188 C 2 13.15625 2.078125 13.402344 2.160156 13.484375 C 2.238281 13.648438 5.28125 17.507813 8.640625 19.804688 C 8.960938 19.96875 9.28125 20.050781 9.519531 19.886719 C 9.839844 19.722656 10 19.476563 10 19.148438 L 10 16 L 23.28125 15 C 23.679688 14.679688 24 13.875 24 12.992188 C 24 12.195313 23.761719 11.320313 23.28125 11 Z"/></svg>
        </div>
        
        <div class="modal__icon modal__arrow modal__arrow--right" title="Arrow Right" aria-label="Arrow Right Button">

          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="28" height="28"><path fill="currentColor" d="M 2.71875 11.023438 L 16 10.023438 L 16 6.875 C 16 6.546875 16.160156 6.300781 16.480469 6.054688 C 16.800781 5.972656 17.121094 5.972656 17.359375 6.136719 C 20.640625 8.433594 23.761719 12.28125 23.839844 12.445313 C 23.917969 12.601563 23.992188 12.835938 23.996094 13 C 23.996094 13.003906 24 13.011719 24 13.015625 C 24 13.179688 23.921875 13.425781 23.839844 13.507813 C 23.761719 13.671875 20.71875 17.53125 17.359375 19.828125 C 17.039063 19.992188 16.71875 20.074219 16.480469 19.910156 C 16.160156 19.746094 16 19.5 16 19.171875 L 16 16.023438 L 2.71875 15.023438 C 2.320313 14.703125 2 13.898438 2 13.015625 C 2 12.21875 2.238281 11.34375 2.71875 11.023438 Z"/></svg>
        </div>

        <div class="modal__caption">
          <div class="modal__caption--text">
          </div>
        </div>

      </span>
    </div>
  </div>
</div>


<script defer src="/blog/js/swipe.min.08ff2be1b74347bad9e267f732f1388d271b2f9d97b6a8a87bd6a510f17c5ad2.js"></script>

<script defer src="/blog/js/micromodal.min.de01b44b2f383056bbcaf6ee921fd385d79108ec1129afd0eb2f3f5a07e11f45.js"></script>

<script defer src="/blog/js/helper/fadeinout.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function () {
  
   
  var docElem = document.documentElement;

   
  function openFullscreen() {
    if (docElem.requestFullscreen) {
      docElem.requestFullscreen();
    } else if (docElem.mozRequestFullScreen) {  
      docElem.mozRequestFullScreen();
    } else if (docElem.webkitRequestFullscreen) {  
      docElem.webkitRequestFullscreen();
    } else if (docElem.msRequestFullscreen) {  
      docElem.msRequestFullscreen();
    }
  }

   
  function closeFullscreen() {
    if (document.fullscreenElement ||
      document.webkitFullscreenElement ||
      document.mozFullScreenElement) {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {  
        document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {  
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {  
        document.msExitFullscreen();
      }
    }
  }

  var modal = document.getElementById('modal');
  var galleryContainerElem = document.querySelector('.gallery__container');
  var swipeWrapElem = document.querySelector('.swipe-wrap');
  var mySwipeElem = document.getElementById('mySwipe');
  var arrowLeftElem = document.querySelector('.modal__arrow--left');
  var arrowRightElem = document.querySelector('.modal__arrow--right');
  var closeElem = document.querySelector('.modal__toolbar--close');
  var fullElem = document.querySelector('.modal__toolbar--full');
  var normalElem = document.querySelector('.modal__toolbar--normal');
  var captionElem = document.querySelector('.modal__caption');
  var pagingElem = document.querySelector('.modal__paging');
  var itemsElem = document.querySelector('.modal__items');
  var imgTotalNum = null;
  var myFadeTimeout = null;
  var mySwipe = null;
  var keydownFunction = function (e) {
    if (e.key === 'ArrowRight') {
      if (modal && modal.classList.contains('is-open')) {
        mySwipe.next();
      }
    } else if (e.key === 'ArrowLeft') {
      if (modal && modal.classList.contains('is-open')) {
        mySwipe.prev();
      }
    }
  }

  if (galleryContainerElem) {
    imgTotalNum = galleryContainerElem.querySelectorAll('img').length;
  } else {
    galleryContainerElem = document.querySelector('.single__contents');
    imgTotalNum = galleryContainerElem.querySelectorAll('img').length;
  }

  MicroModal.init({
    onClose: function () {
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
        closeFullscreen();
      }
      window.removeEventListener('keydown', keydownFunction);
    },
    disableScroll: true,
    disableFocus: true,
    awaitOpenAnimation: false,
    awaitCloseAnimation: false,
    debugMode: false,
  });

  var imageLoad = function(src) {
    return new Promise(function(resolve, reject) {
      var newImg = new Image;
      newImg.onload = function() {
        resolve(newImg);
      }
      newImg.onerror = reject;
      newImg.src = src;
    });
  }

  galleryContainerElem.querySelectorAll('img').forEach(function (elem, idx) {
    elem.style.cursor = 'pointer';

    var clonedElem = elem.cloneNode(true);
    clonedElem.style.maxHeight = '100%';
    clonedElem.style.maxWidth = '100%';
    clonedElem.onclick = function (e) {
      e.stopPropagation();
    }

    var wrapper = document.createElement('div');
    wrapper.style.width = '100%';
    wrapper.style.height = '100vh';
    wrapper.setAttribute('data-micromodal-close', '');
    wrapper.onclick = function () {
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
      }
    }
    wrapper.onmouseenter = function () {
      clearTimeout(myFadeTimeout);
      fadeIn(itemsElem, 200);
    };
    wrapper.onmouseleave = function () {
      myFadeTimeout = setTimeout(function () {
        fadeOut(itemsElem, 200);
      }, 2500);
    }
    wrapper.ontouchstart = function() {
      fadeIn(itemsElem, 200);
    }
    wrapper.append(clonedElem);
    swipeWrapElem.append(wrapper);

    elem.addEventListener('click', async function (e) {
      MicroModal.show('modal');
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
      }

      var imgSrc = e.target.getAttribute('data-src') || e.target.getAttribute('src');
      var img = await imageLoad(imgSrc);
      clonedElem.style.width = img.width + 'px';
      clonedElem.style.height = img.height + 'px';
      
      
      mySwipe = new Swipe(mySwipeElem, {
        startSlide: idx,
        draggable: true,
        autoRestart: false,
        continuous: false,
        disableScroll: true,
        stopPropagation: true,
        callback: async function (index, element) {
          
          var imgElem = element.querySelector('img');
          var imgSrc = imgElem.getAttribute('data-src') || imgElem.getAttribute('src');
          var img = await imageLoad(imgSrc);
          imgElem.style.width = img.width + 'px';
          imgElem.style.height = img.height + 'px';

          
          if (captionElem && imgElem) {
            var caption = null;
            if (imgElem.getAttribute('data-caption')) {
              caption = imgElem.getAttribute('data-caption');
            } else if (imgElem.getAttribute('title')) {
              caption = imgElem.getAttribute('title');
            } else if (imgElem.getAttribute('alt')) {
              caption = imgElem.getAttribute('alt');
            } else {
              caption = imgElem.getAttribute('src');
            }

            captionElem.querySelector('.modal__caption--text').innerText = caption;
            pagingElem.innerText = (index + 1) + ' / ' + imgTotalNum;

            clearTimeout(myFadeTimeout);
            fadeIn(itemsElem, 200);
          }
        },
      });

      fadeIn(itemsElem);

      
      if (captionElem) {
        var caption = null;
        if (e.target.getAttribute('data-caption')) {
          caption = e.target.getAttribute('data-caption');
        } else if (e.target.getAttribute('title')) {
          caption = e.target.getAttribute('title');
        } else if (e.target.getAttribute('alt')) {
          caption = e.target.getAttribute('alt');
        } else {
          caption = e.target.getAttribute('src');
        }

        captionElem.querySelector('.modal__caption--text').innerText = caption;
        pagingElem.innerText = (idx + 1) + ' / ' + imgTotalNum;
      }

      if (normalElem && fullElem) {
        normalElem.style.zIndex = -1;
        normalElem.style.opacity = 0;
        fullElem.style.zIndex = 25;
        fullElem.style.opacity = 1;
      }
    });

    window.addEventListener('keydown', keydownFunction);
  });

  arrowLeftElem ?
    arrowLeftElem.addEventListener('click', function (e) {
      if (mySwipe) {
        mySwipe.prev();
      }
    }) : null;
  arrowRightElem ?
    arrowRightElem.addEventListener('click', function (e) {
      if (mySwipe) {
        mySwipe.next();
      }
    }) : null;

  closeElem ?
    closeElem.addEventListener('click', function () {
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
      }
      closeFullscreen();
      MicroModal.close('modal');
    }) : null;

  fullElem ?
    fullElem.addEventListener('click', function (e) {
      openFullscreen();
      if (normalElem) {
        normalElem.style.zIndex = 25;
        normalElem.style.opacity = 1;
        fullElem.style.zIndex = -1;
        fullElem.style.opacity = 0;
      }
    }) : null;

  normalElem ?
    normalElem.addEventListener('click', function (e) {
      closeFullscreen();
      if (fullElem) {
        fullElem.style.zIndex = 25;
        fullElem.style.opacity = 1;
        normalElem.style.zIndex = -1;
        normalElem.style.opacity = 0;
      }
    }) : null;
  
});
</script>

    <div class="hide">
      

<div class="search">
  <span class="icon">
    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M15.5 14h-.79l-.28-.27c1.2-1.4 1.82-3.31 1.48-5.34-.47-2.78-2.79-5-5.59-5.34-4.23-.52-7.79 3.04-7.27 7.27.34 2.8 2.56 5.12 5.34 5.59 2.03.34 3.94-.28 5.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
  </span>
  <input id="search" aria-label="Site Search" class="input" type="text" placeholder="Search" autocomplete="off">
  <div id="search-results" class="dropdown">
    <div id="search-menu" class="dropdown-menu" role="menu">
    </div>
  </div>
</div>


    </div>
  </div>
</main>


<aside class="single__side main-side">
  


<section class="sidebar hide">
  <script>document.querySelector('.sidebar').classList.remove('hide')</script>
  <div class="toc__flexbox" data-position="fixed">
    <h6 class="toc__title" data-ani="true">What&#39;s on this Page</h6>
    
      <label class="switch" data-ani="true">
        <input id="toggle-toc" aria-label="Toggle TOC" type="checkbox" checked>
        <span class="slider round"></span>
      </label>
    
  </div>
  <div class="toc " data-dir="ltr" data-folding="false" data-ani="true">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#第二章-构筑抽象数据">第二章: 构筑抽象数据</a>
      <ul>
        <li><a href="#21-介绍">2.1 介绍</a></li>
        <li><a href="#22-数据抽象">2.2 数据抽象</a></li>
        <li><a href="#23-序列">2.3 序列</a></li>
        <li><a href="#24-可变数据">2.4 可变数据</a></li>
        <li><a href="#25-面向对象编程">2.5 面向对象编程</a></li>
        <li><a href="#26-实现类以及对象">2.6 实现类以及对象</a></li>
        <li><a href="#27-对象抽象">2.7 对象抽象</a></li>
        <li><a href="#28-效率">2.8 效率</a></li>
        <li><a href="#29-递归对象">2.9 递归对象</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</section>



</aside>

<script>
  
  
  

  var enableToc = JSON.parse("true");
  var toc = JSON.parse("null");
  var tocPosition = JSON.parse("\"inner\"");
  
  var singleMainElem = document.querySelector('.single__main');
  var singleSideElem = document.querySelector('.single__side');

  enquire.register("screen and (max-width: 769px)", {
    match: function () {
      if ((enableToc || toc) && tocPosition !== "outer") {
        if (singleMainElem && singleSideElem) {
          singleMainElem.classList.remove('main-main');
          singleMainElem.classList.add('main');
          singleSideElem.classList.remove('main-side');
          singleSideElem.classList.add('hide');
        }
      } else if (tocPosition === "outer") {
        if (singleMainElem && !singleMainElem.classList.contains('main-main')) {
          singleMainElem.classList.remove('main-main');
          singleMainElem.classList.add('main');
        }
        if (singleSideElem && !singleSideElem.classList.contains('hide')) {
          singleSideElem.classList.add('hide');
        }
      }
    },
    unmatch: function () {
      if ((enableToc || toc) && tocPosition !== "outer") {
        singleMainElem.classList.remove('main');
        singleMainElem.classList.add('main-main');
        singleSideElem.classList.remove('hide');
        singleSideElem.classList.add('main-side');
      } else if (tocPosition === "outer") {
        if (singleMainElem && !singleMainElem.classList.contains('main-main')) {
          singleMainElem.classList.remove('main-main');
          singleMainElem.classList.add('main');
        }
        if (singleSideElem && !singleSideElem.classList.contains('hide')) {
          singleSideElem.classList.add('hide');
        }
      }

      var navCollapseBtn = document.querySelector('.navbar__burger');
      var navCollapse = document.getElementsByClassName('navbarm__collapse')[0];
      if (navCollapse) {
        navCollapse.setAttribute('data-open', false);
        navCollapse.style.maxHeight = 0;
        navCollapseBtn.classList.remove('is-active');
      }
      document.getElementsByClassName('navbar__menu')[0].classList.remove('is-active');
      document.getElementsByClassName('mobile-search')[0].classList.add('hide');
    },
    setup: function () { },
    deferSetup: true,
    destroy: function () { },
  });
</script>




<script defer src="/blog/js/clipboard.min.1626706afc88d95ebe1173b553ec732c6dc82a576989315fdf5e7779af738a44.js"></script>

<script defer src="/blog/js/helper/getParents.min.js"></script>

<script defer src="/blog/js/helper/closest.min.js"></script>

<script defer src="/blog/js/helper/prev.min.js"></script>

<script defer src="/blog/js/helper/prop.min.js"></script>

<script defer src="/blog/js/helper/fadeinout.min.js"></script>

















<script>
  'use strict';

  window.onload = function() {
    var navbar = document.querySelector('.navbar');
    var singleContentsElem = document.querySelector('.single__contents');

    
    
    
    var enableBusuanzi = JSON.parse("false");
    var busuanziPagePV = JSON.parse("true");
    
    if (enableBusuanzi && busuanziPagePV) {
      var pagePvElem = document.querySelector('#busuanzi_value_page_pv');
      pagePvElem.textContent = pagePvElem.textContent.replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
    }    
    


    
    
    
    
    
    
    var enableToc = JSON.parse("true");
    var toc = JSON.parse("null");
    var hideToc = JSON.parse("false");
    var tocFlexbox = document.querySelector('.toc__flexbox');
    var tocFlexboxOuter = document.querySelector('.toc__flexbox--outer');
    var tocFolding = JSON.parse("false");
    
    if ((enableToc || toc) && document.querySelector('.toc')) {
      var tableOfContentsElem = document.querySelector('.toc').querySelector('#TableOfContents');

      if (false === tocFolding) {

      } else {
        tableOfContentsElem.querySelectorAll('ul') ?
          tableOfContentsElem.querySelectorAll('ul').forEach(function (rootUl) {
            rootUl.querySelectorAll('li').forEach(function (liElem) {
              liElem.querySelectorAll('ul').forEach(function (ulElem) {
                ulElem.style.display = 'none';
              });
            });
          }) : null;
      }

      if (tableOfContentsElem) {
        if (tableOfContentsElem.querySelectorAll('a').length > 0) {
          tableOfContentsElem.querySelectorAll('a').forEach(function (elem) {
            elem.addEventListener('click', function () {
              var id = elem.getAttribute('id');
              navbar.classList.remove('navbar--show');
              navbar.classList.remove('navbar--hide');
              navbar.classList.add('navbar--hide');

              document.querySelector('.toc').querySelectorAll('a').forEach(function (elem) {
                elem.classList.remove('active');
              });
              elem.classList.add('active');

              var curElem = tableOfContentsElem.querySelector('[href="#' + id + '"]');
              if (curElem && curElem.nextElementSibling) {
                curElem.nextElementSibling.style.display = 'block';
              }
              if (curElem) {
                getParents(curElem, 'ul') ?
                  getParents(curElem, 'ul').forEach(function (elem) {
                    elem.style.display = 'block';
                  }) : null;
              }
            });
          });
        } else {
          if (tocFlexbox) {
            tocFlexbox.setAttribute('data-position', '');
            if (!tocFlexbox.classList.contains('hide')) {
              tocFlexbox.classList.add('hide');
            }
          }
          if (tocFlexboxOuter) {
            tocFlexboxOuter.setAttribute('data-position', '');
            if (!tocFlexboxOuter.classList.contains('hide')) {
              tocFlexboxOuter.classList.add('hide');
            }
          }
        }
      }

      
      var toggleTocElem = document.getElementById("toggle-toc");
      var visibleTocElem = document.getElementById('visible-toc');
      var tocElem = document.querySelector('.toc');
      var mainElem = document.querySelector('main');
      var sideElem = document.querySelector('side');
      var tocFlexboxElem = document.querySelector('.toc__flexbox');

      toggleTocElem ? 
      toggleTocElem.addEventListener('change', function(e) {
        if (e.target.checked) {
          if (tocElem) {
            fadeIn(tocElem, 200);
          }
          if (tocFlexboxElem) {
            tocFlexboxElem.setAttribute('data-position', 'fixed');
          }

          if (mainElem) {
            mainElem.classList.remove('main-main');
            mainElem.classList.remove('main');
            mainElem.classList.add('main-main');
          }
          if (sideElem) {
            sideElem.classList.remove('main-side');
          }
        } else {
          if (tocElem) {
            fadeOut(tocElem, 200);
          }
          if (tocFlexboxElem) {
            tocFlexboxElem.setAttribute('data-position', 'absolute');
          }

          if (mainElem) {
            mainElem.classList.remove('main-main');
            mainElem.classList.remove('main');
            mainElem.classList.add('main');
          }
          if (sideElem) {
            sideElem.classList.remove('main-side');
          }
        }
      }) : null;

      visibleTocElem ?
      visibleTocElem.addEventListener('change', function(e) {
        if (e.target.checked) {
          if (tocElem) {
            fadeIn(tocElem, 200);
          }
        } else {
          if (tocElem) {
            fadeOut(tocElem, 200);
          }
        }
      }) : null;
    }
    


    
    var tables = document.querySelectorAll('.single__contents > table');
    for (let i = 0; i < tables.length; i++) {
      var table = tables[i];
      var wrapper = document.createElement('div');
      wrapper.className = 'table-wrapper';
      table.parentElement.replaceChild(wrapper, table);
      wrapper.appendChild(table);
    }
    


    
    var text, clip = new ClipboardJS('.anchor');
    var headers = singleContentsElem.querySelectorAll("h1, h2, h3, h4");

    
    var languagedir = JSON.parse("\"ltr\"");

    headers ? 
    headers.forEach(function (elem) {
      var url = encodeURI(document.location.origin + document.location.pathname);
      var link = url + "#" + elem.getAttribute('id');
      var newElemOuter = document.createElement('span');
      newElemOuter.classList.add('anchor');
      newElemOuter.classList.add('hide');
      newElemOuter.setAttribute('data-clipboard-text', link);
      newElemOuter.style.position = 'relative';

      var newElemInner = document.createElement('span');
      newElemInner.style.fontSize = '1rem';
      newElemInner.style.position = 'absolute';
      newElemInner.style.top = '50%';
      newElemInner.style.transform = 'translateY(-50%)';
      newElemInner.innerText = "🔗";

      if (languagedir === "rtl") {
        newElemInner.style.left = '-2rem';
      } else {
        newElemInner.style.right = '-2rem';
      }

      newElemOuter.append(newElemInner);
      elem.append(newElemOuter);

      elem.addEventListener('mouseenter', function() {
        this.querySelector('.anchor').classList.remove('hide');
      });
      elem.addEventListener('mouseleave', function () {
        this.querySelector('.anchor').classList.add('hide');
      });
    }) : null;

    document.querySelectorAll('.anchor').forEach(function(elem) {
      elem.addEventListener('mouseleave', function() {
        elem.setAttribute('aria-label', null);
        elem.classList.remove('tooltipped');
        elem.classList.remove('tooltipped-s');
        elem.classList.remove('tooltipped-w');
      });
    });

    clip.on('success', function (e) {
      e.clearSelection();
      e.trigger.setAttribute('aria-label', 'Link copied to clipboard!');
      e.trigger.classList.add('tooltipped');
      e.trigger.classList.add('tooltipped-s');
    });
    


    
    var clipInit = false;
    var preChromaElem = document.querySelectorAll('pre.chroma');
    var langCodeElem = document.querySelectorAll('.language-code');
    var dollarCodeElem = document.querySelectorAll('div.language-\\$');
    var gtCodeElem = document.querySelectorAll('div.language-\\>');

    var makeClipboard = function(elem) {
      var code = elem,
        text = elem.textContent;
        
      if (text.length > 15) {
        if (!clipInit) {
          var text, clip = new ClipboardJS('.copy-to-clipboard', {
            text: function (trigger) {
              var codeElem = prev(trigger).querySelectorAll('code');
              if (codeElem.length > 1) {
                text = prev(trigger).querySelector('code[class^="language-"]').textContent;
              } else {
                text = prev(trigger).querySelector('code').textContent;
              }

              return text.replace(/^\$\s/gm, '');
            }
          });

          var inPre;
          clip.on('success', function (e) {
            e.clearSelection();
            inPre = prop(e.trigger.parentNode, 'tagName') == 'PRE';
            e.trigger.setAttribute('aria-label', 'Copied to clipboard!');
            e.trigger.classList.add('tooltipped');
            e.trigger.classList.add('tooltipped-w');
          });

          clip.on('error', function (e) {
            inPre = prop(e.trigger.parentNode, 'tagName') == 'PRE';
            e.trigger.setAttribute('aria-label', e.action.toString());
            e.trigger.classList.add('tooltipped');
            e.trigger.classList.add('tooltipped-w');
          });

          clipInit = true;
        }

        var notAllowedClass = ['language-mermaid', 'language-viz', 'language-wave', 'language-chart', 'language-msc', 'language-flowchart'];
        var isNotAllowedIncluded = false;
        var curClassName = code.getAttribute('class');

        for (var i = 0; i < notAllowedClass.length; i++) {
          if (curClassName && curClassName.startsWith(notAllowedClass[i])) {
            isNotAllowedIncluded = true;
            break;
          }
        }

        if (!isNotAllowedIncluded) {
          if (curClassName) {
            var newClipboardElem = document.createElement('span');
            newClipboardElem.setAttribute('class', 'copy-to-clipboard');
            newClipboardElem.setAttribute('title', 'Copy to clipboard');
            elem.parentNode.parentNode.insertBefore(newClipboardElem, elem.parentNode.nextElementSibling);
          }
        }
      }
    }

    var makeSymbolClipboard = function(elem) {
      var clipboardSpan = document.createElement('span');
      clipboardSpan.setAttribute('class', 'copy-to-clipboard');
      clipboardSpan.setAttribute('title', 'Copy to clipboard');
      elem.parentNode.parentNode.insertBefore(clipboardSpan, elem.parentNode.nextElementSibling);
    }

    preChromaElem ? 
    preChromaElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function(codeElem) {
        makeClipboard(codeElem);
      });
    }) : null;
    
    langCodeElem ? 
    langCodeElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function (codeElem) {
        makeClipboard(codeElem);
      });
    }) : null;

    dollarCodeElem ? 
    dollarCodeElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function (codeElem) {
        makeSymbolClipboard(codeElem);
      });
    }) : null;

    gtCodeElem ?
    gtCodeElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function (codeElem) {
        makeSymbolClipboard(codeElem);
      });
    }) : null;
    


    
    dollarCodeElem ?
    dollarCodeElem.forEach(function(elem) {
      var lnts = elem.parentNode.parentNode ? elem.parentNode.parentNode.querySelectorAll('.lnt') : null;
      lnts ? 
      lnts.forEach(function(lnt) {
        lnt.innerHTML = '$<br/>';
      }) : null;
    }) : null;

    gtCodeElem ?
    gtCodeElem.forEach(function(elem) {
      var lnts = elem.parentNode.parentNode ? elem.parentNode.parentNode.querySelectorAll('.lnt') : null;
      lnts ? 
      lnts.forEach(function(lnt) {
        lnt.innerHTML = '><br/>';
      }) : null;
    }) : null;
    


    
    
    var lib = JSON.parse("null");

    if (lib && lib.includes('mermaid')) {
      
      var themeVariant = localStorage.getItem('theme') || JSON.parse("\"solarized\"");

      if (themeVariant === "dark" || themeVariant === "hacker") {
        mermaid.initialize({ theme: 'dark' });
      } else {
        mermaid.initialize({ theme: 'default' });
      }
      
      var mermaids = [];
      [].push.apply(mermaids, document.getElementsByClassName('language-mermaid'));
      mermaids.forEach(function(elem) {
        var elemParentNode = elem.parentNode;

        if (elemParentNode !== document.body) {
          elemParentNode.parentNode.insertBefore(elem, elemParentNode);
          elemParentNode.parentNode.removeChild(elemParentNode);
        }

        var newElemWrapper = document.createElement('div');
        newElemWrapper.classList.add('mermaid');
        newElemWrapper.style.padding = '34px 4px 6px';
        newElemWrapper.innerHTML = elem.innerHTML;
        elem.replaceWith(newElemWrapper);
      });
    }
    
    

    
    if (lib && lib.includes('katex')) {
      var mathElements = document.getElementsByClassName('math');
      var options = {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "\\[", right: "\\]", display: true },
          { left: "$", right: "$", display: false },
          { left: "\\(", right: "\\)", display: false }
        ],
      };

      renderMathInElement(document.querySelector('.single__contents'), options);
    }
    


    
    if (lib && lib.includes('flowchartjs')) {
      
      var options = JSON.parse("{\"arrow-end\":\"block\",\"element-color\":\"black\",\"fill\":\"white\",\"flowstate\":{\"approved\":{\"fill\":\"#58C4A3\",\"font-size\":12,\"no-text\":\"n/a\",\"yes-text\":\"APPROVED\"},\"current\":{\"fill\":\"yellow\",\"font-color\":\"red\",\"font-weight\":\"bold\"},\"future\":{\"fill\":\"#FFFF99\"},\"invalid\":{\"fill\":\"#444444\"},\"past\":{\"fill\":\"#CCCCCC\",\"font-size\":12},\"rejected\":{\"fill\":\"#C45879\",\"font-size\":12,\"no-text\":\"REJECTED\",\"yes-text\":\"n/a\"},\"request\":{\"fill\":\"blue\"}},\"font-color\":\"black\",\"font-size\":14,\"line-color\":\"black\",\"line-length\":50,\"line-width\":3,\"no-text\":\"no\",\"scale\":1,\"symbols\":{\"end\":{\"class\":\"end-element\"},\"start\":{\"element-color\":\"green\",\"fill\":\"yellow\",\"font-color\":\"red\"}},\"text-margin\":10,\"x\":0,\"y\":0,\"yes-text\":\"yes\"}");
      var jsonContent = null;

      var flowchartPrefix = "language-flowchart";
      var index = 0;
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + flowchartPrefix + "]"), function(x){
          x.style.display = 'none'
          x.parentNode.style.backgroundColor = "transparent"
          jsonContent = x.innerText;

          var node0 = document.createElement('div');
          node0.id = 'flowchart' + index;
          x.parentNode.insertBefore(node0, x);

          var diagram = flowchart.parse(jsonContent);
          diagram.drawSVG("flowchart"+index, options);

          index +=1;
      });      
    }
    


    
    


    
    if (lib && lib.includes('msc')) {
      
      var options = JSON.parse("{\"theme\":\"hand\"}");
      var jsonContent = null;

      var index = 0;
      var chartPrefix = "language-msc";
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + chartPrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        jsonContent = x.innerText;
        var node0 = document.createElement('div');
        node0.id = 'msc' + index;
        x.parentNode.insertBefore(node0, x);
        var diagram = Diagram.parse(jsonContent);
        diagram.drawSVG("msc" + index, options);
        index += 1;
      });
    }
    


    
    if (lib && lib.includes('chart')) {
      var borderColor = "#666";
      var bgColor = "#ddd";
      var borderWidth = 2;

      Chart.defaults.global.elements.rectangle.borderWidth = borderWidth;
      Chart.defaults.global.elements.rectangle.borderColor = borderColor;
      Chart.defaults.global.elements.rectangle.backgroundColor = bgColor;

      Chart.defaults.global.elements.line.borderWidth = borderWidth;
      Chart.defaults.global.elements.line.borderColor = borderColor;
      Chart.defaults.global.elements.line.backgroundColor = bgColor;

      Chart.defaults.global.elements.point.borderWidth = borderWidth;
      Chart.defaults.global.elements.point.borderColor = borderColor;
      Chart.defaults.global.elements.point.backgroundColor = bgColor;

      var chartPrefix = "language-chart";
      var index = 0;
      var jsonContent = null;

      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + chartPrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        jsonContent = x.innerText;
        var node0 = document.createElement('canvas');
        var source = null;
        node0.height = 200;
        node0.style.height = 200;
        node0.id = 'myChart' + index;
        source = JSON.parse(jsonContent);
        x.parentNode.insertBefore(node0, x);
        var ctx = document.getElementById('myChart' + index).getContext('2d');
        var myChart = new Chart(ctx, source);
        index += 1;
      });            
    }
    


    
    if (lib && lib.includes('wavedrom')) {
      var wavePrefix = "language-wave";
      var index = 0;
      var jsonContent = null;
      
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + wavePrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        jsonContent = x.innerText;
        var node0 = document.createElement('div');
        var source = null;
        node0.id = 'WaveDrom_Display_' + index;
        source = JSON.parse(jsonContent);
        x.parentNode.insertBefore(node0, x);
        WaveDrom.RenderWaveForm(index, source, "WaveDrom_Display_");
        index += 1;
      });
    }
    


    
    if (lib && lib.includes('viz')) {
      var vizPrefix = "language-viz-";
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + vizPrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        var engine;
        x.getAttribute("class").split(" ").forEach(function (cls) {
          if (cls.startsWith(vizPrefix)) {
            engine = cls.substr(vizPrefix.length);
          }
        });
        var viz = new Viz();
        viz.renderSVGElement(x.innerText, { engine: engine })
          .then(function (element) {
            element.style.width = "100%";
            x.parentNode.insertBefore(element, x);
          })
      });
    }
    
    
  }
</script>


            
            <footer class="footer">
    
<div class="dropdown">
  <button class="dropdown-trigger" aria-label="Select Theme Button">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M12.65 15.67c.14-.36.05-.77-.23-1.05l-2.09-2.06.03-.03c1.74-1.94 2.98-4.17 3.71-6.53h1.94c.54 0 .99-.45.99-.99v-.02c0-.54-.45-.99-.99-.99H10V3c0-.55-.45-1-1-1s-1 .45-1 1v1H1.99c-.54 0-.99.45-.99.99 0 .55.45.99.99.99h10.18C11.5 7.92 10.44 9.75 9 11.35c-.81-.89-1.49-1.86-2.06-2.88-.16-.29-.45-.47-.78-.47-.69 0-1.13.75-.79 1.35.63 1.13 1.4 2.21 2.3 3.21L3.3 16.87c-.4.39-.4 1.03 0 1.42.39.39 1.02.39 1.42 0L9 14l2.02 2.02c.51.51 1.38.32 1.63-.35zM17.5 10c-.6 0-1.14.37-1.35.94l-3.67 9.8c-.24.61.22 1.26.87 1.26.39 0 .74-.24.88-.61l.89-2.39h4.75l.9 2.39c.14.36.49.61.88.61.65 0 1.11-.65.88-1.26l-3.67-9.8c-.22-.57-.76-.94-1.36-.94zm-1.62 7l1.62-4.33L19.12 17h-3.24z"/></svg>
  </button>
  <div class="dropdown-content">
    
    
    
  </div>
</div>

    
<div class="footer__social">
  <div class="social">
    
            
    
            
    
            
    
      
      <a href="mailto:willsurpriseyou@foxmail.com" title="email" aria-label="email">
        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-.4 4.25l-7.07 4.42c-.32.2-.74.2-1.06 0L4.4 8.25c-.25-.16-.4-.43-.4-.72 0-.67.73-1.07 1.3-.72L12 11l6.7-4.19c.57-.35 1.3.05 1.3.72 0 .29-.15.56-.4.72z"/></svg>
      </a>
            
    
      
      <a href="http://example.org/" title="facebook" aria-label="facebook">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 24 24" version="1.1">
<g id="surface2747">
<path fill="currentColor" d="M 11.664062 2.003906 C 6.621094 2.171875 2.375 6.25 2.023438 11.289062 C 1.65625 16.617188 5.46875 21.121094 10.507812 21.878906 L 10.507812 14.648438 L 8.890625 14.648438 C 8.164062 14.648438 7.578125 14.0625 7.578125 13.335938 C 7.578125 12.609375 8.164062 12.023438 8.890625 12.023438 L 10.503906 12.023438 L 10.503906 10.273438 C 10.503906 7.378906 11.914062 6.105469 14.324219 6.105469 C 14.679688 6.105469 14.984375 6.113281 15.242188 6.128906 C 15.878906 6.15625 16.371094 6.6875 16.371094 7.324219 C 16.371094 7.988281 15.835938 8.523438 15.171875 8.523438 L 14.730469 8.523438 C 13.710938 8.523438 13.351562 9.492188 13.351562 10.585938 L 13.351562 12.023438 L 15.222656 12.023438 C 15.8125 12.023438 16.265625 12.550781 16.175781 13.132812 L 16.066406 13.835938 C 15.992188 14.304688 15.589844 14.652344 15.113281 14.652344 L 13.351562 14.652344 L 13.351562 21.898438 C 18.234375 21.234375 22 17.0625 22 12 C 22 6.367188 17.339844 1.820312 11.664062 2.003906 Z M 11.664062 2.003906 "/>
</g>
</svg>

      </a>
            
    
            
    
      
      <a href="https://github.com/jmwill" title="github" aria-label="github">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 24 24" version="1.1">
<g id="surface3680">
<path fill="currentColor" d="M 10.898438 2.101562 C 6.300781 2.601562 2.601562 6.300781 2.101562 10.800781 C 1.601562 15.5 4.300781 19.699219 8.398438 21.300781 C 8.699219 21.398438 9 21.199219 9 20.800781 L 9 19.199219 C 9 19.199219 8.601562 19.300781 8.101562 19.300781 C 6.699219 19.300781 6.101562 18.101562 6 17.398438 C 5.898438 17 5.699219 16.699219 5.398438 16.398438 C 5.101562 16.300781 5 16.300781 5 16.199219 C 5 16 5.300781 16 5.398438 16 C 6 16 6.5 16.699219 6.699219 17 C 7.199219 17.800781 7.800781 18 8.101562 18 C 8.5 18 8.800781 17.898438 9 17.800781 C 9.101562 17.101562 9.398438 16.398438 10 16 C 7.699219 15.5 6 14.199219 6 12 C 6 10.898438 6.5 9.800781 7.199219 9 C 7.101562 8.800781 7 8.300781 7 7.601562 C 7 7.199219 7 6.601562 7.300781 6 C 7.300781 6 8.699219 6 10.101562 7.300781 C 10.601562 7.101562 11.300781 7 12 7 C 12.699219 7 13.398438 7.101562 14 7.300781 C 15.300781 6 16.800781 6 16.800781 6 C 17 6.601562 17 7.199219 17 7.601562 C 17 8.398438 16.898438 8.800781 16.800781 9 C 17.5 9.800781 18 10.800781 18 12 C 18 14.199219 16.300781 15.5 14 16 C 14.601562 16.5 15 17.398438 15 18.300781 L 15 20.898438 C 15 21.199219 15.300781 21.5 15.699219 21.398438 C 19.398438 19.898438 22 16.300781 22 12.101562 C 22 6.101562 16.898438 1.398438 10.898438 2.101562 Z M 10.898438 2.101562 "/>
</g>
</svg>

      </a>
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
      
      <a href="https://twitter.com/j_mwill" title="twitter" aria-label="twitter">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32" version="1.1">
<g id="surface676">
<path fill="currentColor" d="M 28 8.558594 C 27.117188 8.949219 26.167969 9.214844 25.171875 9.332031 C 26.1875 8.722656 26.96875 7.757812 27.335938 6.609375 C 26.386719 7.171875 25.332031 7.582031 24.210938 7.804688 C 23.3125 6.847656 22.03125 6.246094 20.617188 6.246094 C 17.898438 6.246094 15.691406 8.453125 15.691406 11.171875 C 15.691406 11.558594 15.734375 11.933594 15.820312 12.292969 C 11.726562 12.089844 8.097656 10.128906 5.671875 7.148438 C 5.246094 7.875 5.003906 8.722656 5.003906 9.625 C 5.003906 11.332031 5.871094 12.839844 7.195312 13.722656 C 6.386719 13.695312 5.628906 13.476562 4.964844 13.105469 C 4.964844 13.128906 4.964844 13.148438 4.964844 13.167969 C 4.964844 15.554688 6.660156 17.546875 8.914062 17.996094 C 8.5 18.109375 8.066406 18.171875 7.617188 18.171875 C 7.300781 18.171875 6.988281 18.140625 6.691406 18.082031 C 7.316406 20.039062 9.136719 21.460938 11.289062 21.503906 C 9.605469 22.824219 7.480469 23.609375 5.175781 23.609375 C 4.777344 23.609375 4.386719 23.585938 4 23.539062 C 6.179688 24.9375 8.765625 25.753906 11.546875 25.753906 C 20.605469 25.753906 25.558594 18.25 25.558594 11.742188 C 25.558594 11.53125 25.550781 11.316406 25.542969 11.105469 C 26.503906 10.410156 27.339844 9.542969 28 8.558594 Z M 28 8.558594 "/>
</g>
</svg>

      </a>
            
    
            
    
            
    
            
    
            
    
            
    
    
  
  
    
      <a href="https://jmwill.github.io/blog/posts//index.xml" type="application/rss+xml" title="RSS" aria-label="RSS Feed Link">
        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><circle fill="currentColor" cx="6.18" cy="17.82" r="2.18"/><path fill="currentColor" d="M5.59 10.23c-.84-.14-1.59.55-1.59 1.4 0 .71.53 1.28 1.23 1.4 2.92.51 5.22 2.82 5.74 5.74.12.7.69 1.23 1.4 1.23.85 0 1.54-.75 1.41-1.59-.68-4.2-3.99-7.51-8.19-8.18zm-.03-5.71C4.73 4.43 4 5.1 4 5.93c0 .73.55 1.33 1.27 1.4 6.01.6 10.79 5.38 11.39 11.39.07.73.67 1.28 1.4 1.28.84 0 1.5-.73 1.42-1.56-.73-7.34-6.57-13.19-13.92-13.92z"/></svg>
      </a>
    
  

  </div>
</div>

    
<div id="gtt">
  <div class="gtt">
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M8.12 14.71L12 10.83l3.88 3.88c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L12.7 8.71c-.39-.39-1.02-.39-1.41 0L6.7 13.3c-.39.39-.39 1.02 0 1.41.39.38 1.03.39 1.42 0z"/></svg>
  </div>
</div>

    <hr />

    <div class="basicflex">
        
            <a href="" class="footer__link" target="_blank" rel="noreferrer"></a>
        
            <a href="" class="footer__link" target="_blank" rel="noreferrer"></a>
        
    </div>

    <div class="footer__poweredby">
        
                
            <p class="caption">
                
                    ©2020, All Rights Reserved
                
            </p>
        

        
            <p class="caption">Powered by <a href="https://gohugo.io/" target="_blank" rel="noreferrer">Hugo</a> and the <a href="https://github.com/zzossig/hugo-theme-zzo" target="_blank" rel="noreferrer">Zzo theme</a></p>
        
        
    </div> 
</footer>
        </div>
        





<div class="wrapper__right hide" data-pad="true" dir="ltr">
  <script>document.querySelector('.wrapper__right').classList.remove('hide')</script>
  
</div>

    </div>
</body>

</html>