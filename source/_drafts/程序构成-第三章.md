title: 程序构成-第三章
tags:
- 译文
- Design Programs
---

## 第三章: 解析计算机程序

### 3.1 介绍

章节1以及2描述了两个程序的基本要素之间的紧密联系: 函数以及数据. 我们已经见识过函数是如何在高阶函数中被当做数据来操作. 我们也见识过数据是如何通过消息传递以及一个对象系统而被赋予行为的. 我们也学习了用来组织大型程序的技术, 例如函数抽象, 数据抽象, 类继承, 以及一般函数. 这些关键概念构成了建立模块化, 可维护, 可扩展的程序的坚实基础.

本章节专注于编程的第三个基本要素: 程序本身. 一个Python程序只是一个文本的集合. 只有经过解析的过程我们才能基于该文本执行任何有意义的计算. 像Python这样的语言很有用, 因为我们可以定义一个_解析器_, 这是一个可以处理Python的运算以及执行过程的程序. 把这认为是编程的基本思想是毫不夸张的, 一个解析器它能确定表达式在编程语言中的含义, 它本身也就仅仅是另一个程序而已.

要体会到这一点需要转变我们自己作为程序员的印象. 我们要将自己看做是语言的设计者, 而不仅仅是经由其他人设计的语言的使用者.

#### 3.1.1

编程语言在它们的句法结构，特征和应用领域都变化很大. 在通用的编程语言之中, 函数定义以及函数应用的结构是普遍存在的. 另一方面, 存在强大的语言, 它并不包括对象系统, 高阶函数, 赋值, 甚至是控制结构如`while`以及`for`语句. 以具有这些特性的最小子集的强大的语言作为例子, 我们将会介绍[Scheme][1]编程语言, 在本文中介绍的Scheme的子集不允许可变值.

在这个章节中, 我们学习设计一个解析器以及当它们执行程序时创建的计算过程. 为一个通用编程语言设计一个解析器的景愿可能看起来是令人畏惧的. 然而, 许多解析器具有优雅的共同结构: 两个相互递归函数. 第一个在环境中执行表达式; 第二个则是将函数作为参数来进行应用.

这些函数都是递归的, 因为它们是相互定义的: 应用一个函数需要执行它内部的表达式, 而执行一个表达式可能涉及到调用一个或者更多个函数.

### 3.2 函数式编程

在任何现代计算机上运行的软件都是由各种各样的编程语言编写的. 有物理语言, 如针对特定的计算机的机器语言. 这些语言关注数据的表示以及根据各个位来控制存储以及原始计算机指令. 而机器语言编程员关心的是用给定的硬件来构建系统以及在资源有限的计算机上使得实用程序能高效实施. 高阶语言, 架设在机器语言的基础上, 隐藏对数据表示为位的集合以及程序作为一系列原始计算机指令的表示的关注. 这些语言具有组合以及抽象的手段, 比如函数定义, 这适用于大规模组织的软件系统.

在这一章节中, 我们要介绍一种鼓励函数式风格的高阶编程语言, 我们学习的对象是Scheme语言的子集, 它使用的计算模型根Python的很相似, 但只使用表达式(没有声明), 专注于符号运算, 同时只使用不可变数据.

Scheme是[Lisp][2]的一种方言, 是第二古老的编程语言(在[Fortran][3]之后), 它直到今天仍然被广泛地使用.  Lisp程序员社区已经持续存在成长了几十年了, 同时新的Lisp的方言比如[Clojure][4]具有一些跟现代编程语言一样增长最快的编程员社区. 为了跟上本文的例子, 你可以下载一个[Scheme编辑器][5].

#### 3.2.1 表达式

Scheme程序由表达式组成, 也叫做表达式或者特殊形式. 一个可调用的表达式由一个操作符表达式伴随着零或多个操作数子表达式组成, 就像Python那样. 操作数以及操作符都是包含在括号中:

```scheme
(quotient 10 2)
5
```

Scheme只使用前缀符号. 操作符通常是一个符号, 例如`+`以及`*`. 调用表达式可以是嵌套的, 同时它们可能会跨越超过一行.

```scheme
(+ (* 3 5) (- 10 6))
19
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
57
```

跟在Python中那样, Scheme表达式可以是原语或者是组合. 数字文字是原语, 而调用表达式是组合形式其内包含任意子表达式. 调用表达式执行程序跟吻合Python的这些地方: 首先操作符以及操作数表达式被执行, 然后将作为运算符的值的函数应用于作为操作数的值的自变量.

在Scheme中的`if`表达式是一种特殊形式, 意味着虽然它看起来在句法上像是一个调用表达式, 但是它具有不同的执行过程. `if`表达式的一般形式是:

```scheme
(if <predicate> <consequent> <alternative>)
```

为了执行一个`if`表达式, 解析器会开始于执行表达式的`<predicate>`的部分. 如果`<predicate>`运行后得到真值, 解析器之后就会执行`<consequent>`部分然后返回它的值. 否则它会执行`<alternative>`并返回它的值.

数值可以用熟悉的比较操作符来进行比较, 但是前缀符号也一样被用在这个例子中:

```scheme
(>= 2 1)
true
```

布尔值`#t`(或者真)以及`#f`(或者假)在Scheme中可以以特殊的布尔形式来进行组合, 也具有跟Python类似的运行过程.

> - (and `<e1>...<en>`) 解析器一次执行一个表达式`<e>`, 以从左到右的顺序, 如果任何一个`<e>`执行的结果为假, 那么`and`表达式的结果就为假, 而剩下的`<e>`表达式都不会执行, 如果所有的`<e>`执行的值都为真, 那么`and`表达式的值就为最后一个(表达式)的值.
> - (or `<e1>...<en>`) 解析器一次执行一个表达式`<e>`, 以从左到右的顺序, 如果任何`<e>`执行得到的值为真值, 那么这个值就会作为`or`表达式的值被返回, 而剩下的`<e>`表达式不会执行. 如果所有的`<e>`执行都得到假值, 那么`or`表达式的值就为false.
> - (not `<e>`) 当`<e>`执行为假时`not`表达式的值为真, 否则的话就为假.

#### 3.2.2 定义

值可以用`define`这种特殊形式来进行命名:

```scheme
(define pi 3.14)
(* pi 2)
6.28
```

新的函数(在Scheme中称为过程)可以使用`define`的第二个特殊形式的版本来定义. 例如, 定义一个平方, 我们编写:

```scheme
(define (square e) ( * x x))
```

过程定义的一般形式是:

```scheme
(define (<name> <formal parameters>) <body>)
```

`<name>`是一个跟在环境中定义的过程相关联的符号. `<formal parameters>`是用在过程内部的各个名称, 这些名称与过程中的参数相对应. `<body>`是一个表达式, 当形式参数被实际参数替换来进行调用时它会返回过程调用后的值. `<name>`以及`<formal parameters>`以括号为分组, 就像对被定义的过程进行实际调用一样.

有了平方的定义之后, 我们现在可以在调用表达式中使用它.

```scheme
(square 21)
441

(square (+ 2 5))
49

(square (square 3))
81
```

用户定义的函数可以接受多个参数以及包含特殊形式:

```scheme
(define (average x y)
  (/ (+ x y) 2))

(average 1 3)
2

(define (abs x)
    (if (< x 0)
        (- x)
        x))

(abs -3)
3
```

Scheme支持具有与Python相同的词法作用域规则的本地定义. 下面, 我们使用嵌套定义以及递归来定义一个迭代过程去计算平方根:

```scheme
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
(sqrt 9)
3.00009155413138
```

匿名函数是使用`lambda`特殊形式来创建的, `lambda`是用来创建过程的方式跟`define`一样, 除了不需要为过程指定名称:

```scheme
(lambda (<formal-parameters>) <body>)
```

这种结果过程跟用`define`创建过程用得一样多. 唯一的不同是它没有跟环境中的任何一个名称相关联. 实际上, 下面的表达式是一样的:

```scheme
(define (plus4 x) (+ x 4))
(define plus4 (lambda (x) (+ x 4)))
```

就像任何具有过程作为它的值的表达式一样, 一个`lambda`表达式可以在调用表达式内用作一个操作符:

```scheme
((lambda (x y z) (+ x y (square z))) 1 2 3)
12
```

#### 3.2.3 复合值

数据对在Scheme中是内建的. 由于一些历史原因, 数据对是由`cons`这个内建函数来创建的, 同时通过`car`以及`cdr`来访问数据对中的元素:

```scheme
(define x (cons 1 2))

x
(1 . 2)

(car x)
1

(cdr x)
2
```

递归列表同时也使用数据对来内建到了语言当中. 一个特殊的值, 其表示为`nil`或者`'()`表示一个空的列表. 一个递归列表的值是通过放置它的元素到括号内, 并以空格分隔渲染得到的:

```scheme
(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
(1 2 3 4)

(list 1 2 3 4)
(1 2 3 4)

(define one-through-four (list 1 2 3 4))

(car one-through-four)
1

(cdr one-through-four)
(2 3 4)

(car (cdr one-through-four))
2

(cons 10 one-through-four)
(10 1 2 3 4)

(cons 5 one-through-four)
(5 1 2 3 4)
```

一个列表是否是空的可以使用原语`null?`来判断. 使用它, 我们可以为计算`length`以及选择元素来定义标准的序列操作:

```scheme
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define (getitem items n)
  (if (= n 0)
      (car items)
      (getitem (cdr items) (- n 1))))
(define squares (list 1 4 9 16 25))

(length squares)
5

(getitem squares 3)
16
```

#### 3.2.4 符号数据

到目前为止我们使用的所有的组合数据对象最终都是由数字来组成的. Scheme的一个强项是与作为抽象符号的数据进行工作.

为了去操作符号我们的语言需要一个新的元素: 能对数据对象进行引用. 假设我们想要构造一个列表`(a, b)`. 我们不可以通过`(list a b)`这样来进行构造, 因为这个表达式会构造一个具有值为a跟b的列表而不是符号a跟b本身. 在Scheme中, 我们通过在符号a以及b的前面加上一个单引号来引用符号a以及b而不是它们的值.

```scheme
(define a 1)
(define b 2)

(list a b)
(1 2)

(list 'a 'b)
(a b)

(list 'a b)
(a 2)
```

在Scheme中, 任何为运行的表达式都被称为引用. 这种引用概念派生自经典哲学中事物之间的区分, 例如一个狗, 它在跑动并吠叫, 同时"狗"这个名称是一个用来指定这样的事物的语言结构. 当我们用引号来使用"狗"这个名称时, 我们不是在引用某个特定的狗而是这个字本身. 在语言层面上, 引号允许我们谈及语言本身, 因此它在Scheme中是这样的:

```scheme
(list 'define 'list)
(define list)
```

引号同样允许我们去输入一个复合对象, 使用列表的常规打印表示:

```scheme
(car '(a b c))
a

(cdr '(a b c))
(b c)
```

完整的Scheme语言包含其他的特性, 例如可变操作, 向量以及映射等. 然而, 到目前为止我们介绍了的子集已经提供给我们丰富的函数式编程语言的能力来实现许多到目前为止在本文中讨论的想法.

#### 3.2.5 龟图

本章节中, 龟形图作为Scheme的伴随实现, 来说明作为图标开发语言(另一种Lisp方言)的一部分开发环境. 这个龟开始于画布的中间, 根据程序来进行移动以及转动, 同时随着它的移动来进行画线. 虽然发明这个龟图只是用来让儿童参与编程行为, 但是它对于高级程序员来说依然是一个引人入胜的图形工具.

在课程当中的任何时候执行的Scheme程序, 这个龟都在画布中具有一个位置以及标题. 单一参数程序例如, `forward`以及`right`会修改龟的位置以及标题. 通用的程序具有缩写: `forward`也可以被叫做`fd`, 等等. 在Scheme中的特殊形式的`begin`允许单一表达式来包含多个子表达式. 这种形式对于多个命令的发出是有用的:

```scheme
> (define (repeat k fn) (if (> k 0)
                  (begin (fn) (repeat (- k 1) fn))
                  nil))

> (repeat 5
      (lambda () (fd 100)
            (repeat 5
                (lambda () (fd 20) (rt 144)))
            (rt 144)))
nil
```

![start][7]

龟程序的完整曲目同样也作为[龟型库模块][6]内建在了Python中.

作为最后的一个例子. Scheme可以通过以一种异常紧凑的形式来使用它的龟图表现出递归绘图. 谢尔宾斯基三角形是一种分形, 通过将每个三角形绘制为三个相邻的三角形同时在包含它们的三角形的底部的中点处具有顶点. 这可以通过Scheme程序来绘画一个有限的递归深度的图形:

```scheme
> (define (repeat k fn)
    (if (> k 0)
      (begin (fn) (repeat (- k 1) fn))
      nil))

> (define (tri fn)
    (repeat 3 (lambda () (fn) (lt 120))))

> (define (sier d k)
    (tri (lambda ()
      (if (= k 1) (fd d) (leg d k)))))

> (define (leg d k)
    (sier (/ d 2) (- k 1))
    (penup)
    (fd d)
    (pendown))
```

`trangle`过程是一个一般方法来重复绘画某个过程三次并在每次重复中进行左转. `sier`过程需要一个长度`d`以及一个递归深度`k`. 如果深度是1它会绘画一个空的三角形, 否则会绘画一个通过调用`leg`组成的三角形. `leg`过程会通过调用`sier`方法填充前一半的腿部的长度来为谢尔宾斯基三角形绘画一个单一的腿部, 然后通过移动龟图到下一个顶点. 程序`penup`以及`pendown`通过举起笔来进行移动并放下来实现停止绘画的过程. `sier`以及`leg`的相互递归调用的过程返回了它的结果:

```scheme
> (sier 400 6)
```

![Sierpinski's triangle][8]

[1]: https://en.wikipedia.org/wiki/Scheme_(programming_language)
[2]: http://en.wikipedia.org/wiki/Lisp_(programming_language)
[3]: http://en.wikipedia.org/wiki/Fortran
[4]: http://en.wikipedia.org/wiki/Clojure
[5]: http://inst.eecs.berkeley.edu/~scheme/
[6]: http://docs.python.org/py3k/library/turtle.html
[7]: http://composingprograms.com/img/star.png
[8]: http://composingprograms.com/img/sier.png