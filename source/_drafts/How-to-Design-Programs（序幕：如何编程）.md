title: How to Design Programs（序幕：如何编程）
tags:
- 译文
- Design Programs
---

## 序幕：如何编程

在你小时候，父母会教你算术以以及用手指进行简单的演算：“1 + 1 = 2”； “1 + 2 = 3”；等等。然后他们会问“3加2是多少？”然后你会用手来计算。这场景中，父母相当于在编程，我们则负责计算。某种意义上讲，这是就是编程跟运算。

现在时候后转变角色，打开DrRacket并从语言菜单点击“选择语言”。这会打开一个有为“如何设计程序”准备的“教学语言”清单对话框，选择“初学者”（初学者语言，又叫做BSL）然后点击OK来开启DrRacket。完成这个任务后，你可以开始编程了，DrRacket现在变成了一个小孩，可以开始最简单的演算。在DrRacket的最顶端输入

> (+ 1 1)

点击运行，然后结果2会显示在下面那一部分。

![图3：初识DrRacket](/images/How-to-Design-Programs/drracket-plain.png)

这是一个多么简单的程序。你讲DrRacket当做小学生一样问问题，然后DrRacket就为你计算结果。你也可以让DrRacket一次性计算几个问题：

    (+ 2 2)
    (* 3 3)
    (- 4 2)
    (/ 6 2)

当你点击RUN之后，你会在DrRacket的下半部分看见4 9 2 3这几个期望的结果。

让我们放慢一下脚步，然后介绍几个名词。

- 在DrRacket的上半部分叫做定义区域。在这一个区域里，你能创建程序，又叫做编辑程序。一旦你添加名词或者在定义区域改变了一些东西，保存按钮会显示在左上角，当你第一次点击保存的时候，DrRacket会问你要一个保存文件的名字，这样它才能够正确地保存的你的文件。一旦你的定义区域跟你的文件已经进行了关联，就点击保存按钮以确保定义区域的文件内容已经安全保存到文件中。
- 程序有表达式组成。你已经在数学中见到过表达式了。现在，一个表达式由左边是一个“(”中间是一个纯数字或者其他东西最右边是一个“)”号，DrRacket会对括号之间的表达式覆盖一层阴影。
- 当你点击RUN的时候，DrRacket在定义域运行表达式然后在互动区域展示结果。然后，DrRacket这个你忠实的仆从，在提示(>)处等待你的命令。DrRacket中出现的提示符号代表等待你输入额外的表达式，然后就像运行定义区域中的表达式一样处理你的输入。

```
> (+ 1 1)
2
```

在提示处输入表达式，按下你键盘的“return”键或者“enter”键，然后看下DrRacket的响应结果。只要你想，你就可以这样做：

```
> (+ 2 2)
4
> (* 3 3)
9
> (- 4 2)
2
> (/ 6 2)
3
> (sqr 3)
9
> (expt 2 3)
8
> (sin 0)
0
> (cos pi)
#i-1.0
```

让我们仔细看最后的数字。它的“#i”前缀是“我不知道准确的数字所以先用这个（来替代）”或者说是不准确数字的简称。DrRacket很诚实，不像你的计算器或者其他编程系统。当它不知道准确的数字时，它会用特殊的前缀提醒你。稍后，我们会展示给你看关于“计算机数字”的十分奇怪的事实，然后你会十分欣赏DrRacket会发出这样的警告。

现在，你可能会想DrRacket是否能够一次性添加超过两个数字，答案是可以的！事实上，它可以以两种不同的方式实现：

```
> (+ 2 ( + 3 4))
9
> (+ 2 3 4)
9
```

第一个是嵌套运算，就像你从学校学到的。第二个是BSL运算；如果你经常使用括号将运算操作跟数字组合在一起的话，（这个操作）是那么的自然。

在BSL中，每一次你想要用“计算器操作”你需要写下一个开括号，然后是一个你想要的执行的操作，比如说是**+** ,接着是这个操作运行需要的（用空格或者换行符分开的）几个数字，最后，再加上一个闭括号。跟在操作符之后的称之为操作数。嵌套运算意味着你可以用一个表达式作为一个操作数，这就是为什么：

```
> (+ 2 (+ 3 4))
9
```

这是一个正常的程序，只要你喜欢，你可以随时这样做：

```
> (+ 2 (+ (* 3 3) 4))
15
> (+ 2 (+ (* 3 (/ 12 4)) 4))
15
> (+ (* 5 5) (+ (* 3 (/ 12 4)) 4))
38
```

除了你的忍耐力，这里没有对嵌套（层数）做限制。

当然，在DrRacket为你计算时，它用的规则是你熟知且喜欢的数学规则。就像你一样，它可以判定加法运算的结果，只要所有的操作数是纯数字。如果一个操作数是一个括号包裹的运算表达式，即某些以`(`以及操作符开始的表达式，那么它将最先决定这个嵌套表达式的结果。而DrRacket不像你那样需要判断哪个表达式应该先计算，因为第一个规则就是唯一的一个需要应用的规则。

DrRacket便利的代价在于它的括号是具有含义的。你作为一个编程的人，必须要输入完所有这些括号，而且不能输入过多的括号。例如，有时候额外的括号对于的数学老师来说是可以接受的，但这不属于BSL（可接受的）范畴。`(+ (1) (2))`这个表达式含有过多的括号，DrRacket会告诉你说处在无不确定项的情况：

```
> (+ (1) (2))
function call: expected a function after the open parenthesis, found a number
```

虽然，一旦你适应了BSL编程，你会发现它根本不是一个（要付出的）代价，首先如果操作符很自然地就允许这样做，你可以用一个操作符一次性操作几个操作数。

```
> (+ 1 2 3 4 5 6 7 8 9 0)
45
> (* 1 2 3 4 5 6 7 8 9 0)
0
```

如果你不知道一个操作符能操作几个操作数，输入一个例子到互动区域里面，然后点击“return”；DrRacket让你知道（例子）是否能工作以及是如何工作的。或者用帮助菜单来看文档。第二，当你会看其他人写的程序时，你永远没必要知道哪一个表达式会先运算。括号以及嵌套会马上告诉你。

在这方面看来，编程是写下可理解的算术表达式，然后计算就是去确定它的值。在DrRacket中能够十分轻易地探索这方面的编程以及计算。

---

## 算术和算法

如果编程仅仅是跟数字与算术相关，那它就会像是数学一样无趣。幸运的是，我们还可以对数字以外的更多东西进行编程：文本，真假，图片以及更多。

在BSL中你需要知道的第一件事是文本是指在双引号`"`包裹下的一串任意键盘字符组成的序列。我们把它叫做字符串。因此，`"hello world"`就是一个准确的字符串；然后当DrRacket对字符串求值的时候，它就仅仅是将它打印到互动区域里面去，就像一个数字一样：

```
> "hello world"
"hello world"
```

实际上，很多人的第一个程序就是显示这个字符串。

其次，你需要知道的是DrRacket除了能对数字做算术外，也能对字符串做算术运算。所以这里有两个字符串算术的事例展示：

```
> (string-append "hello" "world")
"helloworld"
> (string-append "hello " "world")
"hello world"
```

就像是`+`，`string-append`是一个操作符；它通过将第二个字符串添加到第一个字符串的后面来生成一个新的字符串。如第一个互动展示那样，它就像字面上说的那样做了，没有在两个字符串之间添加任何东西：没有空格，没有逗号，什么都没有。因此，如果你想要“hello world”这个短语，实际上你需要在这两个词之间任意一个上添加一个空格；这就是第二个互动展示上显示的东西。当然，最自然的用这两个词创造短语的方法是输入：

`(string-append "hello" " " "world")`

因为`string-append`就像`+`一样，可以像预期那样操作多个操作数。

除了附加字符串外，你还可以做其他更多的事情。你可以从字符串中提取其中某部分；翻转字符串序列；将所有字符渲染成大写（或者小写）；将字符串的左边和右边的空格去掉；等等。而最好的是，你无需记住任何这些东西，如果你需要知道你能对字符串做什么，只需要看帮助文档就好。

如果你查看BSL的原始操作符，你会看到原始操作符（有时也叫预定义或者內建操作符）能够处理字符串然后返回数字：

```
> (+ (string-length "hello world") 20)
31
> (number->string 42)
"42"
```

也有操作符能够将字符串转化成数字：

```
> (string->number "42")
42
```

如果你期望“forty-two”或者显示其他更聪明的行结果，很抱歉，这真的字符串计算器返回的不是你所期望的那样。

最后的的表达式带来了一个问题，比如，如果一个人用`string->number`来处理不是数字的包裹在字符串引号内的字符串会怎么样。在这个情况下，这个操作会返回完全不同类型的结果：

```
> (string->number "hello world")
#false
```

这既不是一个数字又不是一个字符串；这是一个布尔值。不像数字或者字符串，布尔值只有两种数值：`#true`以及`#false`，第一个是真值，第二个是假值。即使这样，DrRacket也有几个操作符来对布尔值进行组合：

```
> (and #true #true)
#true
> (and #true #false)
#false
> (or #true #false)
#true
> (or #false #false)
#false
> (not #false)
#true
```

然后你得到操作显示的结果。（不知道什么是`and`，`or`以及`not`运算？很简单：`(and x y)`如果x跟y都是真的，结果就是真的；`(or x y)`x或者y里面有任意一个是真的或者全部是真的，结果就是真的。最后`(not x)`当x是假的时候，结果就是真的。

尽管不可能将一个数字转换成布尔值，但是将两个数字转换成布尔值是十分必要的：

```
> (> 10 9)
#true
> (< -1 0)
#true
> (= 42 9)
#false
```

停停停停！试下输入这些：`(>= 10 10), (<= -1 0), 跟(string=? "design" "tinker")`。最后一个跟之前又完全不同了，但是不用担心，你能做到的。

这些漂浮在身边的新的数据以及操作符，是的，数字，字符串跟布尔值就是数据，很容易就让我们忘记一些基本的东西，像嵌套运算：

```
(and (or (= (string-length "hello world")
            (string->number "11"))
         (string=? "hello world" "good morning"))
     (>= (+ (string-length "hello world") 60) 80))
```

这个表达式的结果是什么？你是怎么想的？全部是你自己计算的？还是你输入到DrRacket的互动区域然后点击“return”键？如果你是做了后者，你会认为你自己知道怎么做吗？毕竟，如果你不能预测DrRacket中小的表达式做了什么，那么当你提交大的任务的时候，你可能也不愿意相信它的运算结果。

在我们向你展示收入那么是真正的编程之前，让我们讨论一下一个增添数据趣味的东西，当你插入一个图片到互动区域并点击回车键的时候，像这样：

\> ![插入图片][rocket]

DrRacket会回显一个图片。跟其他编程语言相比较，BSL能理解图片，同时支持对图片进行运算就像支持数值或者字符串的运算一样。简单来说，你的程序能够对图片进行计算，同时你也能够在互动区域上做这些事情。此外，BSL程序员会创造其他人也觉得有用的库，就像其他程序语言的程序员一样。运用这些库就像是用新的词语扩大了你的词汇量或者你的编程词汇表新增了原始函数一样。我们将这些库称作教学包，因为它们有利于教学。

一个重要的库 —— **2htdp/image** 支持对图片的宽高进行计算：

(* (image-width ![插入图片][rocket]) (image-height ![插入图片][rocket]))

一旦你添加这个库到你的程序后，点击RUN会得到 **1176** 这个结果，因为这是这个图片宽高相乘的结果：28 × 42

你没有必要用Google去找图片然后在菜单中找到"Insert"来插入它们到DrRacket程序中，你也可以命令DrRacket来从头创建简单的图片：

`> (circle 10 "solid" "red")`

![红色的圆][red-circle]

`> (rectangle 30 20 "outline" "blue")`

![蓝色方框][blue-rectangle]

当结果是图片的时候DrRacket会画出结果，但是BSL程序处理图片数据就像处理数字一样。尤其是，BSL能够进行合并图片的操作，就像它对数字有加法操作，对字符串有拼合操作一样。

```
> (overlay (circle 5 "solid" "red")
           (rectangle 20 20 "solid" "blue"))
```

![拼合图片][overlay-picture]

用相反的顺序覆盖这些图片会得到实心的蓝色长方形：

```
> (overlay (rectangle 20 20 "solid" "blue")
           (circle 5 "solid" "red"))
```

![实心长方形][revert-overlay]

停下来，并思考一会儿这最后的结果

就像你看到的，overlay就更像是string-append而不是+号，但是它做加这个操作的时候就像string-append一样“加上”字符串以及像+号一样加上数字。下面是相关想法的另一个事例：

```
> (image-width (square 10 "solid" "red"))
10
> (image-width
    (overlay (rectangle 20 20 "solid" "blue")
             (circle 5 "solid" "red")))
20
```

这些DrRacket的互动操作没有描画任何东西，它仅仅只是测量图片的宽度。

另外两个重要操作：[empty-scene][empty-scene]以及[place-image][place-image]，第一个是用来创建场景的，一个特殊的方形。第二个用来放置一个图片到这样的一个场景中：

```
(place-image (circle 5 "solid" "green")
             50 80
             (empty-scene 100 100))
```

然后你就会得到这样的一个图片

![scene][scene]

就像你从图片中看到的那样，左上角的就是原点（或者说(0, 0)），不像数学中那样，y轴是向下测量的，而不是向上。否则，图片不会像你预期那样一个绿色的实心圆在坐标(50, 80)在一个100乘100的空心方形上。

让我们再来总结一下，编程其实是写下一些算术表达式，但是你不在被限制为只能用无趣的数字。在BSL语言中，算术是数字、字符串、布尔值甚至是图片的算术。而尽管计算依然意味着确定表达式的值，除了该值可以是一串字符，一个数字，一个布尔值或者一张图片。

现在，我们已经准备写程序来让火箭飞起来了。

---

## 输入与输出

到目前位置你写的程序都是很无聊的，你写下一个表达式或者几个表达式；点击RUN；看到结果。如果你再点击一次RUN，你会看到完全一样的结果，实际上，你可以随时随地点击RUN然后相同的结果会被展示出来。简而言之，你的程序就像是一个在计算的袖珍计算器一样，除了计算的数据可以是所有类型的数据而不仅仅是数字。

这是好消息也是坏消息，是好消息是因为程序设计以及计算就应该是用计算器的自然推广。说它是坏消息是因为程序设计的目的是处理大量的数据然后得到大量不同的结果，且或多或少会有相同的计算。（它也应该能够快速地计算出这些结果，至少是比我们快的）那就是说，在你知道如何进行程序设计之前你需要学习更多。然而你并不需要担心：你拥有的关于数字、字符串、布尔值以及图片的运算的知识已经几乎让你能够编写一个创造电影的程序了，而不仅仅是那些傻傻的在某处显示“hello world”的程序了。而这就是我们接下来要进行的内容。

以防你不知道，一个电影就是一系列图片快速且按顺序地展示。如果你的代数老师已经知道了你上一小节看的关于“图像的运算”的知识，你就可以用代数来创建一个电影而不是无趣的数字序列。好了，下面就是这样的一个表格：

    x = 1   2   3   4   5   6   7   8   9   10
    y = 1   4   9   16  25  36  49  64  81  ?

你的老师现在会叫你填补上面的空缺处，就是将“?”的地方换成一个数字

事实证明，做一个视频比完成一个像上面那样的表要复杂多了。实际上，所有的东西都是跟这个表有关的。

![figure1][figure1]

具体来说，你的老师会叫你来把第四、第五幅图画出来以及之后的1273张图，因为视频就是一大堆的图，每一秒钟就需要20到30张图，因此你需要1200张图或者1800张图才能制作一分钟的电影。

你也许能回想起来，你的老师不仅会要一些序列中的第四或第五张，还可能会要求按一个给定的x找到序列中的特定项。在一个数值事例中，一个老师想好看到的是这样的结果：

![figure2][figure2]

如果你插入数值1，2,3直到x，然后得到数值1,4,9直到y，就像之前的表格上看到的那样。对于图片的序列而言，你可以认为是下面这样：

    y = the image that contains a dot x2 pixels below the top.

关键是这一行不仅仅是表达式，也可以是函数。

乍一看，函数就像是表达式，总是有一个y在左边，紧跟着一个等号，然后是一个表达式。然而他们不是一个表达式。那些你在学校看到的关于函数的功能符号完全是误导人的。因此在DrRacket中，你写的函数有些不同。

    (define (y x) (* x x))

上面的[define][define]的意思是说“认为y是一个函数”，就像一个表达式，计算一个值。而一个函数的值依赖于一些称作输入的值，我们用`(x y)`来表示。由于我们不知道输入是什么，我们用一个自定义的名称来代表输入的值。按照数学上的传统，这里我们用x来协助表示未知输入；但是不就，我们就应该用各种名称了。

第二部分表示你必须要提供一个数字（在这里是x），来为y定义一个特殊值。当你这样做的时候，DrRacket会替换x的值到关联的函数的表达式中。在这里表达式是`(* x x)`。一旦x被替换为一个值，比如说1，DrRacket就能计算这个表达式的值，也叫作函数的输出

点击RUN会看到没有任何事情发生。在互动区域上没有展示任何东西。在DrRacket上没有任何地方有改变。就好像你没有完成任何东西一样。但是你确实完成了一些东西，实际上你定义了一个函数并通知DrRacket关于它的存在。事实上，下面的函数已经准备好为你所用了，输入：

    (y 1)

在互动区域的提示符处就能看到出现一个1作为反馈。`(y 1)`在DrRacket调用了一个函数应用。试下：

    (y 2)

然后看到一个4被输出。当然，你可以在定义区域输入下面所有的表达式然后点击RUN：

    (define (y x) (* x x))
    (y 1)
    (y 2)
    (y 3)
    (y 4)
    (y 5)

在响应中，DrRacket会展示：1 4 9 16 25，就是表格中的数字。现在来确定确实的条目。

对你而言所有的这些东西意味着函数提供了相当经济实用的方式来用一个表达式去计算大量有趣的值。实际上，程序就是一个函数，一旦你深入理解了一个函数，你就几乎知道了所有关于程序的东西。考虑到它们的重要性，让我们再次概括一下目前我们知道的关于函数的所有东西：

- 第一，

    (define (FunctionName InputName) BodyExpression)

你已经知道了，上面是一个函数的定义，因为它以一个“[define][define]”关键词开头。它基本上由三部分组成：两个名称跟一个表达式。第一个名称是函数名，在你想要应用函数的时候你需要用到它。第二个名称叫做参数，代表函数的输入，它是未知的，直到你应用函数的时候才能确定。而表达式，也就是函数体，对函数的特定输入进行计算并输出。

- 第二，

    (FunctionName ArgumentExpression)

这是一个函数的应用例子，第一部分告诉DrRacket你希望用哪一个函数，第二部分是你希望应用的函数的输入值。如果你已经看过Windows或者Mac的手册，它可能会告诉你说这个表达式“启动了”被称为FunctionName的“程序”而它会去处理作为输入的ArgumentExpression。就像所有的表达式那样，后者可能是一段纯粹的数据或者是更深嵌套的表达式。

函数还能够以数字以外的数据作为输入，同时也能输出所有类型的数据。我们的下一个任务是用函数创建一个来模拟第二个表格（就是那个带有颜色点的图片那个），就像第一个函数模拟的数值表。由于从一个表达式中创建图像不像你从高中中知道的东西，所以让我们先从简单的地方开始，你还记得[empty-scene][empty-scene]吗？我们在上一小节简短地提及到它。当你向互动区域输入下面的表达式：

![figure3][figure3]

DrRacket生产出一个空心的矩形，也叫作场景。你可以用[place-image][place-image]来添加一张图片到场景中，

![figure4][figure4]

将这个火箭想象成一个物体，就像是从你上面的数学班中提到的那个表格里面的点一样。区别是火箭更为有趣。

接下来，你需要让火箭降落，就像是上面表格中的点一样。在前一节中，你知道了如何通过[place-image][place-image]提供的功能来增加y轴从而实现这个效果。

![figure5][figure5]

现在所有需要的只是简易地生产很多的场景，并将所有的场景按照顺序展示它们。

![figure6][figure6]

当然，第一个目标可以用一个函数实现；具体看图4。是的，这就是一个函数定义。在这里没有用y，它用了picture-of-rocket作为函数名，一个可以马上告诉你函数会输出什么的名称：一个有着火箭的图片。作为x的替代，这里用了height作为参数名，一个暗示是自身是数字，并告诉函数如何摆放火箭的名称。函数体就是像我们刚刚进行实验的一系列表达式，除了它用height来替代了数字。我们能够十分容易地用函数来创建这样的图片：

    (picture-of-rocket 0)
    (picture-of-rocket 10)
    (picture-of-rocket 20)
    (picture-of-rocket 30)

在DrRacket的定义区域或者互动区域尝试这些程序；都能创建预期的场景。

第二个目标要求了解一个额外的在2htdp/universe函数库中的原始操作符：[animate][animate]。然后点击RUN以及输入下面的表达式：

`> (animate picture-of-rocket)`

停下来并注意到，参数表达式是一个函数，现在先不要担心用函数作为参数的问题；它能在[animate][animate]中好好工作，但是目前先不要急着尝试去定义像[animate][animate]这样的函数先。

一旦你点击“return”按钮，DrRacket会运行表达式；但是它不会展示结果，甚至也没有任何提示。它会打开其他的窗口（称为画板）然后启动一个时钟，周期为每秒28次。每一次周期，DrRacket将函数调用后过去的时间周期数运用到picture-of-rocket中。这些函数调用的结果会呈现在画板中，然后画板就显示动画的效果。仿真会一直运行直到你关闭窗口。在那时候，[animate][animate]会返回运行的周期数。

那么问题来了，窗口中的图片是哪里来的？一个简单的解释是[animate][animate]用1，2，3等等来运行它的操作数，然后展示图像结果。完全的解释是：

- [animate][animate]启动一个时钟，然后计算周期数；
- 而每一秒的周期数是28；
- 每一个周期内，[animate][animate]将当前的周期数运用到picture-of-rocket函数中；
- 然后这个应用产生的场景就被展示在画板上。

这意味着火箭最先出现的位置是高为0的地方，然后是1，然后是2，等等。这就解释了，为什么火箭会在画板的顶端向底端降落了。也就是说，我们的3行程序在3.5秒内创建了大概100张照片，然后快速地创建火箭降落到地面的效果。

所以，这是你在这一节所学到的内容。函数是十分有用的，因为它们能够在短时间内处理大量的数据，你可以手动运行一些选择性的输入来保证函数有正确的输出，这叫做测试函数。或者，在DrRacket中能够运行在某些库的帮助下在一大堆的输入中运行函数；当你这样做的时候，你只是在运行函数而已。实际上，DrRacket能够在你按下键盘的按钮时运行函数或者在你操作电脑的鼠标的时候。要想知道是怎样做的，那就继续阅读吧。是什么触发函数的运行并不重要，但是要记住的是（简单）程序只是一个函数而已。

---

## 计算的多种方法

当你运行前一小节的picture-of-rocket程序时，那火箭最终消失在底部。这看起来是十分愚蠢的，火箭在老科幻电影里面是不会沉入地下的；它们会优雅地落在底部，影片应该在这里就结束掉。

这个思想暗示计算过程应该根据不同的情况而变化。在我们的例子中，picture-of-rocket程序应该在火箭还在飞行的时候按照“原样”运行。然而，当火箭底部触及到画板的底部时，程序应该停止让火箭下沉得更深。

在某种意义上讲，这个思想对你而言应该是新的。甚至你的数学老师也会定义一个区分不同的情况的函数。

![figure7][figure7]

sign函数对输入进行三种区分：大于零，等于零，小于零。根据输入得到的结果分别为：+1，0，-1。

你可以在DrRacket中用[cond][cond]条件表达式来毫不费力地定义一个这样的函数

```
(define (sign x)
    (cond
        [(> x 0) 1]
        [(= x 0) 0]
        [(< x 0) -1]))
```

在你点击RUN后，你就可以跟sign函数互动，就像跟其他函数一样：

```
> (sign 10)
1
> (sign -5)
-1
> (sign 0)
0
```

一般来说，一个条件表达式是有一个模板的

```
(cond
  [ConditionExpression1 ResultExpression1]
  [ConditionExpression2 ResultExpression2]
  ...
  [ConditionExpressionN ResultExpressionN])
```

也就是说，一个[cond][cond]条件表达式包含多行需要的条件行。每一行含有两个表达式：左边的通常叫做条件，右边的叫做结果；偶尔我们也会用问题与解答来表示。要运行一个[cond][cond]表达式，DrRacket会先运行第一个条件表达式，**ConditionExpression1**。如果它产生的值为`#true`，DrRacket用**ResultExpression1**来替代cond表达式，
运行这个替代后的表达式然后用返回的值作为整个条件表达式的值。如果运行**ResultExpression1**返回的结果是`#false`，DrRacket放弃第一个条件行然后从新开始。如果所有的条件表达式运行结果都为`#flase`，DrRacket返回一个错误信号。

有了这些知识，现在你能修改课程里面的仿真程序。目标是不要让火箭下降到100乘60的场景的地面上。由于picture-of-rocket函数需要比对场景的高度来决定在哪放置火箭，只需要一个简单的跟给定的最大高度进行对比的测试就可以了。

看图五来修正函数的定义。定义名为picture-of-rocket.v2来区分两个版本。使用不同的名字，能够允许我们在互动区域内同时使用这两个函数以及来比较结果。这里是原来的程序的运行结果：

![figure8][figure8]

这里是第二个结果

![figure9][figure9]

无论你给picture-of-rocket.v2什么数字，如果这个数字超出100，你都会得到一个一样的场景，特别地，当你运行

`> (animate picture-of-rocket.v2)`

火箭在停止之前会下沉到地面的一半。

![figure10][figure10]

将火箭着陆到这么远的地方是很丑的。那么接下来，你也知道如何修复程序的这个方面（的错误）了。就像你看到的那样，BSL知道关于图片的运算。当[place-image][place-image]添加一个图片到场景中时，它会用图片的中心点来代表整个图片，即使图片具有非常大的高度以及非常大的宽度。你可能还记得，你可以用[image-height][image-height]来测量图片的高度，这个函数在这里显得很方便，因为你真的想要让火箭飞起来，直到它的底部触及地面。

将（需要的）一个个地组合在一起，现在你可以弄明白下面的

![figure11][figure11]

才是你想要的正确的火箭停靠距离。你可以通过直接跟程序互动来明白这些东西。或者你也可以在互动区域直接用你的图片运算进行实验。

这里是第一个尝试：

![figure12][figure12]

现在将上面的的程序的第三个参数换成：

![figure13][figure13]

停一下，并进行实验，哪一个结果你更喜欢？

![figure14][figure14]

当你跟着这些来想并进行实验的时候，以最终能够得到图六中的程序。给定一些代表火箭高度的数字，它首先测试火箭的底部高度是否在地面上。如果是，它将火箭放到跟之前一样的位置上，如果不是，它将这张火箭图片进行移动知道它的底部接触到地面。

---

## 一个程序，多个定义

现在假设你的朋友看了你的动画，但是他不喜欢你画板的大小，他们可能要求要用200乘400大小场景的版本。这个简单的要求使得你将五个地方的100换成了400，将其他两个地方的60换成了200。那意味着画板中间的50就不用说了。

停一下，在你阅读之前，尝试一下这样做这样的修改，你就能知道这样做对于一个只有五行的程序而言是多么的困难。当你阅读的时候，要记住一个真正的程序会包含50,000或者500,000或者5,000,000行的程序代码。

在一个理想的程序中，一个小的请求，例如是改变画板的大小，应该只需要进行同等程度的小改动就好。要做到这样简单需要用到BSL的[define][define]工具。除了可以定义一个函数，你也可以采用常量定义，用来将一些名称指定为常量。一般的常量定义模板是十分直截了当的：

`(define Name Expression)`

所以，举例说，如果你写下

`(define HEIGHT 60)`

在你的程序中，你是表明HEIGHT一直代表数字60。而这样定义的意义也是你所期望的。无论任何时候，DrRacket在计算过程中遇到HEIGHT，它都会用60来代替。

![figure15][figure15]

现在看一下图七的代码，它实现了这个简单的改变，也命名了火箭图片，复制程序到DrRocket中；然后点击RUN，运行接下来的操作：

`> (animate picture-of-rocket.v4)`

确认程序仍然具有先前的功能。

图七的程序由四个定义组成：一个函数定义以及三个常数定义。数字100以及60一共出现了两次，一次是在一次是赋值给WIDTH时，一次是赋值给HEIGHT时。你可能也注意到了，


[rocket]:     /images/How-to-Design-Programs/rocket.png
[red-circle]: /images/How-to-Design-Programs/pict_2.png
[blue-rectangle]: /images/How-to-Design-Programs/pict_3.png
[overlay-picture]: /images/How-to-Design-Programs/pict_4.png
[revert-overlay]: /images/How-to-Design-Programs/pict_5.png
[scene]: /images/How-to-Design-Programs/pict_6.png
[figure1]: /images/How-to-Design-Programs/pict_7.png
[figure2]: /images/How-to-Design-Programs/pict_8.png
[figure3]: /images/How-to-Design-Programs/pict_9.png
[figure4]: /images/How-to-Design-Programs/pict_10.png
[figure5]: /images/How-to-Design-Programs/pict_11.png
[figure6]: /images/How-to-Design-Programs/pict_12.png
[figure7]: /images/How-to-Design-Programs/pict_13.png
[figure8]: /images/How-to-Design-Programs/pict_14.png
[figure9]: /images/How-to-Design-Programs/pict_15.png
[figure10]: /images/How-to-Design-Programs/pict_16.png
[figure11]: /images/How-to-Design-Programs/pict_17.png
[figure12]: /images/How-to-Design-Programs/pict_18.png
[figure13]: /images/How-to-Design-Programs/pict_19.png
[figure14]: /images/How-to-Design-Programs/pict_20.png
[figure15]: /images/How-to-Design-Programs/pict_21.png
[empty-scene]: http://docs.racket-lang.org/teachpack/2htdpimage.html#%28def._%28%28lib._2htdp%2Fimage..rkt%29._empty-scene%29%29
[place-image]: http://docs.racket-lang.org/teachpack/2htdpimage.html#%28def._%28%28lib._2htdp%2Fimage..rkt%29._place-image%29%29
[define]:      http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29
[animate]: http://docs.racket-lang.org/teachpack/2htdpuniverse.html#%28def._%28%28lib._2htdp%2Funiverse..rkt%29._animate%29%29
[cond]: http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._cond%29%29
[image-height]: http://docs.racket-lang.org/teachpack/2htdpimage.html#%28def._%28%28lib._2htdp%2Fimage..rkt%29._image-height%29%29
