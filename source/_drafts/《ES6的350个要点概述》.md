title: 【译】ES6的350个要点概述
tags:
- ES6
- JavaScript
- Front End
---

## 前言：

我的[深入ES6][3b219273]系列由24篇覆盖了未来ES6中大多数语法以及特性的改变的文章组成。这篇文章的目的是总结所有的要点，提供给你ES6中最切实可行的建议，从而让你可以快速开始。我已经在深入ES6系列文章中提供链接，因此你可以轻易地深入到你感兴趣的主题。

听说你们喜欢要点，所以我写了这篇包含数百要点的文章。在开篇这里有覆盖所有主题的目录。显然，里面有你要的要点。需要注意的是，如果你想要让这些概念深入脑海的话，你将需要很多的时间去通过[深入系列][71be0617]学习相关概念同时还需要练习，试验这写ES6的代码。

## 目录
- [介绍][dd1633bc]
- [工具][d6dc887d]
- [解构赋值][afd90b94]
- [展开运算符以及不定参数][e8b6fbb4]
- [箭头函数][e64231bf]
- [模板字符串][bf729279]
- [对象字面值][75c9caa5]
- [类][006355ad]
- [Let以及Const][d3c8e7b3]
- [Symbols][d81cc7e9]
- [迭代器][cbef365f]
- [生成器][b70bcc5e]
- [Promises][866870f1]
- [映射][ea91abdd]
- [弱映射][ddd6f844]
- [集合][9d2b75e5]
- [弱集合][9f40009a]
- [代理][8b1f4dfd]
- [反射][92765db6]
- [Number对象][1233f62d]
- [Math对象][cf33277f]
- [Array对象][847ce29d]
- [Object对象][abe180fc]
- [字符串跟Unicode][701a6c35]
- [模块组件][bf072aff]

十分抱歉目录这么长，下面我们开始ES6旅程。

## 介绍

- ES6 - 也叫被称作“和谐”，“es-next”，“ES2015” - 是这门语言最新且已敲定的版本。
- ES6规范最终敲定于2015年的7月（又称：ES2015）
- 未来敲定的版本将会使用ES[YYYY]的命名模式，例如：ES2016对应于ES7
    - 每年发布一个新版本，新特性将会一波接着一波
    - 从ES6最先讨论中，我们大多数还是叫它ES6
    - 从ES2016开始（ES7）我们应该使用ES[YYYY]的模式来称呼新版本
    - 命名方案的最主要原因是想要迫使浏览器厂商尽快更新新的特性到现代浏览器中

## 工具

- 要想让ES6运行，你需要一个JavaScript到JavaScript的转译器
- 转译器具有下列功能
    - 它们允许你将相应语言的最新版本的代码翻译成旧版本的可运行代码
    - 随着浏览器的支持越来越好，我们会将ES2016和ES2017翻译成ES6以及以外版本的代码
    - 我们将会需要更好的来源映射功能
    - 它们是在产品上运行ES6版本语言的最可信任的方式（即使浏览器只支持ES5版本的语言）
- Babel（一个转译器）有一个杀手级特性：阅读友好型输出
- 用[Babel][d6ff4634]去将ES6静态转译为ES5
- 用[babelify][e5a76d8d]将`babel`合并到你的`[Gulp, Grunt, or npm run][4ef399d4]`构建流程当中去
- Node.js`v4.x.x`或者更高版本已经对ES6特性有了像样的支持，感谢V8
- 在任何node的版本中使用`babel-node`，因为它可以将模块转译成ES5
- Babel有蓬勃发展的生态系统，已经支持一些ES2016的特性，同时出了插件进行支持
- 阅读[ES6工具简史][725b291f]

## 解构赋值

- `var {foo} = pony`等于`var foo = pony.foo`
- `var {foo: baz} = pony`等于`var baz = pony.foo`
- 你可以提供默认值，`var {foo='bar'} = baz`相当于`foo: 'bar'`如果`baz.foo`是`undefined`
- 只要你喜欢，你可以拿到尽可能多的属性，可以起别名或者不起
    - `var { foo， bar:baz } = { foo: 0, bar: 1}`将会得到`foo:0 跟baz:1`
- 你可以用多层结构。`var {foo: {bar}} = {foo: {bar: 'baz'}}`会得到`deep: 'baz'`
- 你也可以重命名。`var {foo: {bar: deep}} = {foo: {bar: 'baz'}}`，会得到`deep: 'baz'`
- 如果属性没有找到会像平时一样得到undefined，例如：`var {foo} = {}`
- 多层结构中没有找到属性的话会抛出一个错误，例如：`var {foo: {bar}} = {}`
- 对于数组一样适用，`[a, b] = [0, 1]`得到a: 0和b: 1
- 你可以跳过数组中的元素，`[a, , b] = [0, 1, 2]`，会得到a: 0和b: 2
- 你可以交换两个数而不需要额外的交换参数，`[a, b] = [b, a]`
- 你可以在函数的参数中使用解构赋值的特性
    - 分配默认参数如：`function foo (bar=2) {}`
    - 默认参数也可以是对象如：`function foo (bar={a: 1, b: 2}) {}`
    - 完全解构对象如：`function foo({a = 1, b = 2}) {}`
    - 如果额外的参数没有赋予任何值则提供一个空对象如：`function foo ({a = 1, b = 2} = {}) {}`
- 看[深入了解JavaScript ES6解构][a2ed0e70]

## 展开运算符以及不定参数

- 不定参数是更好的`arguments`
    - 你应在方法签名中定义它如：`function foo (...everything) {}`
    - `everything`是一个传输所有参数到foo函数的数组
    - 你可以在`...everything`前定义一些参数如：`function foo(bar, ...rest) {}`
    - 已命名的参数将被排除在`...rest`之外
    - `...rest`一定要是列表中的最后一个参数
- 展开运算符比魔法更好用，也是一样使用`...`标记语法
    - 避免在`.apply`调用方法时使用，如：`fn(...[1, 2, 3])`跟`fn(1, 2, 3)`一样
    - 更容易的级联`[1, 2, ...[3, 4, 5], 6, 7]`
    - 将类数组对象或可迭代对象投射到数组中，如：`[...document.querySelectorAll('img')]`
    - [解构][98b953ad] 中也十分好用，`[a, , ...rest] = [1, 2, 3, 4, 5]`会得到`a: 1`跟`rest: [3, 4, 5]`
    - 让`new + .apply`毫不费力，`new Date(...[2015, 31, 8])`
- 看[深入ES6展开运算符][1d71b0a3]

## 箭头函数

- 能够用简易的方法来声明一个函数像`param => returnValue`
- 在进行这些操作如：`[1, 2].mpa(x => x * 2)`将变得十分方便
- 有几种方式可供选择，可能需要改掉以前的一些习惯
    - `p1 => expr`对于只有一个参数的函数是可行的
    - `p1 => expr`会隐含地返回所提供的expr表达式
    - 要隐式地返回一个对象可以将其包裹在一个括号`() => ({foo: 'bar'})`里面否则会抛出错误
    - 当你有零个，两个或多个参数的时候是需要括号包裹的`() => expr`或者`(p1, p2) => expr`
    - 在右边通过使用大括号可以声明一个代码块`() => {}`，可以在里面写多句代码
    - 当使用代码块的方式的时候是没有隐式的返回操作的，需要自己主动提供`() => {return 'foo'}`
- 你不可以静态地声明一个箭头函数，但是运行时对大多数方法都能够很好地推断出其名称
- 箭头函数内的词法域绑定在其父级
    - `this`跟父级的`this`是一样的
    - `this`无法通过`.call`，`.apply`或者是类似于反射类型的方法修改
- 看[深入ES6箭头函数][7d961bf4]

## 模板字符串

- 你可以通过" &#x60; "反引号来定义字符串，而不是`"`或者`'`
- 被反引号包裹的字符串称为模板字符串
- 模板字符串可以是多行的
- 模板字符串在里面进行插值操作如：`poofoo.com is ${rating}`，里面的rating是一个变量
- 你可以在插值的地方使用任何有意义的JavaScript表达式如：`${ 2 * 3 }`或者`${foo()}`
- 你可以通过标签模板来修改模板字符串的插值方式
    - 在模板字符串前添加一个fn前缀``` fn`foo, ${bar} and ${baz}` ```
    - fn函数会被立马调用，传进去的参数是`template, ...expressions`
    - `template`实际上是`['foo', ' and ', '']`而`expressions`则是`[bar, baz]`
    - fn返回的结果将会是模板函数的值
    - 有可能用于输入清理或者参数结构等地方
- 将字符串包裹在模板字符串中比用单引号或双引号来包裹字符要好
- 看[深入ES6模板字符串][4446b66f]

## 对象字面值

- 不用像之前那样`{ foo: foo }`，现在可以直接`{ foo }`，这被称作属性值速记
- 属性名可以通过计算得到`{[prefix + 'Foo']: 'bar'}`，如果`prefix: 'moz'`，则会得到`{ mozFoo: 'bar'}`
- 不可以同时使用属性值速记法与属性名计算，`{[foo]}`是无效的
- 对象内的方法是常量，可以用选择更加简约的方式来定义，`{ foo () {} }`
- 看[对象][48860a0e]章节
- 看[深入ES6对象字面值特性][c839b142]

## 类

- 不是传统意义上的类，只是原型继承的语法糖
- 语法跟一般的类定义相似，`class Foo {}`
- 实例方法-`new Foo().bar`通过短[对象字面值][de1ad162]语法来定义，`class Foo { bar() {}}`
- 静态方法-`Foo.isPonyFoo()`需要使用`static`前缀关键字，`class Foo { static isPonyFoo() {} }`
- 构造函数方法`class Foo{ constructor () { /* initialize instance */ } }`
- 通过简单的语法进行原型继承`class PonyFoo extends Foo {}`
- 看[深入ES6类][bca69661]

## Let以及Const

- 在定义变量的时候可以选用`let`或者`const`来代替传统的`var`
- `let`定义的变量是以块作用域的为范围的，而不是以`function`作为词法范围的
- `let`的变量提升是在块内的，而`var`定义的变量提升是在函数内的提升
- "暂时性死区" - 简称TDZ
    - 在块区中`let foo`被定义了之后开始产生
    - 结束于`let foo`声明被放置的用户代码区域（在里面跟变量提升没有关系）
    - 在TDZ中对foo（可以进行访问前）进行访问或分配值将会得到一个错误如：let foo = (() => foo = 'test')();
    - 有助于避免在一个变量被声明期间就进行操作而出现的神奇的bug
- `const`也是块级作用域，有变量提升，也具有TDZ限制
- `const`变量一定要在声明之初就初始化，`const foo = 'bar'`
- 在`const`初始化之后再次定义的话会默默地失败而没有任何提示，（或者在严格模式下会抛出错误）
- `const`一个变量不意味着分配的值不可变
    - `const foo = { bar: 'baz' }`意味着`foo`会总是引用右边的对象
    - `const foo = { bar: 'bar' }; foo.bar = 'boo'`不会抛出错误
- 声明一个同样名字的变量会抛出错误
- 为了修正在传输到某处时重新分配变量而丢失引用带来的错误
- 在ES6，函数是块级作用域的
    - 防止通过变量提升来泄露块级作用域的内容`{let _foo = 'secret', bar = () => _foo;}`
    - 不会破坏通常情况下的用户的代码逻辑，以及常用的用法
- 看[深入ES6的Let，Const和”暂时性死区”（TDZ）][a919c338]

## Symbols

- ES6中新的原始类型
- 你可以这样`var symbol = Symbol()`创建你自己的Symbols
- 你可以添加一个描述用于调试目的像：`Symbol('ponyfoo')`
- Symbols是不可修改而且唯一的，`Symbol(), Symbol(), Symbol('foo') Symbol('foo')`彼此之间都是不一样的
- Symbols是`symbol`类型，因此`typeof Symbol() === 'symbol'`
- 你也可以通过`Symbol.for(key)`创建一个全局的Symbols
    - 如果一个具有key的symbol已经存在，就会直接返回这个Symbol
    - 否则，就会创建一个用key描述的新的Symbol
    - `Symbol.keyFor(symbol)`是一个反向操作的函数，通过传进去一个symbol得到一个返回值key
    - 全局symbols是全局可获得的，或者说是跨域的。单一的注册表用于在运行时访问这些symbols
        - window上下文
        - eval上下文
        - `<iframe>`上下文，`Symbol.for('foo') === iframe.contentWindow.Symbol.for('foo')`
- 下面的也是知名的符号对象
    - 不在全局的注册表，通过`Symbol[name]`访问如：`Symbol.iterator`
    - 跨域，意味着`Symbol.iterator === iframe.contentWindow.Symbol.iterator`
    - 通过规范来定义协议如：[iterable protocol][22406275]对于`Symbol.iterator`
    - 它们实际上在口头术语上不是总所周知的
- 对symbol对象的属性进行迭代是困难的，但并非是不可能的也绝不是私有的
    - Symbols对于所有的预ES6“反射”方法都是隐藏的
    - Symbols能够通过Object.getOwnPropertySymbols来访问
    - 你不会偶然找到它们，但是如果你积极寻找，就能找到它们
- 看[深入ES6 Symbols 对象][9dd4fde8]

## 迭代器

- 迭代器和迭代规则定义了如何去遍历一个对象，不仅仅局限于数组或者类数组对象
- 一个总所周知的是`Symbol`对象用于将迭代器分配到任何对象当中
- `var foo = { [Symbol.iterator]: iterable }`或者`foo[Symbol.iterator] = iterable`
- `iterable`是指具有返回一个具有`next`方法的`iterator`对象的方法
- `next`方法返回一个具有两个属性的对象，分别是`value`和`done`
    - `value`属性指示序列中遍历到的当前值
    - `done`方法指示是否还有更多的遍历对象要遍历
- 一个具有`[Symbol.iterator]`值的对象是可遍历的，因为它们遵从迭代协议
- 一些内建的对象如：Array，String或者arguments以及在浏览器中的NodeList在ES6中也是默认可迭代的
- 可迭代对象能够通过`for...of`方法遍历，如：`for (let el of document.querySelectorAll('a'))`
- 可迭代对象可以融合使用展开运算符像：`[...document.querySelectorAll('a')]`
- 你也可以用`Array.from(document.querySelectorAll('a'))`去将一个可迭代序列融合进数组中
- 迭代器是懒惰的，因此创建一个无限序列在程序中也是有效的
- 需要注意的是不要对无限序列进行展开操作`...`或者用`Array.from`，因为这样会导致无限循环
- 看[深入ES6迭代器][3f0a098b]

## 生成器

- 生成器函数是一个特殊的迭代器，能够用这样的语法来声明`function* generator () {}`
- 生成器函数用`yield`来返回一个元素序列
- 生成器函数也能够用`yield*`去委托其他的生成器函数或者任何可迭代对象
- 生成器函数返回一个同时具有可迭代性以及遵从迭代协议的生成器对象
    - 给定`g = generator()`，g遵从可迭代协议，因为`g[Symbol.iterator]`是里面的一个方法
    - 给定`g = generator()`，g遵从可迭代协议，因为`g.next`是一个方法
    - 迭代器对生成器对象g而言就是生成器本身：`g[Symbol.iterator]() === g`
- 通过`Array.from(g), [...g], for (let item of g)`或者仅仅是用`g.next()`方法获取迭代器对象的值
- 生成器函数的执行是暂停的并且记住最后的位置，有四种不同的情况
    - `yield`表达式返回序列的下一个值
    - `return`声明返回序列的最后一个值
    - `throw`声明会完全暂停生成器
    - 生成器函数在最后会发出信号`{done: true}`
- 一旦g序列结束`g.next()`指示返回`{done: true}`且没有副作用
- 使用生成器能够使得异步流感觉起来像同步流
    - 由用户提供生成器函数
    - 当异步操作发生的时候用户代码会暂停
    - 调用`g.next()`，用户代码取消暂停操作
- 看[深入ES6生成器][798a3399]

## Promises

- 遵从[Promises/A+][28b66792]规范，在ES6标准化之前就已经被广泛实施（如：[bluebird][93b4f36a]）
- Promises的表现得像是一棵树。通过`p.then(handler)`和`p.catch(handler)`来添加枝干
- 用`new Promise((resolve, reject) => { /* resolve */ })`来创建一个新的Promises对象`p`
    - `resolve(value)`回调函数会用提供的`value`完成promise
    - `reject(reason)`回调函数会以`reason`错误来拒绝完成`p`
    - 你可以异步地来调用这些方法，在promise树的更深的层次里面进行阻塞
- 每一次调用`p.then`和`p.catch`就会创建另外一个promise用于继续为已经成为完成态的p继续提供阻塞操作
- Promises开始时是一个等待状态，在__fulfilled__或者__rejected__之后变成完成态
- Promises可以只完成一次，然后它就变成完成态，变成完成态的promises会停止阻塞深层的分支
- 你可以添加任意的promises到你需要添加的任意的分支上
- 每一个分支都会执行`.then`处理函数或者`.catch`处理函数两者中的一个，且只能是一个
- `.then`回调函数可以通过返回一个值来传送前一分支的结果
- `.then`可以返回另外的一个阻塞的promises对象
- `p.catch(fn).catch(fn)`不会像你预期的那样工作-除非你是想要捕捉错误处理器的错误
- `Promise.resolve(value)`创建一个已经处于完成态且提供值的promise对象
- `Promise.reject(reason)`创建一个已经处于失败态且提供原因的promise对象
- `Promise.all(...promises)`创建一个等待所有`...promises`变成完成态或者其中一个变成失败态就变成稳定态的promise对象
- `Promise.race(...promises)`创建一个只要`...promises`中有一个处于稳定状态的变成稳定态的promise对象
- 使用[Promises][79fdc39b]--一个可视化的promise练习场--去更好地理解Promises
- 看[深入ES6的Promises][d4bd4ea8]

## 映射

- 用于代替常见的用纯JavaScript对象实现的哈希映射
    - 避免用户提供的键值带来的安全问题
    - 允许键值为任意值，你甚至可以使用DOM元素或者函数作为条目的键值
- `Map`对象遵从迭代协议
- 用`new Map()`方法来创建一个map对象
- 像初始化一个`iterable`对象这样`[[key1, value], [key2, value2]]`来在`new Map(iterable)`里初始化一个map对象
- 用`map.set(key, value)`来添加一个条目
- 用`map.get(key)`来获取一个条目
- 通过`map.has(key)`来用key作检查
- 用`map.delete(key)`来删除一个条目
- 用`for (let [key, value] of map)`来迭代一个map对象，要想展开map可以使用`Array.from`等
- 看深入ES6的Maps对象

  [3b219273]: https://ponyfoo.com/articles/tagged/es6-in-depth "深入了解ES6"
  [71be0617]: https://ponyfoo.com/articles/tagged/es6-in-depth "深入学习系列"
  [dd1633bc]: https://ponyfoo.com/articles/es6#introduction "目录介绍"
  [d6dc887d]: https://ponyfoo.com/articles/es6#tooling "转码工具"
  [afd90b94]: https://ponyfoo.com/articles/es6#assignment-destructuring "解构赋值"
  [e8b6fbb4]: https://ponyfoo.com/articles/es6#spread-operator-and-rest-parameters "展开运算符以及不定参数"
  [e64231bf]: https://ponyfoo.com/articles/es6#arrow-functions "箭头函数"
  [bf729279]: https://ponyfoo.com/articles/es6#template-literals "模板字符串"
  [75c9caa5]: https://ponyfoo.com/articles/es6#object-literals "对象字面值"
  [006355ad]: https://ponyfoo.com/articles/es6#classes "类"
  [d3c8e7b3]: https://ponyfoo.com/articles/es6#let-and-const "Let以及Const"
  [d81cc7e9]: https://ponyfoo.com/articles/es6#symbols "Symbols"
  [cbef365f]: https://ponyfoo.com/articles/es6#iterators "迭代器"
  [b70bcc5e]: https://ponyfoo.com/articles/es6#generators "生成器"
  [866870f1]: https://ponyfoo.com/articles/es6#promises "Promises"
  [ea91abdd]: https://ponyfoo.com/articles/es6#maps "映射"
  [ddd6f844]: https://ponyfoo.com/articles/es6#weakmaps "弱映射"
  [9d2b75e5]: https://ponyfoo.com/articles/es6#sets "集合"
  [9f40009a]: https://ponyfoo.com/articles/es6#weaksets "弱集合"
  [8b1f4dfd]: https://ponyfoo.com/articles/es6#proxies "代理"
  [92765db6]: https://ponyfoo.com/articles/es6#reflection "反射"
  [1233f62d]: https://ponyfoo.com/articles/es6#number "Number对象"
  [cf33277f]: https://ponyfoo.com/articles/es6#math "Math对象"
  [847ce29d]: https://ponyfoo.com/articles/es6#array "Array对象"
  [abe180fc]: https://ponyfoo.com/articles/es6#object "Object对象"
  [701a6c35]: https://ponyfoo.com/articles/es6#strings-and-unicode "字符串跟Unicode"
  [bf072aff]: https://ponyfoo.com/articles/es6#modules "模块组件"
  [d6ff4634]: http://babeljs.io/ "Babel"
  [e5a76d8d]: https://github.com/babel/babelify "babelify"
  [4ef399d4]: https://ponyfoo.com/articles/gulp-grunt-whatever "Gulp, Grunt, or npm run"
  [725b291f]: https://ponyfoo.com/articles/a-brief-history-of-es6-tooling "ES6工具简史"
  [a2ed0e70]: https://ponyfoo.com/articles/es6-destructuring-in-depth "深入了解JavaScript ES6解构"
  [1d71b0a3]: https://ponyfoo.com/articles/es6-spread-and-butter-in-depth "深入ES6展开运算符"
  [98b953ad]: https://ponyfoo.com/articles/es6#assignment-destructuring "解构的解释"
  [7d961bf4]: https://ponyfoo.com/articles/es6-arrow-functions-in-depth "深入ES6箭头函数"
  [4446b66f]: https://ponyfoo.com/articles/es6-template-strings-in-depth "深入ES6模板字符串"
  [48860a0e]: https://ponyfoo.com/articles/es6#object "对象"
  [c839b142]: https://ponyfoo.com/articles/es6-object-literal-features-in-depth "深入ES6对象字面值特性"
  [de1ad162]: https://ponyfoo.com/articles/es6#object-literals "对象字面值"
  [bca69661]: https://ponyfoo.com/articles/es6-classes-in-depth "深入ES6类"
  [a919c338]: https://ponyfoo.com/articles/es6-let-const-and-temporal-dead-zone-in-depth "深入ES6的Let，Const和”暂时性死区”（TDZ）"
  [22406275]: https://ponyfoo.com/articles/es6#iterators "iterable protocol"
  [9dd4fde8]: https://ponyfoo.com/articles/es6-symbols-in-depth "深入ES6 Symbols 对象"
  [28b66792]: https://promisesaplus.com/ "Promises/A+"
  [3f0a098b]: https://ponyfoo.com/articles/es6-iterators-in-depth "深入ES6迭代器"
  [798a3399]: https://ponyfoo.com/articles/es6-generators-in-depth "深入ES6生成器"
  [93b4f36a]: https://github.com/petkaantonov/bluebird "bluebird"
  [79fdc39b]: http://bevacqua.github.io/promisees/ "Promises"
  [d4bd4ea8]: https://ponyfoo.com/articles/es6-promises-in-depth "深入ES6的Promises"
