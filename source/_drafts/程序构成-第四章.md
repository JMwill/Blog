title: 程序构成-第四章
tags:
- 译文
- Design Programs
---

## 第四章: 数据处理

### 4.1 介绍

现代计算机可以处理大量表示世界许多方面的数据. 从这些大数据集合, 我们可以以前所未有的方式学习到人类的相关行为: 语言是如何使用的, 拍摄什么照片, 讨论什么话题, 以及人们是如何跟他们周围的环境来接触的. 为了高效地处理大数据集合, 程序被组织成对有序的数据流进行操作的管道. 在本章, 我们会考虑一套的技术来处理并操纵有序数据流.

在第二章, 我们会引入序列接口, 通过内置的数据类型(如列表和范围)来在Python中实现. 在这章中, 我们将会拓展序列数据的概念, 包括不具边界甚至是无限大小的集合. 两个数学上的无限序列例子是正整数以及斐波那契数列. 具有无限长度的序列数据集合也出现在其他计算领域. 例如, 通过电话塔发送的电话序列, 由计算机用户进行的鼠标移动的序列, 以及飞机上传感器的加速度测量序列随着世界的发展而无限延伸.

### 4.2 隐含序列

一个序列可以无需对每个元素进行明确存储在计算机的存储器中而表示出来. 也就是说, 我们可以构造一个对象来提供访问某些顺序数据集的所有元素而不用提前计算所有这些元素并保存它们. 相反, 我们按需来计算元素.

这个想法的一个简单的例子出现在第二章介绍的`range`序列类型中. 一个`range`表示一个连续, 有界的整数序列. 然而, 序列的每个元素在这个情况下并不是明确存在于内存中的. 相反, 当`range`中的元素被请求时, 它会计算出这个元素. 因此, 我们可以表示非常大的整数而不用大块的内存. 只有`range`的终结点存储为`range`对象的一部分.

```python
>>> r = range(10000, 1000000000)
>>> r = [45006230]

45006230
```

在这个例子中, 不是所有在999,990,000这个范围的整数在创建的时候都会被存储. 相反, 范围对象添加第一个元素10,000一直到到下标45,006,230来产出元素45,016,230. 一旦请求就会计算值而不是从一个已存在的表示来检索它们, 这是一个懒计算的例子. 在计算机科学, 懒计算描述任何延迟计算的程序, 直到需要该值为止.

一个迭代器是一个对象, 它提供对底层顺序数据集的顺序访问. 迭代器在很多程序中是内建对象, 包括Python. 迭代器的抽象具有两个部分, 一个在一个底层元素中检索下一个元素的机制以及一个发出已经到达序列的终点并没有更多元素的信号机制. 在具有内建对象系统的编程语言中, 这个抽象通常来说对应到特定的可以通过类来实现的接口. Python提供的迭代器接口描述会在下一节中描述.

迭代器的有用性源于一个事实即: 迭代器的底层数据序列可能不会在存储器中明确表示. 迭代器提供了一个机制来顺序考量一系列数据的值, 但同时所有的元素不需要存储在内存中. 相反, 当下一个元素被迭代器请求, 元素可以根据需要计算而不是从现有内存源中检索.

范围类可以对一个列表的元素进行懒计算因为所表示的序列是均匀的, 同时任何元素都容易从`range`的开始和结束的边界计算. 迭代器允许懒生成更广泛类型的底层顺序数据集, 因为它们不需要提供对任意元素的底层序列的访问. 相反, 迭代器只需要在每次请求一个元素时按顺序去计算该序列中的下一个元素. 虽然不像访问序列的任意元素一样灵活(称为随机访问), 顺序访问顺序数据序列通常来说足以用于数据处理应用.

#### 4.2.1 Python迭代器

Python的迭代器接口是用一个叫做`__next__`的方法来定义的, 它会返回它所代表的一些底层序列数据的下一个元素. 响应调用`__next__`方法, 迭代器可以执行任意计算以便检索或者计算出下一个元素. 调用`__next__`会为迭代器带来突变型的改变: 它推进了迭代器的位置. 因此, 多次调用`__next__`会返回一个底层序列的序列元素. Python在调用`__next__`期间通过发出`StopInteration`异常的形式来表示一个底层序列已经到达尽头.

下面的`LetterIter`类迭代一个以某些字母开头的而不包括某些字母结束的底层序列. 实例属性`next_letter`保存下一个字母用来返回. `__next__`方法返回这个字母并使用它来计算新的`next_letter`.

```python
>>> class LetterIter:
        """An iterator over letters of the alphabet in ASCII order."""
        def __init__(self, start='a', end='e'):
            self.next_letter = start
            self.end = end
        def __next__(self):
            if self.next_letter == self.end:
                raise StopIteration
            letter = self.next_letter
            self.next_letter = chr(ord(letter)+1)
            return letter
```

使用这个类, 我们可以顺序地访问字母通过`__next__`方法或者内建的`next`函数, 这个函数会调用传入的参数上的`__next__`方法.

```python
>>> letter_iter = LetterIter()
>>> letter_iter.__next__()
'a'
>>> letter_iter.__next__()
'b'
>>> next(letter_iter)
'c'
>>> letter_iter.__next__()
'd'
>>> letter_iter.__next__()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 12, in next
StopIteration
```

迭代器是可变的, 当它们演变事, 它们会跟踪某些底层序列值的位置. 当到达最后的值时, 迭代器就用完了. 一个`LetterIter`实例只可以被迭代一次. 在它的`__next__()`方法抛出`StopIteration`异常之后, 从这时起这个迭代器就会一直这样做. 通常, 一个迭代器是不可以重置的; 而是创建一个新实例来开始一个新的迭代.

迭代器也允许我们通过实现一个永远不会抛出`StopIteration`异常的`__next__`方法来表示一个无限序列. 例如, 下面的`Positives`类用来迭代无限的正整数序列. 在Python中内建的`next`方法会调用它参数上的`__next__`方法.

```python
>>> class Positives:
        def __init__(self):
            self.next_positive = 1;
        def __next__(self):
            result = self.next_positive
            self.next_positive += 1
            return result
>>> p = Positives()
>>> next(p)
1
>>> next(p)
2
>>> next(p)
3
```

#### 4.2.2 可迭代对象

如果一个对象在调用它的`__iter__`方法时返回一个迭代器那么这个对象是可迭代的. 可迭代值代表数据集, 并且它们提供可能产生多于一个迭代器的固定表示.

例如, 下面的`Letters`类的实例表示一个连续的字母序列. 每一次它的`__iter__`方法被调用, 一个新的`LetterIter`实例就被构造, 它允许顺序访问到序列的内容.

```python
>>> class Letters:
        def __init__(self, start='a', end='e'):
            self.start = start
            self.end = end
        def __iter__(self):
            return LetterIter(self.start, self.end)
```

内建的`iter`函数调用传入的参数上的`__iter__`方法. 在下面的序列表达式中, 两个迭代器衍生自相同的可迭代的序列并独立地返回序列中的字母.

```python
>>> b_to_k = Letters('b', 'k')
>>> first_iterator = b_to_k.__iter__()
>>> next(first_iterator)
'b'
>>> next(first_iterator)
'c'
>>> second_iterator = iter(b_to_k)
>>> second_iterator.__next__()
'b'
>>> first_iterator.__next__()
'd'
>>> first_iterator.__next__()
'e'
>>> second_iterator.__next__()
'c'
>>> second_iterator.__next__()
'd'
```

可迭代的`Letters`实例`b_to_k`以及`LetterIter`的迭代器实例`first_iterator`以及`second_iterator`与`Letters`实例的不同之处在于`Letter`实例不会更改, 而迭代器实例会随着每一次`next`调用(或者等效的`__next__`调用)之后改变. 迭代器通过顺序数据跟踪进度, 而可迭代表示数据本身.

在Python中的很多内建函数接受可迭代参数并返回一个迭代器. 例如, `map`函数, 接受一个函数以及一个可迭代的值. 它返回对可迭代参数的每个元素应用到传入函数后的返回结果组成的一个迭代器.

```python
>>> caps = map(lambda x: x.upper(), b_to_k)
>>> next(caps)
'B'
>>> next(caps)
'C'
```

`map`函数是惰性函数, 调用它时并不会执行计算其元素结果所需的计算. 相反, 一个迭代器对象被创建后, 如果使用`next`函数查询则可以返回结果. 我们可以在下面的例子中观察到这个事实, 打印的操作被延迟到了对应元素被`doubled`迭代器请求才操作.

```python
>>> def double_and_print(x):
        print('***', x, '=>', 2*x, '***')
        return 2*x
>>> s = range(3, 7)
>>> doubled = map(double_and_print, s)  # double_and_print not yet called
>>> next(doubled)                       # double_and_print called once
*** 3 => 6 ***
6
>>> next(doubled)                       # double_and_print called again
*** 4 => 8 ***
8
>>> list(doubled)                       # double_and_print called twice more
*** 5 => 10 ***
*** 6 => 12 ***
[10, 12]
```

`filter`, `zip`以及`reversed`函数也是返回迭代器的.

#### 4.2.3 声明

在Python中的`for`声明用于操作迭代器. 对象如果具有一个`__iter__`方法, 返回一个迭代器, 那么它是可以迭代的(一个接口). 可迭代对象可以是`for`声明头部的`<expression>`中的值:

```python
for <name> in <expression>:
    <suite>
```

为了执行`for`声明, Python执行头部`<expression>`, 这个expression必须返回一个迭代器值. 然后, 在该至上调用`__iter__`方法. 直到`StopIteration`异常被抛出, Python反复调用在这个迭代器上的`__next__`方法以及绑定结果到`<name>`在for声明中. 然后, 它执行`<suite>`.

```python
>>> counts = [1, 2, 3]
>>> for item in counts:
        print(item)
1
2
3
```

在上面的例子中, `counts`列表从它的`__iter__()`方法中返回一个迭代器. `for`声明之后不断地调用这个迭代器的`__next__()`方法, 同时每次都将返回值分配到`item`上. 这个过程一直持续直到迭代器抛出`StopIteration`异常, `for`声明在这个点上结束执行.

随着我们对迭代器的了解, 我们可以以`while`, 赋值, 以及`try`声明, 实现执行`for`的规则.

```python
>>> items = counts.__iter__()
>>> try:
        while True:
            item = items.__next__()
            print(item)
    except StopIteration:
        pass
1
2
3
```

上面, 通过调用`counts`迭代器的`__iter__`方法并将返回的值绑定到名称`items`上, 这样就可以依次查询每个元素. 处理`StopIteration`异常的处理机制什么都不会做, 但是这个处理机制提供了一个控制机制来跳出`while`循环.

在`for`循环中使用一个迭代器, 这个迭代器也必须具有一个`__iter__`方法. Python文档中的[Iterator][1]类型章节建议一个迭代器具有一个`__iter__`方法, 这个方法返回迭代器本身, 因此所有的迭代器都是可迭代的.

#### 4.2.4 生成器以及yield声明

上面的`Letters`以及`Positives`对象需要我们去引入一个新的域`self.current`到我们的对象来跟踪序列进度. 使用如上面展现的这样简单的序列, 可以很容易完成. 然而对于复杂的序列, `__next__`方法就很难在计算中保持它的位置. 生成器允许我们利用Python解析器的功能去定义更复杂的迭代.

生成器就是通过一个特殊类型的函数返回一个迭代器对象的函数. 生成器函数有别于常规的函数的地方在于它们的函数体内不是包含`return`声明, 它们使用`yield`声明来返回序列的元素.

生成器并不使用对象的属性来追踪序列的步进过程. 相反, 它们控制生成器函数的执行过程, 每一次生成器的`__next__`方法被调用就会一直执行直到下一个`yield`声明被执行才停止. `Letters`迭代器可以使用生成器函数来实现得更加紧凑.

```python
>>> def letters_generator():
        current = 'a'
        while current <= 'd':
            yield current
            current = chr(ord(current)+1)
>>> for letter in letters_generator():
        print(letter)
a
b
c
d
```

即使我们从来没有明确地定义`__iter__`或者`__next__`方法, `yield`声明指出我们正在声明一个生成器函数. 当函数被调用时, 生成器函数不是返回一个特定的产生的值, 而是一个生成器(它的类型是一个迭代器)它本身可以返回产生的值. 生成器对象具有`__iter__`以及`__next__`方法, 同时每一次调用`__next__`会继续从上一次生成器函数离开的地方继续执行生成器函数直到另一个`yield`声明被执行.

第一次调用`__next__`, 程序会执行来自`letters_generator`函数主体的语句, 直到它遇到`yield`声明. 然后, 它暂停并返回值给`current`. `yield`声明并不会销毁最新创建的环境, 它们将保留下来. 当`__next__`再次被调用, 执行过程恢复到它停止的地方, `current`的结果以及其他在这个`letters_generator`域之中绑定了的名称都会保留直到随后的`__next__`调用.

我们可以通过手动调用`__next__()`来遍历生成器:

```python
>>> letters = letters_generator()
>>> type(letters)
<class 'generator'>
>>> letters.__next__()
'a'
>>> letters.__next__()
'b'
>>> letters.__next__()
'c'
>>> letters.__next__()
'd'
>>> letters.__next__()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

生成器不会开始执行其生成函数的任何body语句, 直到`__next__`第一次被调用. 当生成器结束时会抛出`StopIteration`异常.

#### 4.2.5 创建带有yield的可迭代对象

在Python, 迭代器只能单向通过底层迭代序列的元素. 在这之后, 迭代器在`__next__`再次被调用时会继续抛出`StopIteration`异常. 很多程序需要重复元素多次. 例如, 我们要迭代列表多次来枚举所有元素对.

```python
>>> def all_pairs(s):
        for item1 in s:
            for item2 in s:
                yield (item1, item2)
>>> list(all_pairs([1, 2, 3]))
[(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]
```

序列本身并不是迭代器, 而是可迭代对象. 在Python中的可迭代接口由单个消息组成, `__iter__`, 它返回一个迭代器. 在Python中的内建序列类型在它们的`__iter__`方法被调用时返回新的迭代器的实例. 如果一个可迭代对象每次`__iter__`方法被调用时就返回一个新的实例, 那么它就可以迭代多次.

新的可迭代类可以通过实现可迭代接口来定义. 例如, 下面的_可迭代_`LettersWithYield`类每次在`__iter__`被调用时返回一个新的建立在字母上的迭代器.

```python
>>> class LettersWithYield:
        def __init__(self, start='a', end='e'):
            self.start = start
            self.end = end
        def __iter__(self):
            next_letter = self.start
            while next_letter < self.end:
                yield next_letter
                next_letter = chr(ord(next_letter) + 1)
```

`__iter__`方法是一个生成器函数; 它返回一个生成器对象这个生成器对象返回字母`a`到`d`然后就停止. 每次我们调用这个方法, 一个新的生成器会开始迭代一个新的序列数据.

```python
>>> letters = LettersWithYield()
>>> list(all_pairs(letters))[:5]
[('a', 'a'), ('a', 'b'), ('a', 'c'), ('a', 'd'), ('b', 'a')]
```

#### 4.2.6 流

流通常是隐含地表示序列数据的另一种方式. 流是一个懒计算的链接列表. 跟第二章的`Link`类类似, `Stream`实例响应请求它的第一个元素以及流剩下的元素. 跟`Link`类类似, `Stream`剩下的部分也是`Stream`. 跟`Link`不相似的是一个流剩下的部分只在它被查询的时候才计算, 而不是提前存储起来. 也就是说, 流剩下来的部分是懒计算的.

要实现这个懒运算, 流需要保存一个函数, 这个函数计算流剩下的部分. 无论何时函数被调用, 它返回的值会作为流的一部分被存储到一个叫做`_rest`的属性上, 以下划线来命名是为了标识它不应该被直接访问.

可访问的属性`rest`是一个属性方法, 它返回流剩下的部分, 在必要时进行计算. 有了这个设计, 流存储了如何计算流的剩余部分, 而不用总是明确地保存剩余的部分.

```python
>>> class Stream:
        """A lazily computed linked list."""
        class empty:
            def __repr__(self):
                return 'Stream.empty'
        empty = empty()
        def __init__(self, first, compute_rest=lambda: empty):
            assert callable(compute_rest), 'compute_rest must be callable.'
            self.first = first
            self._compute_rest = compute_rest
        @property
        def rest(self):
            """Return the rest of the stream, computing it if necessary."""
            if self._compute_rest is not None:
                self._rest = self._compute_rest()
                self._compute_rest = None
            return self._rest
        def __repr__(self):
            return 'Stream({0}, <...>)'.format(repr(self.first))
```

链表是通过嵌套表达式来定义的. 例如, 我们可以创建一个下面的表示具有元素1, 然后是元素5的`Link`:

```python
>>> r = Link(1, Link(2 + 3, Link(9)))
```

同样地, 我们可以创建一个`Stream`表示相同的序列, `Stream`实际上并不计算第二个元素5, 直到剩余的stream被请求, 我们可以通过创建匿名函数来达到这个效果.

```python
>>> s = Stream(1, lambda: Stream(2 + 3, lambda: Stream(9)))
```

这里, 1是流的第一个元素, 然后接下来的`lambda`表达式返回一个函数来计算剩余的流.

访问链表r的元素跟流s的元素的过程是相似的. 然而, 5已经存在r里面, 而s是在第一次被请求的时候按需求来进行加法计算的.

```python
>>> r.first
1
>>> s.first
1
>>> r.rest.first
5
>>> s.rest.first
5
>>> r.rest
Link(5, Link(9))
>>> s.rest
Stream(5, <...>)
```

而r的`rest`是一个具有两个元素的链表, 而s的`rest`则包括一个用于计算剩余部分的函数; 而它将会返回一个空的流的事实可能尚未被发现.

当一个`Stream`实例构建后, `self._rest`区域是`None`, 表示剩余的`Stream`部分尚未被计算. 当`rest`属性被通过点表达式请求, `rest`属性方法被调用就会触发`self._rest = self._compute_rest()`执行运算. 因为`Stream`的缓存机制, `compute_rest`函数只会调用一次, 然后会被丢弃.

`compute_rest`函数的基本属性是它不需要参数, 同时它返回一个`Stream`或者`Stream.empty`.

懒惰执行让我们有能力去用流来表示一个无限序列数据集. 例如, 我们可以表示增长的整数, 以任何`first`值开始.

```python
>>> def integer_stream(first):
        def compute_rest():
            return integer_stream(first+1)
        return Stream(first, compute_rest)
>>> positives = integer_stream(1)
>>> positives
Stream(1, <...>)
>>> positives.first
1
```

当`integer_stream`第一次被调用, 它返回一个流, 这个流的`first`是在序列中的第一个整数. 然而, `integer_stream`实际上是递归的, 因为这个流的`compute_rest`会再次以一个增长了的参数来调用`integer_stream`. 我们说`integer_stream`是懒惰的是因为递归调用`integer_stream`只会在剩下整数流被请求的时候才会调用.

```python
>>> positives.first
1
>>> positives.rest.first
2
>>> positives.rest.rest
Stream(3, <...>)
```

同样用来处理序列的高阶函数 --`map`以及`filter`-- 同样也可以应用到流上去, 即使它们的实现必须要改成惰性地应用它们的参数函数. 函数`map_stream`映射函数到整个流上, 这会产生一个新的流. 内部定义的`compute_rest`函数确保在剩下的流被计算时函数会被映射到剩余的流中去.

```python
>>> def map_stream(fn, s):
	if s is Stream.empty:
	    return s
	def compute_rest():
	    return map_stream(fn, s.rest)
	return Stream(fn(s.first), compute_rest)
```

流可以通过定义	一个`compute_rest`函数来应用过滤函数到剩余的流中来进行过滤. 如果过滤函数拒绝流的第一个元素, 剩下来的会马上被计算. 因为`filter_stream`是递归的, 剩下的流可能会被计算数次, 直到第一个有效的值被找到.

```python
>>> def filter_stream(fn, s):
        if s is Stream.empty:
            return s
        def compute_rest():
            return filter_stream(fn, s.rest)
        if fn(s.first):
            return Stream(s.first, compute_rest)
        else:
            return compute_rest()
```

`map_stream`以及`filter_stream`函数展示了流处理的共同模式: 本地定义`compute_rest`函数每当在需要计算剩余部分的时候递归地应用过程函数到流剩余的部分中.

为了检查流里面的内容, 我们可以将第一个元素强制转为Python中的`list`类型.

```python
>>> def first_k_as_list(s, k):
        first_k = []
        while s is not Stream.empty and k > 0:
            first_k.append(s.first)
            s, k = s.rest, k-1
        return first_k
```

这些便利函数允许我们去校验我们的`map_stream`实现, 一个简单的例子就是将从3到7的整数进行平方.

```python
>>> s = integer_stream(3)
>>> s
Stream(3, <...>)
>>> m = map_stream(lambda x: x*x, s)
>>> m
Stream(9, <...>)
>>> first_k_as_list(m, 5)
[9, 16, 25, 36, 49]
```

我们可以使用我们的`filter_stream`函数通过使用`Eratosthenes`的筛子来定义一个素数流, 它过滤整数流来移除所有是第一个元素的倍数的所有数字. 通过连续过滤每个素数，从流中删除所有复合数。

```python
>>> def primes(pos_stream):
        def not_divible(x):
            return x % pos_stream.first != 0
        def compute_rest():
            return primes(filter_stream(not_divible, pos_stream.rest))
        return Stream(pos_stream.first, compute_rest)
```

通过截断`primes`流, 我们可以列举任何素数的前缀

```python
>>> prime_numbers = primes(integer_stream(2))
>>> first_k_as_list(prime_numbers, 7)
[2, 3, 5, 7, 11, 13, 17]
```

流与迭代器不同的是它们可以被传递给纯函数多次并且每次都返回相同的结果. 素数流通过将其转换成列表时并没有被"用完". 也就是说, `prime_numbers`第一个元素在转换流的前缀为列表之后依旧是2.

```python
>>> prime_numbers.first
2
```

就像链表提供简单的序列抽象实现一样, 流通过使用高阶函数实现懒惰计算从而提供简单, 功能强大的递归式数据结构.

### 4.3 声明式编程

除了流以外, 数据值通常也保存在大型的库中, 这个库称为数据库. 数据库由包含数据值的数据存储以及用于检索和转换这些值的接口. 每个存储在数据库中的值都被称为_记录_. 记录具有相似的结构且被分组成表. 记录使用查询(这是一种查询语言)来进行检索和转换. 到目前为止, 这是使用最广泛的查询语言被称为结构化查询语言或者SQL(读作 "sequel").

SQL是声明式编程语言的一个例子. 声明并不直接描述计算, 而是描述期望的某些计算结果. 这是数据库系统查询解析器的作用是设计并执行计算过程来产出这样的结果.

这种交互与Python或Scheme这样的程序编程范例有很大的不同. 在Python, 计算过程是由程序员来直接指定的, 而声明式语言抽象程序细节, 而不是关注结果的形式.

#### 4.3 表

SQL语言是标准化的, 但是大多数数据库系统会实现一些语言的自定义变体, 其带有某些专有功能. 在本文中, 我们会描述SQL的一个小的集合它被实现在[Sqlite][2]中. 你可以通过[下载Sqlite][3]或者使用[在线的SQL解析器][4].

表, 也称为关联, 具有固定数量的命名和类型列, 表的每一行表示一个数据记录且每列都具有一个值. 例如, 一个城市的表可能会具有的列有`latitude`, `longitude`两者所持有的都是数值型的值, 还有一列为`name`所持有的值为字符串. 每一行通过它的纬度以及经度值来表示一个城市的坐标位置.

Latitude | Longitude | Name
---------|-----------|-----
38 | 122 | Berkeley
42 | 71 | Cambridge
45 | 93 | Minneapolis

可以通过SQL语言中的`select`声明来创建一个表中的单个行, 行中值是被逗号给分隔开的, 后接一个关键词"as"以及紧随的每列的名称. 所有的SQL声明都以分号作为结尾.

```sql
sqlite> select 38 as latitude, 122 as longitude, "Berkeley" as name;
38|122|Berkeley
```

第二行是输出, 每一条包含由竖线分隔开的列来组成.

多行表格可以通过_union_来构造, 这用来组合两个表的行. 左边的表格的列名在构建的表中使用. 而间隔在一行之内并不影响结果.

```sql
sqlite> select 38 as latitude, 122 as longitude, "Berkeley" as name union
   ...> select 42,             71,               "Cambridge"        union
   ...> select 45,             93,               "Minneapolis";
38|122|Berkeley
42|71|Cambridge
45|93|Minneapolis
```

表格可以用`create table`声明来给定一个名称. 而这个声明也可以用来创建空表, 我们将会关注给定名称给一个已经通过`select`声明定义的存在的表格这种形式.

```sql
sqlite> create table cities as
   ...>    select 38 as latitude, 122 as longitude, "Berkeley" as name union
   ...>    select 42,             71,               "Cambridge"        union
   ...>    select 45,             93,               "Minneapolis";
```

一旦一个表格被命名了, 这个名称可以用在`select`声明的`from`子句中. 表格中的所有列可以使用特殊形式的`select *`来展示.

```sql
sqlite> select * from cities;
38|122|Berkeley
42|71|Cambridge
45|93|Minneapolis
```

#### 4.3.2 Select声明

`select`声明定义一个新的表, 通过列出值在单一的一行或者更一般地通过`from`子句投影已经存在的表:

`select [column description] from [existing table name]`

结果表中的列通过一个以逗号分隔的表达式列表来描述, 对现有输入表的每一行执行运算.

例如, 我们可以创建两列的表, 这个表描述了每个城市距离伯克利的北部或者南部有多远. 每个纬度的每一度表示距离北方60海里.

```sql
sqlite> select name, 60*abs(latitude-38) from cities;
Berkeley|0
Cambridge|240
Minneapolis|420
```

列描述在语言中是一个表达式它分享了Python中的许多特性, 添加操作符如`+`以及`%`, 内建函数如`abs`以及`round`, 以及括号用来描述运算的顺序. 在这些表达式中的名称, 例如上面的`latitude`, 执行后得到列的值来形成数据行.

可选地, 每个表达式可以后接关键字`as`以及一个列的名称. 当整个表格被赋予一个名称时, 通常给每个列一个名称是很有用的, 这方便将来在`select`语句中被引用. 由简单名称描述的列将会自动命名.

```sql
sqlite> create table distances as
   ...>   select name, 60*abs(latitude-38) as distance from cities;
sqlite> select distance/5, name from distances;
0|Berkeley
48|Cambridge
84|Minneapolis
```

**`Where`子句**, `select`声明也可以包含具有过滤表达式的`where`子句. 这表达式过滤映射的行. 只有经过滤表达式运算后得到的值为真的行才会被用于在结果表中生成一行记录.

```sql
sqlite> create table cold as
   ...>   select name from cities where latitude > 43;
sqlite> select name, "is cold!" from cold;
Minneapolis|is cold!
```

**`Order`子句**. `select`声明也可以对结果表进行排序. `order`子句包含一个排序表达式, 这表达式对每个未经过滤的行执行运算. 这个表达式的结果值用作结果表的排序标准.

```sql
sqlite> select distance, name from distances order by -distance;
84|Minneapolis
48|Cambridge
0|Berkeley
```

这些特性的组合允许`select`语句将输入表的各种映射表达到相关的输出表中.

#### 4.3.3 连接

通常来说, 数据库会包含多个表同时查询可以要求包含在不同的表中的信息来计算出期望的结果. 例如, 我们可能会有第二表描述了不同城市的平均日高温.

```sql
sqlite> create table temps as
   ...>   select "Berkeley" as city, 68 as temp union
   ...>   select "Chicago"         , 59         union
   ...>   select "Minneapolis"     , 55;
```

通过将多个表连接在一起来组合数据, 这是数据库系统的基本操作. 有很多方法来进行连接, 所有都是密切相关的, 但是在本文中我们会只专注于一个方法. 当表被连接时结果表包含所有输入的表组合而成的新的行. 如果两个表被连接同时左边的表具有`m`行, 右边的表具有`n`行, 那么连接后的表就会具有`m*n`行. 连接在SQL中的表达是通过在`select`语句中的`from`子句中用逗号分隔表格名称来实现的.

```sql
sqlite> select * from cities, temps;
38|122|Berkeley|Berkeley|68
38|122|Berkeley|Chicago|59
38|122|Berkeley|Minneapolis|55
42|71|Cambridge|Berkeley|68
42|71|Cambridge|Chicago|59
42|71|Cambridge|Minneapolis|55
45|93|Minneapolis|Berkeley|68
45|93|Minneapolis|Chicago|59
45|93|Minneapolis|Minneapolis|55
```

连接一般会伴随有`where`子句来表达两个表之间的关系. 例如, 如果我们想要收集数据到一个表中, 这个表允许我们关联纬度以及温度, 我们会从连接中选择那些两个表中都提及到的城市来组成行. 在`cities`表中, 城市的名称被保存在名为`name`的列中. 在`temps`表中, 城市名称被保存在名为`city`的列中. `where`子句在连接表中选择那些值相等的行. 在SQL, 使用单个`=`符号来测试数字等式.

```sql
sqlite> select name, latitude, temp from cities, temps where name = city;
Berkeley|38|68
Minneapolis|45|55
```

表可能会具有重叠的列名称, 因此我们需要一种通过表来消除列名称歧义的方法, 一个表也可能与它自己来进行连接, 因此我们需要一种方法来消除表名称的歧义. 为了这样做, SQL允许我们在`from`子句中用`as`关键字来为表格起别名并通过使用点表达式来在特定表格中引用列名称. 下面的`select`语句计算两个不相等的城市的温度差. 在`where`子句中具有按之母顺序的约束确保每一对数据只会在结果中出现一次.

```sql
sqlite> select a.city, b.city, a.temp - b.temp
   ...>        from temps as a, temps as b where a.city < b.city;
Berkeley|Chicago|10
Berkeley|Minneapolis|15
Chicago|Minneapolis|5
```

我们在SQL中组合表的两种方法, 连接以及合并(`join`以及`union`), 允许语句具有极大的表现力.

#### 4.3.4 解释SQL

为了创建迄今为止介绍的一个SQL子集的解析器, 我们需要创建表格的表示, 用文本写成的语句的解析器以及解析语句的执行器. [`sql`][5]解析器的例子介绍了所有这些部分, 提供简单但是能演示功能的声明式语言解析器.

在这个实现中, 每个表具有它自己的类, 在表中的每行数据通过这个表格类的实例来进行表示. 行在表中的每一列都具有一个属性, 同时, 表格是一系列的行.

表格的类是使用Python标准库中的`collections`包中[`namedtuple`][6]函数来创建的, 它会返回一个新的`tuple`的子类, 并给元组中的每个元素命名.

想一下来自前面章节的`cities`表, 表示如下.

```sql
sqlite> create table cities as
   ...>    select 38 as latitude, 122 as longitude, "Berkeley" as name union
   ...>    select 42,             71,               "Cambridge"        union
   ...>    select 45,             93,               "Minneapolis";
```

下面的Python语句构造了这表格的表示

```python
>>> from collections import namedtuple
>>> CitiesRow = namedtuple("Row", ["latitude", "longitude", "name"])
>>> cities = [CitiesRow(38, 122, "Berkeley"),
              CitiesRow(42,  71, "Cambridge"),
              CitiesRow(43,  93, "Minneapolis")]
```

`select`语句的结果可以用序列操作来进行解析. 回想一下来自前面章节的`distances`表, 表示如下.

```sql
sqlite> create table distances as
   ...>   select name, 60*abs(latitude-38) as distance from cities;
sqlite> select distance/5, name from distances;
0|Berkeley
48|Cambridge
84|Minneapolis
```

这个表格是由`cities`表格中的`name`以及`latitude`列产生的. 这结果列表可以通过在输入表的行上映射函数来形成, 这个函数为每一个`CitiesRow`返回`DistancesRow`.

```python
>>> DistancesRow = namedtuple("Row", ["name", "distance"])
>>> def select(cities_row):
        latitude, longitude, name = cities_row
        return DistancesRow(name, 60*abs(latitude-38))
>>> distances = list(map(select, cities))
>>> for row in distances:
        print(row)
Row(name='Berkeley', distance=0)
Row(name='Cambridge', distance=240)
Row(name='Minneapolis', distance=300)
```

我们的SQL解析器的设计概括了这个方法. `select`语句表示为由`select`子句构造的类`Select`的实例.

```python
>>> class Select:
        """select [columns] from [tables] where [condition] order by [order]."""
        def __init__(self, columns, tables, condition, order):
            self.columns = columns
            self.tables = tables
            self.condition = condition
            self.order = order
            self.make_row = create_make_row(self.columns)
        def execute(self, env):
            """Join, filter, sort, and map rows from tables to columns."""
            from_rows = join(self.tables, env)
            filtered_rows = filter(self.filter, from_rows)
            ordered_rows = self.sort(filtered_rows)
            return map(self.make_row, ordered_rows)
        def filter(self, row):
            if self.condition:
                return eval(self.condition, row)
            else:
                return True
        def sort(self, rows):
            if self.order:
                return sorted(rows, key=lambda r: eval(self.order, r))
            else:
                return rows
```

`execute`方法连接输入表, 过滤并排序结果行, 然后映射函数`make_row`调用到这些结果行中. `make_row`函数是在`Select`构造器中通过调用`create_make_row`来创建的, 这个高阶函数为结果表创建一个新的类并定义如何将输入行投影到输出行. (这个函数具有更多错误处理以及特殊情况的版本出现在[`sql`][7]中.)

```python
>>> def create_make_row(description):
        """Return a function from an input environment (dict) to an output row.
        description -- a comma-separated list of [expression] as [column name]
        """
        columns = description.split(", ")
        expressions, names = [], []
        for column in columns:
            if " as " in column:
                expression, name = column.split(" as ")
            else:
                expression, name = column, column
            expressions.append(expression)
            names.append(name)
        row = namedtuple("Row", names)
        return lambda env: row(*[eval(e, env) for e in expressions])
```

最后, 我们需要定义`join`函数来创建输入行. 给定一个`env`字典包含现有表(行的列表)并以它们的名字作为key值, `join`函数将所有行的组合, 用`itertools`包中的[`product`][8]函数组合到输出表中. 它映射一个叫做`make_env`的函数到已经连接完成的行当中去, 这个函数将每个行的组合转换为字典, 以便它可以用来执行表达式. (这个函数具有更多错误处理以及特殊情况的版本出现在[`sql`][7]中)

```python
>>> from itertools import product
>>> def join(tables, env):
        """Return an iterator over dictionaries from names to values in a row.
        tables -- a comma-separate sequences of table names
        env    -- a dictionary from global names to tables
        """
        names = tables.split(", ")
        joined_rows = product(*[env[name] for name in names])
        return map(lambda rows: make_env(rows, names), joined_rows)
>>> def make_env(rows, names):
        """Create an environment of names bound to values."""
        env = dict(zip(names, rows))
        for row in rows:
            for name in row._fields:
                env[name] = getattr(row, name)
        return env
```

上面, `row._fields`求包含该行的表的列名称的值. `_fields`属性的存在是因为`row`的类型是`namedtuple`类.

我们的解析器已经足够执行`select`语句了. 例如我们可以计算从"Berkeley"到其他所有城市的纬度距离, 并以它们的经度来排序.

```python
>>> env = {"cities": cities}
>>> select = Select("name, 60*abs(latitude-38) as distance",
                    "cities", "name != 'Berkeley'", "-longitude")
>>> for row in select.execute(env):
        print(row)
Row(name='Minneapolis', distance=300)
Row(name='Cambridge', distance=240)
```

[1]: http://docs.python.org/3/library/stdtypes.html#iterator-types
[2]: http://sqlite.org/
[3]: http://sqlite.org/download.html
[4]: http://kripken.github.io/sql.js/GUI/
[5]: http://composingprograms.com/examples/sql/sql_exec.py
[6]: https://docs.python.org/3/library/collections.html#collections.namedtuple
[7]: http://composingprograms.com/examples/sql/sql_exec.py
[8]: https://docs.python.org/3/library/itertools.html#itertools.product