title: 程序构成-第四章
tags:
- 译文
- Design Programs
---

## 第四章: 数据处理

### 4.1 介绍

现代计算机可以处理大量表示世界许多方面的数据. 从这些大数据集合, 我们可以以前所未有的方式学习到人类的相关行为: 语言是如何使用的, 拍摄什么照片, 讨论什么话题, 以及人们是如何跟他们周围的环境来接触的. 为了高效地处理大数据集合, 程序被组织成对有序的数据流进行操作的管道. 在本章, 我们会考虑一套的技术来处理并操纵有序数据流.

在第二章, 我们会引入序列接口, 通过内置的数据类型(如列表和范围)来在Python中实现. 在这章中, 我们将会拓展序列数据的概念, 包括不具边界甚至是无限大小的集合. 两个数学上的无限序列例子是正整数以及斐波那契数列. 具有无限长度的序列数据集合也出现在其他计算领域. 例如, 通过电话塔发送的电话序列, 由计算机用户进行的鼠标移动的序列, 以及飞机上传感器的加速度测量序列随着世界的发展而无限延伸.

### 4.2 隐含序列

一个序列可以无需对每个元素进行明确存储在计算机的存储器中而表示出来. 也就是说, 我们可以构造一个对象来提供访问某些顺序数据集的所有元素而不用提前计算所有这些元素并保存它们. 相反, 我们按需来计算元素.

这个想法的一个简单的例子出现在第二章介绍的`range`序列类型中. 一个`range`表示一个连续, 有界的整数序列. 然而, 序列的每个元素在这个情况下并不是明确存在于内存中的. 相反, 当`range`中的元素被请求时, 它会计算出这个元素. 因此, 我们可以表示非常大的整数而不用大块的内存. 只有`range`的终结点存储为`range`对象的一部分.

```python
>>> r = range(10000, 1000000000)
>>> r = [45006230]

45006230
```

在这个例子中, 不是所有在999,990,000这个范围的整数在创建的时候都会被存储. 相反, 范围对象添加第一个元素10,000一直到到下标45,006,230来产出元素45,016,230. 一旦请求就会计算值而不是从一个已存在的表示来检索它们, 这是一个懒计算的例子. 在计算机科学, 懒计算描述任何延迟计算的程序, 直到需要该值为止.

一个迭代器是一个对象, 它提供对底层顺序数据集的顺序访问. 迭代器在很多程序中是内建对象, 包括Python. 迭代器的抽象具有两个部分, 一个在一个底层元素中检索下一个元素的机制以及一个发出已经到达序列的终点并没有更多元素的信号机制. 在具有内建对象系统的编程语言中, 这个抽象通常来说对应到特定的可以通过类来实现的接口. Python提供的迭代器接口描述会在下一节中描述.

迭代器的有用性源于一个事实即: 迭代器的底层数据序列可能不会在存储器中明确表示. 迭代器提供了一个机制来顺序考量一系列数据的值, 但同时所有的元素不需要存储在内存中. 相反, 当下一个元素被迭代器请求, 元素可以根据需要计算而不是从现有内存源中检索.

范围类可以对一个列表的元素进行懒计算因为所表示的序列是均匀的, 同时任何元素都容易从`range`的开始和结束的边界计算. 迭代器允许懒生成更广泛类型的底层顺序数据集, 因为它们不需要提供对任意元素的底层序列的访问. 相反, 迭代器只需要在每次请求一个元素时按顺序去计算该序列中的下一个元素. 虽然不像访问序列的任意元素一样灵活(称为随机访问), 顺序访问顺序数据序列通常来说足以用于数据处理应用.

#### 4.2.1 Python迭代器

Python的迭代器接口是用一个叫做`__next__`的方法来定义的, 它会返回它所代表的一些底层序列数据的下一个元素. 响应调用`__next__`方法, 迭代器可以执行任意计算以便检索或者计算出下一个元素. 调用`__next__`会为迭代器带来突变型的改变: 它推进了迭代器的位置. 因此, 多次调用`__next__`会返回一个底层序列的序列元素. Python在调用`__next__`期间通过发出`StopInteration`异常的形式来表示一个底层序列已经到达尽头.

下面的`LetterIter`类迭代一个以某些字母开头的而不包括某些字母结束的底层序列. 实例属性`next_letter`保存下一个字母用来返回. `__next__`方法返回这个字母并使用它来计算新的`next_letter`.

```python
>>> class LetterIter:
        """An iterator over letters of the alphabet in ASCII order."""
        def __init__(self, start='a', end='e'):
            self.next_letter = start
            self.end = end
        def __next__(self):
            if self.next_letter == self.end:
                raise StopIteration
            letter = self.next_letter
            self.next_letter = chr(ord(letter)+1)
            return letter
```

使用这个类, 我们可以顺序地访问字母通过`__next__`方法或者内建的`next`函数, 这个函数会调用传入的参数上的`__next__`方法.

```python
>>> letter_iter = LetterIter()
>>> letter_iter.__next__()
'a'
>>> letter_iter.__next__()
'b'
>>> next(letter_iter)
'c'
>>> letter_iter.__next__()
'd'
>>> letter_iter.__next__()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 12, in next
StopIteration
```

迭代器是可变的, 当它们演变事, 它们会跟踪某些底层序列值的位置. 当到达最后的值时, 迭代器就用完了. 一个`LetterIter`实例只可以被迭代一次. 在它的`__next__()`方法抛出`StopIteration`异常之后, 从这时起这个迭代器就会一直这样做. 通常, 一个迭代器是不可以重置的; 而是创建一个新实例来开始一个新的迭代.

迭代器也允许我们通过实现一个永远不会抛出`StopIteration`异常的`__next__`方法来表示一个无限序列. 例如, 下面的`Positives`类用来迭代无限的正整数序列. 在Python中内建的`next`方法会调用它参数上的`__next__`方法.

```python
>>> class Positives:
        def __init__(self):
            self.next_positive = 1;
        def __next__(self):
            result = self.next_positive
            self.next_positive += 1
            return result
>>> p = Positives()
>>> next(p)
1
>>> next(p)
2
>>> next(p)
3
```

#### 4.2.2 可迭代对象

如果一个对象在调用它的`__iter__`方法时返回一个迭代器那么这个对象是可迭代的. 可迭代值代表数据集, 并且它们提供可能产生多于一个迭代器的固定表示.

例如, 下面的`Letters`类的实例表示一个连续的字母序列. 每一次它的`__iter__`方法被调用, 一个新的`LetterIter`实例就被构造, 它允许顺序访问到序列的内容.

```python
>>> class Letters:
        def __init__(self, start='a', end='e'):
            self.start = start
            self.end = end
        def __iter__(self):
            return LetterIter(self.start, self.end)
```

内建的`iter`函数调用传入的参数上的`__iter__`方法. 在下面的序列表达式中, 两个迭代器衍生自相同的可迭代的序列并独立地返回序列中的字母.

```python
>>> b_to_k = Letters('b', 'k')
>>> first_iterator = b_to_k.__iter__()
>>> next(first_iterator)
'b'
>>> next(first_iterator)
'c'
>>> second_iterator = iter(b_to_k)
>>> second_iterator.__next__()
'b'
>>> first_iterator.__next__()
'd'
>>> first_iterator.__next__()
'e'
>>> second_iterator.__next__()
'c'
>>> second_iterator.__next__()
'd'
```

可迭代的`Letters`实例`b_to_k`以及`LetterIter`的迭代器实例`first_iterator`以及`second_iterator`与`Letters`实例的不同之处在于`Letter`实例不会更改, 而迭代器实例会随着每一次`next`调用(或者等效的`__next__`调用)之后改变. 迭代器通过顺序数据跟踪进度, 而可迭代表示数据本身.

在Python中的很多内建函数接受可迭代参数并返回一个迭代器. 例如, `map`函数, 接受一个函数以及一个可迭代的值. 它返回对可迭代参数的每个元素应用到传入函数后的返回结果组成的一个迭代器.

```python
>>> caps = map(lambda x: x.upper(), b_to_k)
>>> next(caps)
'B'
>>> next(caps)
'C'
```

`map`函数是惰性函数, 调用它时并不会执行计算其元素结果所需的计算. 相反, 一个迭代器对象被创建后, 如果使用`next`函数查询则可以返回结果. 我们可以在下面的例子中观察到这个事实, 打印的操作被延迟到了对应元素被`doubled`迭代器请求才操作.

```python
>>> def double_and_print(x):
        print('***', x, '=>', 2*x, '***')
        return 2*x
>>> s = range(3, 7)
>>> doubled = map(double_and_print, s)  # double_and_print not yet called
>>> next(doubled)                       # double_and_print called once
*** 3 => 6 ***
6
>>> next(doubled)                       # double_and_print called again
*** 4 => 8 ***
8
>>> list(doubled)                       # double_and_print called twice more
*** 5 => 10 ***
*** 6 => 12 ***
[10, 12]
```

`filter`, `zip`以及`reversed`函数也是返回迭代器的.
