title: 程序构成-第四章
tags:
- 译文
- Design Programs
---

## 第四章: 数据处理

### 4.1 介绍

现代计算机可以处理大量表示世界许多方面的数据. 从这些大数据集合, 我们可以以前所未有的方式学习到人类的相关行为: 语言是如何使用的, 拍摄什么照片, 讨论什么话题, 以及人们是如何跟他们周围的环境来接触的. 为了高效地处理大数据集合, 程序被组织成对有序的数据流进行操作的管道. 在本章, 我们会考虑一套的技术来处理并操纵有序数据流.

在第二章, 我们会引入序列接口, 通过内置的数据类型(如列表和范围)来在Python中实现. 在这章中, 我们将会拓展序列数据的概念, 包括不具边界甚至是无限大小的集合. 两个数学上的无限序列例子是正整数以及斐波那契数列. 具有无限长度的序列数据集合也出现在其他计算领域. 例如, 通过电话塔发送的电话序列, 由计算机用户进行的鼠标移动的序列, 以及飞机上传感器的加速度测量序列随着世界的发展而无限延伸.

### 4.2 隐含序列

一个序列可以无需对每个元素进行明确存储在计算机的存储器中而表示出来. 也就是说, 我们可以构造一个对象来提供访问某些顺序数据集的所有元素而不用提前计算所有这些元素并保存它们. 相反, 我们按需来计算元素.

这个想法的一个简单的例子出现在第二章介绍的`range`序列类型中. 一个`range`表示一个连续, 有界的整数序列. 然而, 序列的每个元素在这个情况下并不是明确存在于内存中的. 相反, 当`range`中的元素被请求时, 它会计算出这个元素. 因此, 我们可以表示非常大的整数而不用大块的内存. 只有`range`的终结点存储为`range`对象的一部分.

```python
>>> r = range(10000, 1000000000)
>>> r = [45006230]

45006230
```

在这个例子中, 不是所有在999,990,000这个范围的整数在创建的时候都会被存储. 相反, 范围对象添加第一个元素10,000一直到到下标45,006,230来产出元素45,016,230. 一旦请求就会计算值而不是从一个已存在的表示来检索它们, 这是一个懒计算的例子. 在计算机科学, 懒计算描述任何延迟计算的程序, 直到需要该值为止.

一个迭代器是一个对象, 它提供对底层顺序数据集的顺序访问. 迭代器在很多程序中是内建对象, 包括Python. 迭代器的抽象具有两个部分, 一个在一个底层元素中检索下一个元素的机制以及一个发出已经到达序列的终点并没有更多元素的信号机制. 在具有内建对象系统的编程语言中, 这个抽象通常来说对应到特定的可以通过类来实现的接口. Python提供的迭代器接口描述会在下一节中描述.

迭代器的有用性源于一个事实即: 迭代器的底层数据序列可能不会在存储器中明确表示. 迭代器提供了一个机制来顺序考量一系列数据的值, 但同时所有的元素不需要存储在内存中. 相反, 当下一个元素被迭代器请求, 元素可以根据需要计算而不是从现有内存源中检索.

范围类可以对一个列表的元素进行懒计算因为所表示的序列是均匀的, 同时任何元素都容易从`range`的开始和结束的边界计算. 迭代器允许懒生成更广泛类型的底层顺序数据集, 因为它们不需要提供对任意元素的底层序列的访问. 相反, 迭代器只需要在每次请求一个元素时按顺序去计算该序列中的下一个元素. 虽然不像访问序列的任意元素一样灵活(称为随机访问), 顺序访问顺序数据序列通常来说足以用于数据处理应用.

#### 4.2.1 Python迭代器

Python的迭代器接口是用一个叫做`__next__`的方法来定义的, 它会返回它所代表的一些底层序列数据的下一个元素. 响应调用`__next__`方法, 迭代器可以执行任意计算以便检索或者计算出下一个元素. 调用`__next__`会为迭代器带来突变型的改变: 它推进了迭代器的位置. 因此, 多次调用`__next__`会返回一个底层序列的序列元素. Python在调用`__next__`期间通过发出`StopInteration`异常的形式来表示一个底层序列已经到达尽头.

下面的`LetterIter`类迭代一个以某些字母开头的而不包括某些字母结束的底层序列. 实例属性`next_letter`保存下一个字母用来返回. `__next__`方法返回这个字母并使用它来计算新的`next_letter`.

```python
>>> class LetterIter:
        """An iterator over letters of the alphabet in ASCII order."""
        def __init__(self, start='a', end='e'):
            self.next_letter = start
            self.end = end
        def __next__(self):
            if self.next_letter == self.end:
                raise StopIteration
            letter = self.next_letter
            self.next_letter = chr(ord(letter)+1)
            return letter
```

使用这个类, 我们可以顺序地访问字母通过`__next__`方法或者内建的`next`函数, 这个函数会调用传入的参数上的`__next__`方法.

```python
>>> letter_iter = LetterIter()
>>> letter_iter.__next__()
'a'
>>> letter_iter.__next__()
'b'
>>> next(letter_iter)
'c'
>>> letter_iter.__next__()
'd'
>>> letter_iter.__next__()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 12, in next
StopIteration
```

迭代器是可变的, 当它们演变事, 它们会跟踪某些底层序列值的位置. 当到达最后的值时, 迭代器就用完了. 一个`LetterIter`实例只可以被迭代一次. 在它的`__next__()`方法抛出`StopIteration`异常之后, 从这时起这个迭代器就会一直这样做. 通常, 一个迭代器是不可以重置的; 而是创建一个新实例来开始一个新的迭代.

迭代器也允许我们通过实现一个永远不会抛出`StopIteration`异常的`__next__`方法来表示一个无限序列. 例如, 下面的`Positives`类用来迭代无限的正整数序列. 在Python中内建的`next`方法会调用它参数上的`__next__`方法.

```python
>>> class Positives:
        def __init__(self):
            self.next_positive = 1;
        def __next__(self):
            result = self.next_positive
            self.next_positive += 1
            return result
>>> p = Positives()
>>> next(p)
1
>>> next(p)
2
>>> next(p)
3
```

#### 4.2.2 可迭代对象

如果一个对象在调用它的`__iter__`方法时返回一个迭代器那么这个对象是可迭代的. 可迭代值代表数据集, 并且它们提供可能产生多于一个迭代器的固定表示.

例如, 下面的`Letters`类的实例表示一个连续的字母序列. 每一次它的`__iter__`方法被调用, 一个新的`LetterIter`实例就被构造, 它允许顺序访问到序列的内容.

```python
>>> class Letters:
        def __init__(self, start='a', end='e'):
            self.start = start
            self.end = end
        def __iter__(self):
            return LetterIter(self.start, self.end)
```

内建的`iter`函数调用传入的参数上的`__iter__`方法. 在下面的序列表达式中, 两个迭代器衍生自相同的可迭代的序列并独立地返回序列中的字母.

```python
>>> b_to_k = Letters('b', 'k')
>>> first_iterator = b_to_k.__iter__()
>>> next(first_iterator)
'b'
>>> next(first_iterator)
'c'
>>> second_iterator = iter(b_to_k)
>>> second_iterator.__next__()
'b'
>>> first_iterator.__next__()
'd'
>>> first_iterator.__next__()
'e'
>>> second_iterator.__next__()
'c'
>>> second_iterator.__next__()
'd'
```

可迭代的`Letters`实例`b_to_k`以及`LetterIter`的迭代器实例`first_iterator`以及`second_iterator`与`Letters`实例的不同之处在于`Letter`实例不会更改, 而迭代器实例会随着每一次`next`调用(或者等效的`__next__`调用)之后改变. 迭代器通过顺序数据跟踪进度, 而可迭代表示数据本身.

在Python中的很多内建函数接受可迭代参数并返回一个迭代器. 例如, `map`函数, 接受一个函数以及一个可迭代的值. 它返回对可迭代参数的每个元素应用到传入函数后的返回结果组成的一个迭代器.

```python
>>> caps = map(lambda x: x.upper(), b_to_k)
>>> next(caps)
'B'
>>> next(caps)
'C'
```

`map`函数是惰性函数, 调用它时并不会执行计算其元素结果所需的计算. 相反, 一个迭代器对象被创建后, 如果使用`next`函数查询则可以返回结果. 我们可以在下面的例子中观察到这个事实, 打印的操作被延迟到了对应元素被`doubled`迭代器请求才操作.

```python
>>> def double_and_print(x):
        print('***', x, '=>', 2*x, '***')
        return 2*x
>>> s = range(3, 7)
>>> doubled = map(double_and_print, s)  # double_and_print not yet called
>>> next(doubled)                       # double_and_print called once
*** 3 => 6 ***
6
>>> next(doubled)                       # double_and_print called again
*** 4 => 8 ***
8
>>> list(doubled)                       # double_and_print called twice more
*** 5 => 10 ***
*** 6 => 12 ***
[10, 12]
```

`filter`, `zip`以及`reversed`函数也是返回迭代器的.

#### 4.2.3 声明

在Python中的`for`声明用于操作迭代器. 对象如果具有一个`__iter__`方法, 返回一个迭代器, 那么它是可以迭代的(一个接口). 可迭代对象可以是`for`声明头部的`<expression>`中的值:

```python
for <name> in <expression>:
    <suite>
```

为了执行`for`声明, Python执行头部`<expression>`, 这个expression必须返回一个迭代器值. 然后, 在该至上调用`__iter__`方法. 直到`StopIteration`异常被抛出, Python反复调用在这个迭代器上的`__next__`方法以及绑定结果到`<name>`在for声明中. 然后, 它执行`<suite>`.

```python
>>> counts = [1, 2, 3]
>>> for item in counts:
        print(item)
1
2
3
```

在上面的例子中, `counts`列表从它的`__iter__()`方法中返回一个迭代器. `for`声明之后不断地调用这个迭代器的`__next__()`方法, 同时每次都将返回值分配到`item`上. 这个过程一直持续直到迭代器抛出`StopIteration`异常, `for`声明在这个点上结束执行.

随着我们对迭代器的了解, 我们可以以`while`, 赋值, 以及`try`声明, 实现执行`for`的规则.

```python
>>> items = counts.__iter__()
>>> try:
        while True:
            item = items.__next__()
            print(item)
    except StopIteration:
        pass
1
2
3
```

上面, 通过调用`counts`迭代器的`__iter__`方法并将返回的值绑定到名称`items`上, 这样就可以依次查询每个元素. 处理`StopIteration`异常的处理机制什么都不会做, 但是这个处理机制提供了一个控制机制来跳出`while`循环.

在`for`循环中使用一个迭代器, 这个迭代器也必须具有一个`__iter__`方法. Python文档中的[Iterator][1]类型章节建议一个迭代器具有一个`__iter__`方法, 这个方法返回迭代器本身, 因此所有的迭代器都是可迭代的.

#### 4.2.4 生成器以及yield声明

上面的`Letters`以及`Positives`对象需要我们去引入一个新的域`self.current`到我们的对象来跟踪序列进度. 使用如上面展现的这样简单的序列, 可以很容易完成. 然而对于复杂的序列, `__next__`方法就很难在计算中保持它的位置. 生成器允许我们利用Python解析器的功能去定义更复杂的迭代.

生成器就是通过一个特殊类型的函数返回一个迭代器对象的函数. 生成器函数有别于常规的函数的地方在于它们的函数体内不是包含`return`声明, 它们使用`yield`声明来返回序列的元素.

生成器并不使用对象的属性来追踪序列的步进过程. 相反, 它们控制生成器函数的执行过程, 每一次生成器的`__next__`方法被调用就会一直执行直到下一个`yield`声明被执行才停止. `Letters`迭代器可以使用生成器函数来实现得更加紧凑.

```python
>>> def letters_generator():
        current = 'a'
        while current <= 'd':
            yield current
            current = chr(ord(current)+1)
>>> for letter in letters_generator():
        print(letter)
a
b
c
d
```

即使我们从来没有明确地定义`__iter__`或者`__next__`方法, `yield`声明指出我们正在声明一个生成器函数. 当函数被调用时, 生成器函数不是返回一个特定的产生的值, 而是一个生成器(它的类型是一个迭代器)它本身可以返回产生的值. 生成器对象具有`__iter__`以及`__next__`方法, 同时每一次调用`__next__`会继续从上一次生成器函数离开的地方继续执行生成器函数直到另一个`yield`声明被执行.

第一次调用`__next__`, 程序会执行来自`letters_generator`函数主体的语句, 直到它遇到`yield`声明. 然后, 它暂停并返回值给`current`. `yield`声明并不会销毁最新创建的环境, 它们将保留下来. 当`__next__`再次被调用, 执行过程恢复到它停止的地方, `current`的结果以及其他在这个`letters_generator`域之中绑定了的名称都会保留直到随后的`__next__`调用.

我们可以通过手动调用`__next__()`来遍历生成器:

```python
>>> letters = letters_generator()
>>> type(letters)
<class 'generator'>
>>> letters.__next__()
'a'
>>> letters.__next__()
'b'
>>> letters.__next__()
'c'
>>> letters.__next__()
'd'
>>> letters.__next__()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

生成器不会开始执行其生成函数的任何body语句, 直到`__next__`第一次被调用. 当生成器结束时会抛出`StopIteration`异常.

#### 4.2.5 创建带有yield的可迭代对象

在Python, 迭代器只能单向通过底层迭代序列的元素. 在这之后, 迭代器在`__next__`再次被调用时会继续抛出`StopIteration`异常. 很多程序需要重复元素多次. 例如, 我们要迭代列表多次来枚举所有元素对.

```python
>>> def all_pairs(s):
        for item1 in s:
            for item2 in s:
                yield (item1, item2)
>>> list(all_pairs([1, 2, 3]))
[(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]
```

序列本身并不是迭代器, 而是可迭代对象. 在Python中的可迭代接口由单个消息组成, `__iter__`, 它返回一个迭代器. 在Python中的内建序列类型在它们的`__iter__`方法被调用时返回新的迭代器的实例. 如果一个可迭代对象每次`__iter__`方法被调用时就返回一个新的实例, 那么它就可以迭代多次.

新的可迭代类可以通过实现可迭代接口来定义. 例如, 下面的_可迭代_`LettersWithYield`类每次在`__iter__`被调用时返回一个新的建立在字母上的迭代器.

```python
>>> class LettersWithYield:
        def __init__(self, start='a', end='e'):
            self.start = start
            self.end = end
        def __iter__(self):
            next_letter = self.start
            while next_letter < self.end:
                yield next_letter
                next_letter = chr(ord(next_letter) + 1)
```

`__iter__`方法是一个生成器函数; 它返回一个生成器对象这个生成器对象返回字母`a`到`d`然后就停止. 每次我们调用这个方法, 一个新的生成器会开始迭代一个新的序列数据.

```python
>>> letters = LettersWithYield()
>>> list(all_pairs(letters))[:5]
[('a', 'a'), ('a', 'b'), ('a', 'c'), ('a', 'd'), ('b', 'a')]
```

#### 4.2.6 流

流通常是隐含地表示序列数据的另一种方式. 流是一个懒计算的链接列表. 跟第二章的`Link`类类似, `Stream`实例响应请求它的第一个元素以及流剩下的元素. 跟`Link`类类似, `Stream`剩下的部分也是`Stream`. 跟`Link`不相似的是一个流剩下的部分只在它被查询的时候才计算, 而不是提前存储起来. 也就是说, 流剩下来的部分是懒计算的.

要实现这个懒运算, 流需要保存一个函数, 这个函数计算流剩下的部分. 无论何时函数被调用, 它返回的值会作为流的一部分被存储到一个叫做`_rest`的属性上, 以下划线来命名是为了标识它不应该被直接访问.

可访问的属性`rest`是一个属性方法, 它返回流剩下的部分, 在必要时进行计算. 有了这个设计, 流存储了如何计算流的剩余部分, 而不用总是明确地保存剩余的部分.

```python
>>> class Stream:
        """A lazily computed linked list."""
        class empty:
            def __repr__(self):
                return 'Stream.empty'
        empty = empty()
        def __init__(self, first, compute_rest=lambda: empty):
            assert callable(compute_rest), 'compute_rest must be callable.'
            self.first = first
            self._compute_rest = compute_rest
        @property
        def rest(self):
            """Return the rest of the stream, computing it if necessary."""
            if self._compute_rest is not None:
                self._rest = self._compute_rest()
                self._compute_rest = None
            return self._rest
        def __repr__(self):
            return 'Stream({0}, <...>)'.format(repr(self.first))
```

链表是通过嵌套表达式来定义的. 例如, 我们可以创建一个下面的表示具有元素1, 然后是元素5的`Link`:

```python
>>> r = Link(1, Link(2 + 3, Link(9)))
```

同样地, 我们可以创建一个`Stream`表示相同的序列, `Stream`实际上并不计算第二个元素5, 直到剩余的stream被请求, 我们可以通过创建匿名函数来达到这个效果.

```python
>>> s = Stream(1, lambda: Stream(2 + 3, lambda: Stream(9)))
```

这里, 1是流的第一个元素, 然后接下来的`lambda`表达式返回一个函数来计算剩余的流.

访问链表r的元素跟流s的元素的过程是相似的. 然而, 5已经存在r里面, 而s是在第一次被请求的时候按需求来进行加法计算的.

```python
>>> r.first
1
>>> s.first
1
>>> r.rest.first
5
>>> s.rest.first
5
>>> r.rest
Link(5, Link(9))
>>> s.rest
Stream(5, <...>)
```

而r的`rest`是一个具有两个元素的链表, 而s的`rest`则包括一个用于计算剩余部分的函数; 而它将会返回一个空的流的事实可能尚未被发现.

当一个`Stream`实例构建后, `self._rest`区域是`None`, 表示剩余的`Stream`部分尚未被计算. 当`rest`属性被通过点表达式请求, `rest`属性方法被调用就会触发`self._rest = self._compute_rest()`执行运算. 因为`Stream`的缓存机制, `compute_rest`函数只会调用一次, 然后会被丢弃.

`compute_rest`函数的基本属性是它不需要参数, 同时它返回一个`Stream`或者`Stream.empty`.

懒惰执行让我们有能力去用流来表示一个无限序列数据集. 例如, 我们可以表示增长的整数, 以任何`first`值开始.

```python
>>> def integer_stream(first):
        def compute_rest():
            return integer_stream(first+1)
        return Stream(first, compute_rest)
>>> positives = integer_stream(1)
>>> positives
Stream(1, <...>)
>>> positives.first
1
```

当`integer_stream`第一次被调用, 它返回一个流, 这个流的`first`是在序列中的第一个整数. 然而, `integer_stream`实际上是递归的, 因为这个流的`compute_rest`会再次以一个增长了的参数来调用`integer_stream`. 我们说`integer_stream`是懒惰的是因为递归调用`integer_stream`只会在剩下整数流被请求的时候才会调用.

```python
>>> positives.first
1
>>> positives.rest.first
2
>>> positives.rest.rest
Stream(3, <...>)
```

同样用来处理序列的高阶函数 --`map`以及`filter`-- 同样也可以应用到流上去, 即使它们的实现必须要改成惰性地应用它们的参数函数. 函数`map_stream`映射函数到整个流上, 这会产生一个新的流. 内部定义的`compute_rest`函数确保在剩下的流被计算时函数会被映射到剩余的流中去.

```python
>>> def map_stream(fn, s):
	if s is Stream.empty:
	    return s
	def compute_rest():
	    return map_stream(fn, s.rest)
	return Stream(fn(s.first), compute_rest)
```

流可以通过定义	一个`compute_rest`函数来应用过滤函数到剩余的流中来进行过滤. 如果过滤函数拒绝流的第一个元素, 剩下来的会马上被计算. 因为`filter_stream`是递归的, 剩下的流可能会被计算数次, 直到第一个有效的值被找到.

```python
>>> def filter_stream(fn, s):
        if s is Stream.empty:
            return s
	def compute_rest():
	    return filter_stream(fn, s.rest)
	if fn(s.first):
	    return Stream(s.first, compute_rest)
	else:
	    return compute_rest()
```

[1]: http://docs.python.org/3/library/stdtypes.html#iterator-types
