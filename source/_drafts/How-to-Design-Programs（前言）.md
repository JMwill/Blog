title: How to Design Programs（前言）
tags:
- 译文
- Design Programs
---

## 前言

许多行亚都需要某种形式上的程序设计，会计编写电子表格；音乐家编写曲谱；作家编写文字；以及网络设计师编写样式表。当我们为这本书的第一版（1995-2000）写下这些文字的时候，人们正在考虑它们的未来；而现在，程序设计已经成为一项必要的技能，众多的网点在迎合这个需求——书籍、线上课程、K-12课程等，总是以提高人们的就业前景为目标。

这些典型的程序设计课程教授一种“不断修补，直到可以工作为止”的途径。当它可以工作时，学生大叫“它可以运行了！”然后再继续。可悲的是，那句话是计算机领域里最短的谎言，而且它已经花费了许多人生活中的许多时间。与之相反的是，这本书专注于让专业和职业的程序员养成好的编程习惯。

“良好的编程”在我们看来是以一种良好的途径来创造的程序，它依赖于系统化的思想，计划，并从一开始就认识到每一个阶段的每一步（应如何做）。为了强调这一点，我们会讲授系统化程序设计，以及系统化设计的程序。特别地，后者阐明了所期望的功能的基本原理。好的程序设计同时也能提高审美素养；良好的编程的优雅之处就像是历经时间考验的诗句或者是过去时代的黑白照片。简而言之，编程不同于好的编程，就像晚餐后的蜡笔画不同于博物馆的油画。

不，这本书不会让任何人变成一个油画大师。但是，如果我们不相信：“每个人都可以设计程序” 以及 ”每个人都能从有创意的设计中获得成就感。” 我们不会花费15年来写这个版本。实际上，我们甚至更进一步地对“程序设计——但不是**编程**”——应该像教授数学以及语言技能那样在文科中占一个席位进行争论。

一个学习了（程序）设计的学生，即使他此后再没有接触编程，他也依然掌握了普遍有用的解决问题的能力，进行深度创造性活动的经验，以及学习了欣赏新的审美意识。接下来的前言详细地解释了我们说的“系统化设计”这种方式带来的好处，以及我们会如何教授这一切。

<!-- more -->

---
## 系统化程序设计

程序与人（我们称之为用户）进行交互，彼此之间也进行交互，在这些情况下，我们通常称为服务组件和客户组件。因此任何合理的完备程序都可以认为是由许多构建模块构成：一些处理输入，一些创建输出，一些为这两者之间的界限构筑一个桥梁。我们选择使用函数来作为基本的构建模块，因为每个人都在预代数中遇到过函数，同时也因为最简单的程序就是函数。关键是发现哪些函数是需要的，如何连接它们，以及如何以基本元素来构建它们。

在这种情况下，“系统程序设计”指的是两个概念的混合：设计“食谱”（方法/处方）以及迭代求精。设计食谱是一个作者的创作；这里有一些他们之后能使用的（准则）

```
1. 以分析问题来进行数据定义
    认清在所选编程语言中必需要表示的信息并了解它是如何表示的，制定数据定义，同时用例子说明。
2. 签名，目的陈述，标题
    陈述所期望的功能是如何处理并产出数据的。用一条简介的单行声明语句准确地说出功能是如何运算的，为声明定义一个名副其实的存根
3. 应用实例
    通过一个可工作的实例说明功能的意图
4. 函数模板
    对函数的数据定义转译成函数大纲
5. 函数定义
    在函数模板中填补剩下的空白。利用目的声明以及例子（来进行）。
6. 测试
    用之前展示的实例来进行测试，并保证所有功能都通过测试。这样做能够发现错误同时也能在需要的时候帮助其他人阅读以及理解定义，这对于任何负责任的程序都是必需的。

图一： 函数食谱的基础设计步骤
```

**设计菜谱**应用于所有完整的程序以及各个函数中，这本书只处理两种完整程序中的食谱，一种GUI（图形用户界面）程序，另一种是批处理程序。与之相反的是，为各种功能设计食谱有各种各样的风格：有的用于形成原子类型的数据如数字，有的用于枚举不同类型数据，有的用于以固定的方式复合数据，有的用于有限但任意大小的数据，等等。

函数层级的食谱设计共用一套相同的设计流程。函数食谱基础设计步骤所展示的六个基础步骤。每一步的标题指定了预期的输出；那些指令给出了主要活动的建议。范例在每一个阶段都起到了核心作用。如步骤1中的选择数据表示，写下范例证明真实世界中的信息是如何作为数据被编码的以及数据是如何作为信息被解读的。步骤3说明了一个问题的解决必须要通过具体的应用场景来理解所需的函数在具体的例子里是如何运算的。这些理解都是为了步骤5中定义一个函数而进行铺垫的。最终，步骤6需要将范例变成自动化测试代码，用于保证函数在某些情况下正确运行。函数运行在真实世界的数据下可能会揭示一些预期结果与真实结果之间的差异。

设计流程的每一步都来源于关键问题。对于某些步骤，例如说：功能例子或者模板的创建时，会在数据定义时引出一些问题。这些问题的答案几乎自动地就创建出一个半成品，而这个脚手架在实现过程中需要迈出创造性的一步的时候给予我们回报：完成函数的定义。不仅如此，（设计流程）几乎所有情况下都会带来帮助。

这种方法的新奇之处在于创建初级程序的中间产物。当一个初学者遇到问题的时候，专家或者讲师可以查看现有的半成品。这个查阅的方How-to-Design-Programs式很可能是用一系列设计流程中的问题来引导初学者去修正他们自己的实现。而这个自我提升的过程就是编程与程序设计之间的关键区别。

**迭代细化**解决这个问题的难点是复杂以及多方面的。让所有事情一次就做对是几乎不可能的。相反，计算机科学借鉴了物理学的迭代细化（理论）来解决这一设计问题。事实上，迭代细化建议一开始就剥离所有琐碎的细节以及为剩下的核心问题寻找解决办法。每进行一次求精步骤就用尽可能使用现有的解决办法来忽略一些细节以及重新解决扩大了的问题域。每一次这些求精步骤的重复，也叫做迭代，会最终将我们导向问题的完整解决方案。

在这个场景下，程序员就是一个微科学家，科学家们为世界创造理想化版本的近似模型来进行预测。一旦这个模型的预测成为现实，那么没什么问题。当预期的事件与实际的不一样，科学家修正他们的模型来减少差异。同理，当程序员接到一个任务，他们创建第一个设计方案，将它转化成代码，让真实用户评价它并且反复提炼设计直到程序的行为足够接近预期所需的预期产物。

这本书用两种方法介绍了迭代细化（这一概念），当设计方案变得越复杂，精细化设计就变得越有用，当问题难到一定的程度时，这本书会在第四部分会明确地介绍这技术。此外在本书的第一、三两节课程里面，我们使用迭代细化来声明日益复杂的相同问题的变体。也就是说，我们选择一个问题，在一章中解决它们，然后在随后的章节中提出相似的问题——与细节相匹配的新引入的概念。

---

## DrRacket（编程语言）和教学语言

学习程序设计要求不断地动手练习。没有人能够不创造一个实际的程序并让它正确地工作就成为一个程序设计师，就像没有人能够不弹钢琴就成为钢琴家一样，因此，这本书自带一点小小的软件支持：一门用来写程序的语言和一个带有像word那样的文档编辑器，在实际输入上跑的程序开发环境。

人们经常告诉我们说他们希望自己知道怎么编程，然后又问我们他们应该选哪一种程序语言来学。鉴于通过资讯来了解某些语言而提出这样的疑问就不那么意外了。但这也是完全不恰当的。用当前时尚的编程语言来学习编程，常会让学生感到失败。时尚在当前世界当中是及其短暂的。典型的“快速用X语言开发”的书籍或者课程未能正确教导转换到下一个流行语言的原理。更糟糕的是，这些语言常常让人从获得转换原理中分心，包括寻求相应水平的解决方案以及处理程序错误。

与之相反的是，学习程序设计主要包括学习原理以及获得语言间转换的能力，理想的编程语言应该要对这两个目的支持良好，但现成的工业语言没有这样做。关键的问题是，初学者在他们十分了解这个语言之前就会犯错误，而程序语言总是将编程的人当作已经了解了整个编程语言来诊断错误。最终，诊断结果常常会卡住初学者。

我们的解决办法是从我们自己开始，量身定做一门语言，又称为“初学者语言”或者*SL。这门语言实际上是一门“外”语，它要求初学者学习过预代数的课程，它包括的符号有函数定义、函数应用、以及条件判断。同时，表达式可以嵌套，换句话说，这门语言是那么的小以至于对整个语言来说诊断报告中除了预代数来说依然是可读。

说到编程环境，我们遇到跟编程语言一样糟糕的选择，编程环境对于专业人士来说就像是喷气客机的座舱。它有众多的控制器以及显示屏，（能够）压倒任何第一次启动这样的程序的人。初学者需要能让他们练习基础技能的相当于双座，单引擎螺旋桨的飞机。因此我们为初学者创造了DrRacket语言以及一个编程环境。

DrRacket是一个以两个简单的互动窗格来支持非常好玩的面向结果为导向的语言：一个含有函数定义的区域以及一个允许编程者求证可能跟定义相关的表达式的结果。在这上下文中探索假设的场景跟在电子表格应用中一样容易。第一次接触就能用常规的计算表达式开始实验，而且很快就能继续计算图片、文字、以及其他格式的数据

一个像DrRacket这样的交互式程序开发环境将学习过程简化为两个途径。第一，它允许初学者直接操作数据。因为没有必要从文件或者设备中读取输入信息。初学者无需花费宝贵的时间来弄明白它是怎么工作的。第二，（我们）严格区分从真实世界中输入输出的数据和数据操作。今天，这种区分对程序系统化设计是那么的重要，以至于得到一个命名：模型-试图-控制器结构。通过用DrRacket，新手程序员从一开始就自然地直接接触这些基本的软件工程思想。

---

## 技能转移

技能需要通过在两个方向上学习系统化的程序设计之间的转换而习得。自然地，它们也适用于一般的编程，编写电子表格程序，合成器，样式表，甚至是文字处理器。通过我们的观察表明，从图一得到的设计过程几乎能延展到任何程序语言（当中），它能应用于10行的程序，也能应用于10,000行的程序。通过该设计过程能够反射出程序的语言的编写形式以及编程问题的规模；但是这在很多方面都是值得的，一旦这个过程成为习惯。

学习程序设计也意味着获得两种普遍有用的技能。程序设计无疑会教授与数学一样的分析技能，特别地，（预）代数以及几何学。但是其中不像数学的是，编写程序是一项积极的学习方式。创建程序能够提供即时的回馈同时引导我们探索，实验，以及自我评估。结果得出的往往是互动的产品，与在练习本上练习相比这大大提升了成就感。

除了提高学生们的数学技能外，程序设计教授分析阅读与写作的技能，即使是以最小的设计任务为题，如果没有坚实的阅读能力，也是不可能设计程序来解决这些具有合理复杂度的问题的。反过来，程序设计方法迫使创建者他/她用正确且精确的语言说出想法。的确，如果学生真的吸收了设计方法，他们增强的关键技能比其他什么都要多。

要说明这一点，先看一下图一。根据流程说明，设计者必须
1. 分析并陈述问题，通常是文字的陈述；
2. 提取并表达它的本质，抽象且带有例子；
3. 根据分析制作大纲以及计划；
4. 将结果与预期的结果进行评估；
5. 修正作品中错误检查以及测试暴露出来的问题；

每一步都需要分析，精确，描述，专注，以及注意细节。任何有经验的企业家，工程师，记者，律师，科学家或者其他专业人士都能说明有多少技能在他们的日常工作中是必要的。用纸张或者DrRacket来练习程序设计能愉快地获得这些技能。

同样地，提炼设计（这项能力）不仅仅局限于计算机领域或者创建程序。建筑师，作曲家，作家以及其他的专业人士同样也使用（这项能力）。他们的想法始于脑中，并以某种方式表达它们的本质，他们在纸上提炼这些想法，直到作品能够越多地反映脑海中的想法。当他们将想法带到纸上时，他们采用的技能类似于完全吸收了的设计食谱：画画，写作，或者弹奏钢琴去为表达建筑物的某些样式元素，描述某人的性格，或者定制某些旋律。正是因为他们已经吸收消化了他们基础的设计食谱以及学习到如何在当前场景下选择应该使用哪个步骤，让他们能够以迭代开发过程来进行生产创作。

---
## 这本书以及其他部分

这本书的目的是介绍系统化程序设计给那些没有过往经验的读者。顺带地，它提出了一个计算符号的观念，一种解释数据处理程序是如何工作的方法。大致地讲这个方法概括了学生时代的小学算术以及中学代数。无需担心的是：DrRacket有一个代数步进机制，它能够一步一步地演示这些计算。

这本书包括6个部分，每个部分分成五个插曲以及加上由序幕和尾声组成的结尾。而主要的部分专注于程序设计，插曲介绍了一些有关于程序设计力学与计算的补充概念。

[序言: 如何编程][Prologue-How-To-Program]简要介绍了普通编程。它说明了如何用*SL写一个简单的动画。一旦完成，任何初学者势必既感到充满力量又不知所措，最后的要点解释了为何普通编程错误的以及如何通过系统地循序渐进的程序设计方法消除每一个初级程序员都会面对的恐惧情绪。接下来就是这本书的核心阶段。

- [固定大小数据][Fixed-Size-Data]用最简单的例子介绍了最根本的系统化设计概念。中心思想是设计者通常对程序支持对数据进行哪些处理和产出有粗略的构思，因此一个系统的设计方法必须尽可能地提取描述流进流出程序中的数据中的线索。为了简单起见，这一部分开始于原子数据-数字，图像以及其他等等，然后渐渐介绍其他描述数据的新方法：区间，枚举，序列，结构，以及这些的组合体。
- [插曲: BSL][Intermezzo-BSL]描述教学语言的全部细节：它的词汇，语法，以及含义。计算机科学家参考这些作为语法和语义，程序设计者用这些计算模型展示他们创作的东西在运行或者进行错误诊断分析时是怎么计算的。
- [任意大数据][Arbitrarily-Large-Data]扩展自[固定大小数据][Fixed-Size-Data]用方法来描述最有趣、最有用的数据形式：任意大规模复合数据。而一些程序员可能将各种[固定大小数据][Fixed-Size-Data]进行嵌套来代表信息，这种嵌套往往是固定深度和宽度的。这一部分展示了如何通过微妙的泛化让我们从前面的嵌套到任意大小的数据。关注点之后会切换到系统化设计程序来处理这类型数据上。
- [插曲：引用，结束引语][Intermezzo-Quote-Unquote]介绍简洁有用的符号用于写下大块的数据：引用以及反引用
- [抽象化][Abstration]认知，从[任意大数据][Arbitrarily-Large-Data]的众多功能中得来。没有一个编程语言应该迫使程序员去创建那些相互之间具有相似功能的代码。反过来，好的程序语言有办法消除这些相似性。计算机程序设计将这些消除相似性的步骤以及它的结果叫做抽象，同时，他们知道，抽象化能够极大地提高程序员的生产力。因此，这一部分介绍创造以及使用抽象的设计方法。
- [插曲：域和抽象][Intermezzo-Scope-and-Abstraction]扮演两个角色。一方面，它注入词域的概念，这主意能让程序语言通过内含的命名定义（程序员能通过代码检查来找到）进行联系。另一方面，它用一个库来说明抽象的额外机制，包括所谓的循环。
- [交织的数据][Intertwined-Data]归纳了[任意大数据][Arbitrarily-Large-Data]且明确地引入了迭代细化的设计概念到目录当中。
- [插曲：数的性质][Intermezzo-The-Nature-of-Numbers]解释了为什么在所有程序语言中十进制数会以一种如此陌生的方式运行。所有程序初学者都应该去了解这些基础事实；而在本书的内容中，很容易去讨论或者演示这些思路。
- [递归生成][Generative-Recursion]注入了一种全新的设计思想。尽管结构化设计以及抽象化已经能够满足大多数程序员遇到的问题，但是，它们偶尔也会导致程序不那么“高性能”。换句话说，结构化设计的程序可能需要更多的时间或者内存或能量来计算期望的答案。因此计算机科学家们替换结构化程序的设计方案为有益于对指定问题域有特别见解的程序。这本书的这一部分展示了如何设计这一大类的程序。
- [插曲：计算的成本][Intermezzo-The-Cost-of-Computation]用[递归生成][Generative-Recursion]中的例子来演示计算机科学家们是如何考量性能的。
- [累加器][Accumulators]为设计者的工具箱添加了最后一个绝招：累加器，通俗地讲，一个累加器让程序具有“记忆能力”，加入了记忆能力极大地提高了这本书前四章里的结构化设计的函数的性能，对于[递归生成][Generative-Recursion]中的特设程序，累加器能让找到所有答案以及找不到一个答案之间有所区分。
- [结语：继续前行][Epilogue-Moving-On]既是对下一步的一个评估，也是展望。

![图二：每一部分以及插曲的依赖](/images/How-to-Design-Programs/pict.png)

独立的读者应该从头到尾做完这整本书。我们说“做完”是因为我们的意思真的是说一个读者应该解决所有的练习或者至少知道如何解决它们。

同样地，讲师从序幕一直到结语应该覆盖尽可能多的内容。我们的教学经验建议是可行的。特别地，我们组织了我们的课程，因此我们的读者通过学期内的课程能够创造了一个相当大的娱乐程序。然而我们知道，某些情况下（课程）需要大幅削减或者一些讲授者对这本书的使用会有自己的风格。

图二是给那些希望从书中选择相关部分学习的人的一个导航图。那是一张依赖图，从一项到另一项的实箭头建议严格按照顺序来看；比如，第二部分要求对第一部分完全理解。与之对比的是，虚箭头大多是建议按照顺序来阅读；如读懂序言对读本书剩下的内容不是必须的。

按照这个阅读路线图，这里有三个可行的阅读路径：
- 一个中学讲师可能想要（尽可能）涉及第一以及第二部分，包括一个小型项目，如一个游戏。
- 一个大学讲师在四分之一学制内可能希望专注于[固定大小数据][Fixed-Size-Data]、[任意大数据][Arbitrarily-Large-Data]、[抽象化][Abstration]和[递归生成][Generative-Recursion]，外加*SL以及域这两个插曲。
- 一个大学讲师在整个学制内可能较为喜欢尽可能早地讨论设计中的性能权衡。在这种情况中，最好覆盖[固定大小数据][Fixed-Size-Data]以及[任意大数据][Arbitrarily-Large-Data]接着是[累加器][Accumulators]章节中的并不依赖于[递归生成][Generative-Recursion]的累加器素材。到那时候，就可以讨论[插曲：计算的成本][Intermezzo-The-Cost-of-Computation]以及从这个角度开始学习本书剩下的章节。

**样例主题的复述**这本书一次又一次地回顾了某些样例话题以及练习。比如，虚拟宠物在[固定大小数据][Fixed-Size-Data]中随处能找到，甚至出现在[任意大数据][Arbitrarily-Large-Data]中。同样地，[固定大小数据][Fixed-Size-Data]以及[任意大数据][Arbitrarily-Large-Data]覆盖了实现交互式文本编辑器的替代方法。图形出现在[迭代生成][Generative-Recursion]中，然后有马上出现在[累加器][Accumulators]中。这些重复的目的是为了激励进行迭代细化，并通过其他途径介绍（概念）。我们敦促讲师来分配这些主题序列的练习或者创造他们自己的序列。

---

## 区别

第二版的“How to Design Programs”跟第一版的几个主要方面有所不同。

1. 第二版明确承认了设计整个程序与设计构造程序的函数之间的不同。特别地，这一版本专注于两种类型的程序：事件驱动型（大部分是GUI程序，也有网络程序）以及批处理程序。
2. 程序的设计在规划阶段应用的是自顶向下的设计流程，然后是自底向上的构造阶段。我们明确地库的借口是如何指挥某些程序元素的外形的。尤其是在程序设计的最初始阶段产生出一个函数期望列表。而期望清单的概念在第一版已经存在，第二版明确地将它作为设计要素之一。
3. 依靠“设计菜谱”完成函数期望清单的条目，是第六部分的主题。
4. 结构化设计的关键元素是组成其他东西的函数的定义。这种组合设计十分适合批处理程序这个领域。像递归生成，它需要一个尤卡里（问题的答案）特别是一个可识别的的中间数据，通过一个函数以及过程处理中间结果，再通过第二个函数简化整体设计。这个方法也需要期望清单，但是制定这些期望需要对中间数据进行有洞察力的开发。这一版本的书编织了许多明确的组合设计的练习。
5. 测试永远是我们的设计哲学中的一部分，就在我们公开第一版之后，教学语言以及DrRacket在2002年就开始正确地支持它。这新的版本很大程度上依赖于测试支持。
6. 这一版本放弃了命令式程序的设计。旧的章节依然在线，其中的资料会出现在这一系列的第二卷"How to Design Components."
7. 书中的例子以及练习需要采用新的教学包。首选的风格是通过[require][require]链接这些库，但是也可以通过DrRacket菜单添加教学包。
8. 最后，第二版的术语跟符号与第一版的有些许不同。
    ```
    Second Edition ------------- First Edition
    signature                    contract
    itemization                  union
    '()                          empty
    #true                        true
    #false                       false
    ```

最后的三个不同点大大地提高了列表中的引用（的方便程度）

---

## [第一版的致谢][Acknowledgments-Of-First-Edition]

---

## [第二版致谢][Acknowledgments]

[Prologue-How-To-Program]:              http://www.ccs.neu.edu/home/matthias/HtDP2e/part_prologue.html
[Fixed-Size-Data]:                      http://www.ccs.neu.edu/home/matthias/HtDP2e/part_one.html
[Intermezzo-BSL]:                       http://www.ccs.neu.edu/home/matthias/HtDP2e/part_one.html#%28part._i1-2%29
[Arbitrarily-Large-Data]:               http://www.ccs.neu.edu/home/matthias/HtDP2e/part_two.html
[Intermezzo-Quote-Unquote]:             http://www.ccs.neu.edu/home/matthias/HtDP2e/part_two.html#%28part._i2-3%29
[Abstration]:                           http://www.ccs.neu.edu/home/matthias/HtDP2e/part_three.html
[Intermezzo-Scope-and-Abstraction]:     http://www.ccs.neu.edu/home/matthias/HtDP2e/part_three.html#%28part._i3-4%29
[Intertwined-Data]:                     http://www.ccs.neu.edu/home/matthias/HtDP2e/part_four.html
[Generative-Recursion]:                 http://www.ccs.neu.edu/home/matthias/HtDP2e/part_five.html
[Intermezzo-The-Cost-of-Computation]:   http://www.ccs.neu.edu/home/matthias/HtDP2e/part_five.html#%28part._i5-6%29
[Accumulators]:                         http://www.ccs.neu.edu/home/matthias/HtDP2e/part_six.html
[Epilogue-Moving-On]:                   http://www.ccs.neu.edu/home/matthias/HtDP2e/part_epilogue.html
[require]:                              http://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._require%29%29
[Acknowledgments-Of-First-Edition]:     http://www.ccs.neu.edu/home/matthias/HtDP2e/part_preface.html#(part._.Acknowledgments_from_the_.First_.Edition)
[Acknowledgments]:                      http://www.ccs.neu.edu/home/matthias/HtDP2e/part_preface.html#(part._.Acknowledgments)
