title: 程序构成-第一章
tags:
- 译文
- Design Programs
---

## 第一章：用函数构筑抽象

### 1.1 开始

计算机科学是极为广泛的科学。涉及的领域有全球的分布式系统，人工智能，机器人，图形学，安全，科学计算，计算机体系结构以及每年发掘的大量新兴的子领域对新技术的相关拓展。计算机科学的快速发展使得人类生活中的各个方面都收到影响。商业，通讯，科学，艺术，休闲，以及政治都在计算机领域被重新发明了。

只有计算机科学能够有这么高的生产率，因为这个学科是建立在一套优雅以及强大的基本思想上的。所有的计算都开始于表达信息，制定处理逻辑，以及设计抽象来管理复杂的逻辑。要掌握这些原理要求我们明白恰恰就是计算机是如何翻译计算机程序以及完成计算过程。

这些基本思想长期用[SICP][SICP]（Structure and Interpretation of Computer Programs）这本Harold Abelson以及Gerald Jay Sussman和Julie Sussman所写的教科书来教授，本书大量借用了这本教科书，原书作者允许我们在共享创作的许可协议下进行改编以及重用。这些笔记遵循[知识共享署名非商业性类似共享许可证第三版][Creative Commons attribution non-commericial share-alike license version 3]

第一到三节讲的都是python的基本组成要素：
- 1.1 安装开发环境
- 1.2 编程要素，表达式、库的引入等
- 1.3 定义函数

因此，在1.4节，设计函数这里开始翻译，用于自己边翻译边理解

### 1.4设计函数

函数是所有程序语言无论其大小的必要组成部分，并作为我们的主要媒介在程序设计语言中表达计算过程。至今为止，我们已经讨论了函数的形式属性以及它们是如何应用的。现在我们将标题转向如何写一个好的函数。基本地，一个好的程序的质量全在于加强函数是抽象这个概念。
- 每一个程序都应该只有负责一个工作，这个工作有一个可识别的短名称以及可以用单行文字来进行表征。一个按顺序执行多项工作的函数应该被拆分到多个函数里面去。
- “不要重复你自己”是软件工程的中心宗旨。简称DRY原则，说的是多个代码片段不应该描述冗余的代码逻辑。相反，逻辑应该只实现一次，给出一个名称，并被多次调用。如果你发现自己复制并粘贴一个代码块，你可能找到了一个进行函数抽象的契机。
- 函数的定义应该具有一般性。平方这个方法恰恰不在Python函数库中，因为这是pow函数（可以将数字提升为任意次幂的函数）的特殊形式。

这些指南提升了代码的可读性，减少错误的数量，通常减少代码编写的总量。分解复杂任务到简洁的函数中是一项需要经验才能掌握的技能。幸运的是，Python提供了几样特性来支持你的努力。

#### 1.4.1 文档

一个函数定义通常会在函数内包含文档定义，叫做`docstring`，必须要有与函数体一样的缩进。Docstrings通常是用三重引号来包含内容，第一行是用于描述函数的作用。接下来的行用于描述参数以及阐明函数的行为：

```
>>> def pressure(v, t, n):
        """Compute the pressure in pascals of an ideal gas.

        Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law

        v -- volume of gas, in cubic meters
        t -- absolute temperature in degrees kelvin
        n -- particles of gas
        """
        k = 1.38e-23  # Boltzmann's constant
        return n * k * t / v
```

当你用一个名字作为参数来调用help函数时，你会看到它的docstring（点击q来退出Python帮助）

`help(pressure)`

当编写Python程序的时候，除了最简单的函数外，都要包含有docstring。要记住，代码只是编写一次，但是常被多次阅读。Python的文档有包含docstring的[指南][docstring guidelines]用于在不同项目之间保持一致性。

**注释** 。Python中的注释能够附加到任意行的结尾上，跟在`#`符号的后面。例如，上面的k的评论是用于描述玻尔兹曼常数。这些评论是不会出现在Python的help函数中的，同时也会被解释器忽略掉。它们只为了人而存在。

#### 1.4.2

定义一般函数的结果是会引入额外的参数。一个函数如果有很多个参数的话在调用时会很尴尬而且也很难阅读。

在Python，我们能够为函数的参数提供默认的值。当调用函数时，具有默认值的参数是可选的。如果（调用函数时）没有被提供，参数的默认值会绑定到形式参数的名字上。例如，如果一个应用通常都是计算一摩尔的粒子的压力，这个值可以作为默认值来提供：

```
>>> def pressure(v, t, n=6.022e23):
        """Compute the pressure in pascals of an ideal gas.

        v -- volume of gas, in cubic meters
        t -- absolute temperature in degrees kelvin
        n -- particles of gas (default: one mole)
        """
        k = 1.38e-23  # Boltzmann's constant
        return n * k * t / v
```

在这个例子中`=`符号意味着两种不同的东西，取决于使用它的上下文。在def声明语句头，`=`号并不执行分配而是表示pressure被调用时当做一个默认的值来用。相比之下，函数体中的k的分配声明将名字k与玻尔兹曼常数的近似值进行绑定。

```
>>> pressure(1, 273.15)
2269.974834
>>> pressure(1, 273.15, 3 * 6.022e23)
6809.924502
```

pressure函数定义为需要三个参数，但在上面第一个调用等式中只提供了两个参数值。在这种情况下，值n取自def声明的默认值。如果第三个参数被提供，默认值就会被忽略。

作为指导，大多数在函数体中用到的数据的值都应该表示为命名参数的默认值，使得它们易于被检查同时能被函数的调用者改变。一些永远不会改变的值，例如基本常数k，可以绑定到函数体或者全局内。

### 1.5 控制流

第五节用于描述控制流，if-elif-else以及一些测试相关的知识，属于基础知识，不翻译。

### 1.6 高阶函数

我们已经知道函数是一种抽象方法，用于描述与它们的参数的特定值无关的复合操作。也就是说，像square函数：

```python
>>> def square(x):
        return x * x
```

我们并没有讨论某个特定值的平方，而是讨论关于获得所有数字的平方的方法。当然，我们可以不去定义这样的函数，而是总写下这样的表达式：

```python
>>> 3 * 3
9
>>> 5 * 5
25
```

并且从不明确提及square。这种做法对于简单的计算如square是足够了，但是对于更加复杂的例子像abs或者fib等要继续保持这样的做法就会变得很困难。一般来说，缺乏函数定义通常会使我们处于不利的地位，迫使我们总是在特定层级即语言的原语（在这个例子中是乘法）上工作，而不是在更高的层次上进行操作。即使我们的程序能够计算平方，但是我们的语言却缺乏表达平方概念的能力。

我们对于强大编程语言的其中一个需求是它提供的通过为常见模式分配名称构建抽象然后直接通过调用名称来执行工作的能力。就像我们接下来看到的例子，这是一个在代码中重复的常见模式，但是是与许多不同的函数一起使用。这种模式也可以通过命名来进行抽象化。

要将某些一般模式作为命名概念，我们需要构造函数让它能够接受其他函数作为其参数或者将函数作为其返回值。能够操纵函数的函数被称为高阶函数。本节将会展示高阶函数是如何能够作为强大的抽象机器从而大大增强我们的语言的表达能力的。

#### 1.6.1 函数作为参数

研究一下接下来的三个都是用来计算总数的函数。第一个，sum_naturals，计算n个自然数的和

```python
>>> def sum_naturals(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + k, k + 1
        return total
>>> sum_naturals(100)
5050
```

第二个，sum_cubes，计算n个自然数的平方和。

```python
>>> def sum_cubes(n);
        total, k = 0, 1
        while k <= n:
            total, k = total + k * k * k, k + 1
        return total
>>> sum_cubes(100)
25502500
```

第三个，pi_sum，计算一系列项的总和

![pi_sum][pi_sum]

其非常缓慢地收敛到pi

```python
>>> def pi_sum(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + 8 / ((4 * k - 3) * (4 * k - 1)), k + 1
        return total
>>> pi_sum(100)
3.1365926848388144
```

这三个函数很显然使用了一种相同的底层模式，它们的大部分都是相同的，只有函数名以及函数中计算要累加的项的k的用法不同。我们可以通过在相同的模板中填充槽来生成每一个函数。

```
def <name>(n):
    total, k = 0, 1
    while k <= n:
        total, k = total + <term>(k), k + 1
    return total
```

这是这种共同模式存在的强有力的证据，等待着将有用的抽象带到表面上来。这些函数每一个都是求和术语，作为一个程序设计师，我们都希望我们的语言足够强大以至于我们能够能够编写函数来表达求和的概念，而不是对特定的值进行求和。在Python中我们可以轻易地将上面展示的模板中的槽替换成形式参数：

在下面的例子中，summation需要两个参数，上限n以及用来计算第k次值的函数term。我们能像使用其他函数一样来使用summation函数，它简洁地表现了求和（概念）。用点时间来一步步执行这个例子，注意下cube是如何绑定到局部命名term上的并保证结果1*1*1 + 2*2*2 + 3*3*3 = 36被正确计算的。在这个例子中，不需要的帧会被移除以用于节省空间。

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20summation(n,%20term%29%3A%0A%20%20%20%20total,%20k%20%3D%200,%201%0A%20%20%20%20while%20k%20%3C%3D%20n%3A%0A%20%20%20%20%20%20%20%20total,%20k%20%3D%20total%20%2B%20term(k%29,%20k%20%2B%201%0A%20%20%20%20return%20total%0A%0Adef%20cube(x%29%3A%0A%20%20%20%20return%20x*x*x%0A%0Adef%20sum_cubes(n%29%3A%0A%20%20%20%20return%20summation(n,%20cube%29%0A%0Aresult%20%3D%20sum_cubes(3%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

使用一个**可识别**的函数来返回其参数，我们也能够用完全相同的summation函数来计算自然数的和。

```python
>>> def summation(n, term):
        total, k = 0, 1
        while k <= n:
            total, k = total + term(k), k + 1
        return total
>>> def identity(x):
        return x
>>> def sum_naturals(n):
        return summation(n, identity)
>>> sum_naturals(10)
55
```

这个summation函数也能够直接调用，而不用对特定序列来定义另一个函数

```python
>>> summation(10, square)
385
```

我们可以通过定义一个pi_term函数来计算每一次的值从而用我们的summation抽象函数来定义一个pi_sum，我们输入参数1e6，是1*10^6 = 1000000的简写，来生成pi的近似值。

```python
>>> def pi_term(x):
        return 8 / ((4*x-3) * (4*x-1))
>>> def pi_sum(n):
        return summation(n, pi_term)
>>> pi_sum(1e6)
3.141592153589902
```

#### 1.6.2 作为一般方法的函数



<!-- Images -->
[pi_sum]: /images/Composing-Programs/Chapter-1/pi_sum.png

<!-- Urls -->
[SICP]: http://mitpress.mit.edu/sicp
[Creative Commons attribution non-commericial share-alike license version 3]: http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US
[docstring guidelines]: http://www.python.org/dev/peps/pep-0257/
