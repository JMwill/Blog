title: 程序构成-第二章
tags:
- 译文
- Design Programs
---

## 第二章: 构筑抽象数据

### 2.1 介绍

在第一章我们集中关注计算过程, 以及函数对程序设计的作用与影响. 我们已经见识过如何使用原始数据(numbers)以及原始操作符(算术), 如何通过组合和控制来组成复合函数, 以及通过给计算过程赋予名称来创建函数抽抽象. 我们也看到高阶函数通过允许我们自行控制, 从而推理出一般计算方法来增强我们的语言的力量. 这就是编程的本质.

这一章主要关注数据. 我们在这里探讨的技术允许我们表达以及操作许多不同领域的信息. 由于因特网的爆炸性增长, 提供给我们大量在线且免费的结构化信息, 并且可以在大范围不同问题上进行计算. 有效使用內建的以及用户定义的数据类型是数据处理程序的根本. 

#### 2.1.1 基本数据类型

每一种数据在Python中都有一个类属, 这个类属决定了这个值是什么类型. 共享的数据同时具有共享的行为. 例如, 整数1以及2都是int类的实例. 这两个值能够进行类似的处理. 例如, 它们都可以被另外一个整数加或者减. 內建的type函数允许我们检查任何数值的类型.

```python
>>> type(2)
<class 'int'>
```

我们目前使用的数值知识少量Python语言的內建_本地_数据类型. 本地数据类型具有以下属性:

1. 有对原生类型的值进行定义的表达式, 叫做常量
2. 有对原生类型的值进行操作的內建函数以及操作符

int类是用来表示整数的原生数据类型. 整型常量(相邻数字序列)表达为int值, 以及数学运算符来操作这些值. 

```python
>>> 12 + 3000000000000000000000000
3000000000000000000000012
```

Python包含有三种本地数据类型: 整型(int), 实数(float), 以及复数(complex). 

```python
>>> type(1.5)
<class 'float'>
>>> type(1+1j)
<class 'complex'>
```

**Floats**: 名字float来源于Python以及许多其他的程序语言实数的表示方式是以: "浮点(floating point)"来表示的. 至于数字是如何表示的这些细节不在我们这一节的讨论范围之内, 而一些int以及float对象的高级差异需要重点了解. 尤其是, int对象能够准确地表示整数, 对其大小没有任何近似以及限制. 另一方面, float对象能够表示较宽范围内的分数, 但不是所有的数字都能够准确表示, 同时它们还具有最小值以及最大值. 因此, float数值应该被视为实际值的近似值来对待. 这些近似值只具有有限的精度. 合并浮点数会导致一些精度错误; 如果不用近似值的话下面的表达式计算后应该会等于7:

```python
>>> 7 / 3 * 3
7.0
>>> 1 / 3 * 7 * 3
6.999999999999999
```

虽然上面是int的组合, 用一个int除以另一个会得到一个float的值: 一个被截断了的近似值, 也就是两个整数相除的实际比率. 

```python
>>> type(1/3)
<class 'float'>
>>> 1/3
0.3333333333333333
```

当我们进行相等性测试的时候就会出现近似值的问题.

```python
>>> 1/3 == 0.333333333333333312345  # Beware of float approximation
True
```

这些int类型与float类型之间的微妙不同, 对程序的编写具有广泛的影响, 因此它们的细节程序员必须要铭记在心. 幸运的是, 只有少量的本地数据类型, 限制了精通编程语言所需要的记忆量. 此外, 这些相同的细节在许多编程语言中也是一致的. 由社区准则强制执行, 如: [IEEE 754 floating point standard][1]

**非数字类型**. 数值能够代表许多其他类型的数据, 例如声音, 图像, 地点, 网址, 网络连接等等. 少量是通过本地数据类型来表示的, 例如代表真(True)和假(False)的布尔(bool)类型. 大多数值的类型都需要程序员来使用本章中研究的组合和抽象手段来进行定义. 

接下来的部分将介绍更多Python的本地数据类型, 侧重于它们在创建有用的数据抽象中所起到的作用. 那些对于更加深入的细节感兴趣的人可以阅读一下深入Python3这本书的[本地数据类型][2]这一章,写出了所有Python的本地数据类型的实用概述以及如何对它们进行操作, 包括大量的用法例子以及练习提示.

### 2.2 数据抽象

当我们考虑世界上的广泛的事物的时候, 我们会想要将它在我们的程序中表现出来, 我们会发现它们大多数都具有复合结构. 例如, 一个地理位置有经度以及纬度坐标. 为了表示位置, 我们会想让我们的程序语言有能力将经度和纬度合在一起以形成一对, 作为一个我们的程序能够操作的一个单一的概念单元, 但是它也具有两个部分可以进行单独考虑.

使用复合数据能够让我们提升程序的模块性, 如果我们能够将地理位置作为一个整体来进行操作, 然后我们就可以对程序使用位置进行计算中是如何对这些地理位置进行表示的细节进行屏蔽. 一般的隔离程序各个部分的技术, 都是处理数据是如何被表示, 以及处理数据是如何被操作的强大的设计方法, 这方法称为数据抽象. 数据抽象让程序更容易被设计, 维护, 以及修改

数据抽象在性质上跟函数抽象那一章相似. 当我们创建一个函数抽象, 函数是如何实现的细节能够被压制, 以及特定的函数本身能够被任何其他的具有相同整体行为的函数进行替换. 换句话说, 我们可以实现一个抽象来将函数使用的方式与函数如何实现的细节上进行分离. 类似地, 数据抽象对复合数据的使用方式与如何构造的细节进行了隔离. 

数据抽象的基本思想是结构化程序, 以便于它们对抽象数据进行操作. 也就是说, 我们的程序应该以尽可能少的以对数据进行假设的方式来使用数据. 同时, 数据的具体表现应该定义为程序的一个独立的部分.

程序的这两个部分, 对数据抽象进行操作的部分以及定义具体表示的部分, 通过一组小的函数进行连接, 这些函数根据具体表示实现抽象数据. 为了说明这种技术, 我们需要考虑如何设计一套函数来操作有理数.

#### 2.2.1 例子: 有理数

一个有理数就是整数的比率, 有理数是构成实数的重要子类. 一个有理数如1/3或者17/29通常写作:

`<numerator>/<denominator>`

而`<numerator>`以及`<denominator>`都是整数的占位符. 这些部分都需要用来准确地表征有理数的值. 实际上整数相除得到一个浮点数的近似值, 失去了整数的精确度.

```python
>>> 1/3
0.3333333333333333
>>> 1/3 == 0.333333333333333300000  # Dividing integers yields an approximation
True
```

然而, 我们可以通过将分子和分母组合在一起来为有理数创建一个精确的表示. 

我们从使用函数的抽象中可以知道, 我们可以在程序的某些部分实现之前开始进行编程. 让我们假设我们已经有办法从一个分子以及一个分母中构造一个有理数开始. 我们还假设, 给定一个有理数, 我们有方法选定它的分子和分母的部分. 让我们进一步假设构造器以及选择器可具有一下的三个功能:

- **rational(n, d)**以分子为n分母为d的形式返回一个有理数
- **numer(x)**返回有理数中的分子x
- **denom(x)**返回有理数中的分母x

在这里我们使用程序设计中的强大策略: _祈愿思维_. 我们还没有讲述一个有理数是如何表示的, 或者函数number, denom, 以及rational应该怎么实现. 即使这样, 如果我们定义了这三个函数, 我们可以对有理数进行加, 乘, 打印, 以及测试相等性等操作:

```python
>>> def add_rationals(x, y):
        nx, dx = numer(x), denom(x)
        ny, dy = numer(y), denom(y)
        return rational(nx * dy + ny * dx, dx * dy)

>>> def mul_rational(x, y):
        return rational(numer(x) * numer(y), denom(x) * denom(y))

>>> def print_rational(x):
        print(numer(x), '/', denom(x))

>>> def rationals_are_equal(x, y):
        return numer(x) * denom(y) == numer(y) * denom(x)
```

现在我们具有定义在选择器函数number以及denom和构造器函数rational之上的操作函数, 但是我们还没有定义这些选择器函数以及构造器函数. 我们需要一种方法来将分子和分母进行粘合, 形成一个复合值.

#### 2.2.2 一对

为了让我们实现正确等级的数据抽象, Python提供了一种复合数据结构叫做list, 能够通过将表达式放到方括号内并用逗号分隔开来构造, 这种表达式就叫做列表字面量.

```python
>>> [10, 20]
[10, 20]
```

列表中的元素可以用两种方式来进行访问, 第一种方式是通过我们熟悉的多重分配的方法, 通过对list对象中的元素进行解包然后绑定每一个元素到不同的名字.

```python
>>> pair = [10, 20]
>>> pair
[10, 20]
>>> x, y = pair
>>> x
10
>>> y
20
```

第二个访问方法是通过list的元素选择运算符, 也通过方括号来进行表达. 不像列表字面量, 一个方括号表达式直接跟在另一个表达式后面不以生成列表值来运行, 而是在前面的表达式中选择一个元素.

```python
>>> pair[0]
10
>>> pair[1]
20
```

在Python中的列表(以及大多数其他的编程语言)是以0索引作为开始的, 这意味着索引0选定第一个元素, 索引1选定第二个, 等等. 一个支持这个索引惯例的直觉是索引代表一个元素偏离列表开始位置有多远. 

跟元素选择操作符相等的函数叫做getitem, 它也用索引0作为开始位置来对列表对象进行选取.

```python
>>> from operator import getitem
>>> getitem(pair, 0)
10
>>> getitem(pair, 1)
20
```

两个元素的列表不是表示一对的唯一方法, 任何将两个值捆绑到一块的方法都可以认为是一对. 只是列表是一种常用的方法. 列表也可以容纳超过两个对象, 正如我们本章接下来要进行讨论的. 

**表示有理数**. 现在我们能够将有理数表示为一对整数的组合: 一个分子和一个分母.

```python
>>> def rational(n, d):
        return [n, d]

>>> def numer(x):
        return x[0]

>>> def denom(x):
        return x[1]
```

结合早先我们定义的算术运算, 我们可以用我们已经定义好的函数来操作有理数.

```python
>>> half = rational(1, 2)
>>> print_rational(half)
1 / 2
>>> third = rational(1, 3)
>>> print_rational(mul_rational(half, third))
1 / 6
>>> print_rational(add_rationals(third, third))
6 / 9
```

像上面例子显示的那样, 我们的有理数的实现不会将有理数减少到最低项. 我们可以通过改变rational函数的实现来修复这个缺陷. 如果我们有一个函数来计算两个整数的最大公分母, 我们就可以在构建有理数对时用它来将分子和分母减少为最底项. 跟许多有用的工具一样, 在Python的库中已经有这样的一个函数了. 

```python
>>> from fractions import gcd
>>> def rational(n, d):
        g = gcd(n, d)
        return (n//g, d//g)
```

整除运算符, `//`, 表示整除, 也就是对相除的结果将向下舍入小数部分. 由于我们已经知道g能够完全整除n以及d, 整除在这种情况下是精确的. 这个rational函数的合理地进行了修正保证了有理数以最低项来表示.

```python
>>> print_rational(add_rationals(third, third))
2 / 3
```

这种改进是通过改进构造函数而不用改变其他函数(即实现实际运算的函数)来完成的.

#### 2.2.3 抽象屏障

在继续(介绍)更多的组合数据和数据抽象的例子之前, 让我们思考一下有理数例子提出的一些问题. 我们根据构造函数rational和选择器numer, denom定义操作. 一般来说, 数据抽象的基础思想是识别一组基础操作, 根据这些操作来表达某种类型的值的所有操作, 然后只使用这些操作来处理数据. 通过限制这些操作的使用方式, 将会更容易改变抽象数据的表示而不用修改程序的行为.

对于有理数, 程序的不同部分使用不同的操作来操纵有理数, 如下表所述:

|**Parts of the program that...**|**Treat rational as...**|**Using only...**|
|:-------------------------------|:-----------------------|:----------------|
|Use rational numbers to perform computation|whole data values|`add_rational`, `mul_rational`, `rationals_are_equal`, `print_rational`|
|Create rationals or implement rational operations|numerators and denominators|`rational`, `numer`, `denom`|
|Implement selectors and constructor for rationals|two-element lists|list literals and element selection|

|**程序的每个部分...**|**将有理数当做...**|**只用作**|
|:------------------|:----------------|:--------|
|用有理数来执行计算|整个数值|`add_rational`, `mul_rational`, `rationals_are_equal`, `print_rational`|
|创建有理数或操作有理数|分子以及分母|`rational`, `numer`, `denom`|
|实现有理数的构造器以及选择器|两个元素的列表|列表字面量以及元素选择|

在上面的每一层, 最后一列的函数实现了一个抽象屏障. 这些函数通过更低层次的抽象来实现来被更高层的函数调用.

违反一个抽象屏障的情况发生在每当可以在较高级别函数中使用程序的一部分时, 却使用较低级别的函数来实现. 举个例子, 一个计算有理数平方的函数最好是根据`mul_rational`来实现, 而无需对有理数的实现进行任何假设.

```python
>>> def square_rational(x):
        return mul_rational(x, x)
```

直接涉及到分子以及分母会违反一层抽象屏障.

```python
>>> def square_rational_violating_once(x):
        return rational(numer(x) * numer(x), denom(x) * denom(x))
```

假设有理数用两个元素的列表表示会违反两层抽象屏障.

```python
>>> def square_rational_violating_twice(x):
        return [x[0] * x[0], x[1] * x[1]]
```

抽象屏障让程序更容易管理与修改. 越少函数依赖于特定的表示, 当想改变其中一个的表示的时候就需要越少的改动. 所有的这些`square_rational`的实现都具有正确的行为, 但是只有第一个对于未知的变化是健壮的. `square_rational`函数即使在我们修改有理数的表示的时候也不需要更新. 相比之下, `square_rational_violating_once`每当选择器或者构造器的特征改变的时候都需要进行修改, 而`square_rational_violating_twice`则在有理数的实现有任何改变时都需要进行更新.

#### 2.2.4 数据的属性

抽象屏障能够塑造我们思考数据的方式. 对有理数进行有效的表示是不限于任何特定的实现的(如具有两个元素的列表); 它是rational函数返回的一个值, 这个值能够输入到numer以及denom当中. 除此之外, 必需维持构造器跟选择器之间恰当的关系. 也就是说, 如果我们从整数n跟d中构造一个有理数x, 应该得到一种情况是numer(x)/denom(x)等于n/d.

一般来说, 我们可以用选择器函数以及构造器函数集合与一些行为条件一起来表示抽象数据. 只要这些行为条件满足(例如上面的除法属性), 选择器以及构造器函数构成了一种数据的有效表示. 在抽象屏障之下的细节可能会有更改, 但是如果行为没有改变, 那数据抽象依然是有效的, 然后任何使用这些数据抽象编写的程序依然是正确的.

这一观点能够进行广泛地应用, 包括我们用于实现有理数的数据对. 我们从没有说过什么是数据对, 只有语言提供的创建以及操作两个元素的列表方法. 我们需要实现的数据对的行为是它能将两个值黏合在一起. 而行为条件,

- 如果一个数据对p由值x跟y构造, 那么select(p, 0)返回x, select(p, 1)返回y.

我们实际上不需要用列表类型来创建数据对, 作为替代, 我们可以实现两个函数pair以及select来满足这个描述, 就像两个元素的列表一样.

```python
>>> def pair(x, y):
        """Return a function that represents a pair."""
        def get(index):
            if index == 0:
                return x
            elif index == 1:
                return y
        return get

>>> def select(p, i):
        """Return the element at index i of pair p."""
        return p(i)
```

有了这个实现, 我们可以创建并操作数据对.

```python
>>> p = pair(20, 14)
>>> select(p, 0)
20
>>> select(p, 1)
14
```

这种高阶函数的使用方式能够跟我们对于数据是什么这种直观的概念进行对应. 然而, 这些函数足够表示我们程序中用到的数据对. 函数足以表示复合数据.

用函数展示数据对的意思不代表Python就是以这种方式来运行的(处于效率的原因, 列表的实现更加的直观)但是它能以这种方式运行. 函数型的表示虽然模糊, 但它完全具有表示数据对的能力, 因为它满足数据对唯一需要满足的条件. 数据抽象的实践允许我们轻易地在各种表示中进行切换.

### 2.3 序列

序列就是一个值的有序集合. 序列在计算机科学中是强大的, 基本的抽象. 序列不是某个特定的內建类型的实例或者抽象数据表示, 而是在一些不同类型的数据之间共享行为的集合. 也就是说, 有许多种类型的序列. 但是它们都共享共同的行为. 尤其是,

**长度**. 一个序列具有有限的长度. 一个空序列的长度是0.

**元素选择**. 一个序列的对于任何小于它长度的非负整数的索引值都对应它的一个元素, 第一个元素从0开始.

Python包含的一些本地数据类型就是序列, 最重要的莫过于**列表**了.

#### 2.3.1 列表

一个列表就是一个具有任意长度的序列. 列表具有一大套內建行为, 以及表示这些行为的特殊语法. 我们已经见识过列表字面量了, 也就是用来运算生成列表实例那个, 以及元素选择表达式, 即用来获取列表中的值的语法. 內建的len函数用于返回一个序列的长度. 下面, digits是一个具有四个元素的列表. 索引为3的元素值是8.

```python
>>> digits = [1, 8, 2, 8]
>>> len(digits)
4
>>> digits[3]
8
```

另外, 列表可以加在一起, 以及与一个整数相乘. 对于序列来说, 加法以及乘法不会添加或者乘里面的元素, 而是复制序列本身并将它们合并在一起. 也就是说, 在operator模块下的add函数(以及符号+)返回的是添加的参数级联后生成的一个列表. 而在operator中的mul函数(以及`*`号)能够传入一个列表以及一个整数然后返回另一个列表, 这个列表是由k次重复的源列表组成的.

```python
>>> [2, 7] + digits * 2
[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]
```

任意的值都可以包含在列表中, 包括其他的列表. 为了选择到包括在列表里面的列表这样深层次嵌套的元素可以多次应用列表元素选择语法.

```python
>>> pairs = [[10, 20], [30, 40]]
>>> pairs[1]
[30, 40]
>>> pairs[1][0]
30
```

#### 2.3.2 序列迭代

在很多情况下, 我们会想要对序列的元素进行迭代然后反过来对每个元素执行一些计算. 这种模式是如此的常见以至于Python有一个额外的控制语句来处理顺序的数据: for语句.

想一下计算一个值在序列中出现的次数这样的一个问题, 我们可以实现一个函数用while循环来进行计数.

```python
>>> def count(s, value):
        total, index = 0, 0
        while index < len(s):
            if s[index] == value:
                total += 1
            index += 1
        return total

>>> count(digits, 8)
2
```

Python的for语句能够简化这个函数体通过直接对元素值进行迭代而根本不需要引入名称index.

```python
>>> def count(s, value):
        total = 0
        for elem in s:
            if elem == value:
                total += 1
        return total

>>> count(digits, 8)
2
```

for语句由单个子句组成, 形式如下:

```
for <name> in <expression>:
    <suite>
```

一个for语句会按照以下的步骤执行:

1. 计算头部表达式`<expression>`, 必须返回一个可迭代的值.
2. 遍历该可迭代值中的每一个元素, 是为了:
    1. 将这个元素值当前域的中的`<name>`进行绑定
    2. 执行`<suite>`

这个执行过程引用的是可迭代的值, 列表是序列的一种, 而序列是一种可迭代的值. 它们的元素按照它们原有的顺序被考虑. Python包括其他的可迭代的值, 但是目前我们会专注于序列; 术语"可迭代"的一般定义出现在第四章的迭代器部分.

这个计算过程的一个重要的意义是`<name>`会在for语句运行后绑定到序列中的最后一个元素. for循环引入了另外一种可以让运行环境随语句执行而更新的方式.

**序列解包**. 在程序中的常见模式是有一个以序列为元素的序列, 但元素都是固定长度的. 一个for语句可能会包含有多个名称在它的头部用来对序列中的每一个序列元素"解包"到各自对应的名称上. 例如, 可能会有一个以包含两个元素的序列为元素的序列:

```python
>>> pairs = [[1, 2], [2, 2], [2, 3], [4, 4]]
```

然后希望从中找到这些序列对中两个数字是相等的序列对

```python
>>> same_count = 0
```

下面的for语句在它的头部有两个变量名x和y, 这两个变量名会分别跟序列对的第一和第二个元素进行绑定:

```python
>>> for x, y in pairs:
        if x == y:
            same_count += 1

>>> same_count
2
```

这种将多个名称以固定长度的顺序绑定到多个值的模式称为序列解包; 这跟我们在赋值语句中看到的绑定多个名称到多个值的模式是一样的.

**范围**. 一个range类型是Python中另一个內建的序列类型, 它代表了一个整数的区间. 区间由range来创造, 需要两个整数作为参数: 第一个数字和一个超出所需范围内的最后一个数字.

```python
>>> range(1, 10) # 包含1, 但不包含10
range(1, 10)
```

调用list构造器计算出在一个在范围内的与范围相符的列表, 因此可以很容易地检查里面的元素.

```python
>>> list(range(5, 8))
[5, 6, 7]
```

如果只给定一个参数, 这被解析为构建一个从零开始到超出所需范围内的最后一个数字的区间.

```python
>>> list(range(4))
[0, 1, 2, 3]
```

区间通常出现在for表达式的头部来指定`<suite>`部位应该执行的次数: 有一个共同的约定是如果在for的头部写入的名称在`<suite>`中没有用到的话就用单个下划线作为名称:

```python
>>> for _ in range(3):
        print('Go Bears!')

Go Bears!
Go Bears!
Go Bears!
```

下划线对于解释器环境而言只是另外的一个名称, 但是它在程序员之间却是具有常规的意义, 那就是表明这个名称不会现在在之后的任何表达式中.

#### 2.3.3 序列处理

序列是一种如此常见的用于组成复合数据的形式以至于整个程序通常都围绕这个单一抽象来进行组织. 模块化组件同时以序列作为输入和输出能够对数据处理过程进行混合以及匹配. 复杂组件能够通过将序列处理操作连接在一起形成管道来进行定义, 而每个处理都是简单和集中的.

**列表推导**. 很多的序列处理操作能够通过为序列中的每个元素计算一个固定的表达式然后收集结果的值到一个结果序列中来表示. 在Python中, 一个列表推导式是一个执行这样的计算的表达式:

```python
>>> odds = [1,3,5,7,9]
>>> [x + 1 for x in odds]
[2,4,6,8,10]
```

上面的for关键词不是for语句的一部分, 而是列表表达式的一部分因为它包含在方括号里面. 而子表达式 x+1 是将x顺序绑定到每一个odds中的元素来进行运算, 然后收集每次运算的结果到列表中.

另一个常见的列表推导操作是去选择一个满足某些结果的子集. 列表推导能够表达这种模式, 例如选择所有odds中的能够整除25的元素:

```python
>>> [x for x in odds if 25 % x == 0]
[1, 5]
```

列表推导的一般形式是:

`[<map expression> for <name> in <sequence expression> if <filter expression>]`

为了运算一个列表推导, Python会计算`<sequence expression>`, 这个表达式必须要返回一个可迭代值. 然后, 对每个元素按照顺序, 将元素的值与`<name>`进行绑定, 接着运算过滤表达式, 然后如果过滤结果返回真值, `map expression`(映射表达式)将会执行, 最后结果会被收集到一个列表中.

**聚合**. 第三个序列处理的一般模式是将一个序列中所有的值聚合到单一的一个值中. 內建函数sum, min, 以及max所有都是聚合函数的例子.

通过结合这些对每个元素进行运算, 选择元素的子集, 以及聚集元素的模式, 我们可以使用序列处理方法来解决问题.

一个完备正整数指的就是一个等于它的除数的总和. n的除数是小于n且能均分n的正整数. 可以通过列表推导来运算从而列出这些n的除数

```python
>>> def divisors(n):
        return [1] + [x for x in range(2, n) if n % x == 0]

>>> divisors(4)
[1, 2]
>>> divisors(12)
[1, 2, 3, 4, 6]
```

使用divisors函数, 我们可以用其他的列表推导来计算出从1到1000的所有的完备数. (1通常也被认为是完备数, 但是它不符合我们对divisors的定义)

```python
>>> [n for n in range(1, 1000) if sum(divisors(n)) == n]
[6, 28, 496]
```

我们可以复用我们定义的divisors来解决另外的问题, 找出一个具有固定面积以及整数长度边长的长方形的最小周长. 长方形的面积等于它的高乘以宽. 而且, 给定面积以及高, 我们可以计算出宽. 我们可以肯定地说, 长和宽都能均分面积的话, 就可以保证边长都是整数.

```python
>>> def width(area, height):
        assert area % height == 0
        return area // height
```

长方形的周长等于它边长的总和

```python
>>> def perimeter(width, height):
        return 2 * width + 2 * height
```

具有整数边长的长方形的高必须是它面积的除数. 我们可以通过考虑它所有的高来计算最小周长.

```python
>>> def minimum_perimeter(area):
        heights = divisors(area)
        perimeters = [perimeter(width(area, h), h) for h in heights]
        return min(perimeters)

>>> area = 80
>>> width(area, 5)
16
>>> perimeter(16, 5)
42
>>> perimeter(10, 8)
36
>>> minimum_perimeter(area)
36
>>> [minimum_perimeter(n) for n in range(1, 10)]
[4, 6, 8, 8, 12, 10, 16, 12, 12]
```

**高阶函数**

我们在序列处理中观察到的一般模式可以用高阶函数来进行表示. 首先, 为序列中的每个元素运行一个表达式可以通过对每一个元素应用函数来来表示.

```python
>>> def apply_to_all(map_fn, s):
        return [map_fn(x) for x in s]
```

通过对每一个元素应用的函数表达式然后仅选择能使表达式结果为真的元素.

```python
>>> def keep_if(filter_fn, s):
        return [x for x in s if filter_fn(x)]
```

最后, 许多形式的聚合可以表示为反复应用一个带有两个参数的函数, 分别是进行**reduced**后的值, 以及顺序应用的每一个元素.

```python
>>> def reduce(reduce_fn, s, initial):
        reduced = initial
        for x in s:
            reduced = reduce_fn(reduced, x)
        return reduced
```

例如, reduce可以用来将序列中的所有元素乘到一起. 使用mul替代`reduce_fn`, 1替代`initial`, reduce可以用来将序列中的数都乘到一起.

```python
>>> reduce(mul, [2, 4, 6, 8], 1)
64
```

我们也可以用这些高阶函数来找寻完备数

```python
>>> def divisors_of(n):
        divides_n = lambda x: n % x == 0
        return [1] + keep_if(divides_n, range(2, n))

>>> divisors_of(12)
[1, 2, 3, 4, 6]
>>> from operator import add
>>> def sum_of_divisors(n):
        return reduce(add, divisors_of(n), 0)

>>> def perfect(n):
        return sum_of_divisors(n) == n

>>> keep_if(perfect, range(1, 1000))
[1, 6, 28, 496]
```

**常规名称**

在计算机科学的社群中, `apply_to_all`一般叫做`map`, `keep_if`一般叫做`filter`. 在Python中, 內建的map以及filter是这些方法的泛化, 且并不返回列表对象. 这些方法会在第四章来进行讨论. 上面的定义相当于用列表构造器到处理內建的map以及filter调用后所返回结果.

```python
apply_to_all = lambda map_fn, s: list(map(map_fn, s))
keep_if = lambda filter_fn, s: list(filter(filter_fn, s))
```

reduce函数构建在Python的标准库的`functools`模块中. 在这个版本中, initial参数是可选的.

```python
>>> from functools import reduce
>>> from operator import mul
>>> def product(s):
        return reduce(mul, s)

>>> product([1, 2, 3, 4, 5])
120
```

在Python程序中, 直接使用列表推导是比使用高阶函数更一般的模式, 但两者在列表处理中都是广泛使用的方法.

#### 2.3.4 序列抽象

我们已经介绍了两种满足序列抽象的本地数据类型: 列表和区间(lists and ranges). 两者都满足这部分开始所设的条件: 长度以及元素选择. Python包含了额外的两个序列类型的行为用来进行序列抽象的拓展.

**成员**. 一个值能够就是否是一个序列的成员来进行测试. Python有两个操作符`in`以及`not in`其计算的结果是True或者False取决于元素是否出现在序列中.

```python
>>> digits
[1, 8, 2, 8]
>>> 2 in digits
True
>>> 1828 not in digits
True
```

**切片**. 序列都包含更小的序列. 一个序列的切片是原有序列的任何一个连续片段, 由一对整数来指定. 就像range构造函数一样, 第一个整数指定了切片的起始下标, 然后第二个整数指定了超过结束下标的数.

在Python中, 序列切片的表达式跟元素选择类似, 用方括号包裹. 一个冒号分割起始以及结束索引. 任何省略的边界都被认定为一个极值: 0是开始下标的极值, 而序列的长度则是结束下标的极值.

```python
>>> digits[0:2]
[1, 8]
>>> digits[1:]
[8, 2, 8]
```

切片也可以用于树的分支上. 例如, 我们可能想要对一些树的分支数进行限制. 一个共同的树转型通过将原始树进行分组组合并调整分支得出的一个二叉树叫做二值化计算.

```python
>>> def right_binarize(tree):
        """Construct a right-branching binary tree."""
        if is_leaf(tree):
            return tree
        if len(tree) > 2:
            tree = [tree[0], tree[1:]]
        return [right_binarize(b) for b in tree]

>>> right_binarize([1, 2, 3, 4, 5, 6, 7])
[1, [2, [3, [4, [5, [6, 7]]]]]]
```

对Python序列抽象中的这些额外行为进行枚举给我们一个机会来反映一个一般有用的数据抽象的组成. 抽象的丰富性(也就是说它包含的行为有多少)是有意义的. 对用户来说, 一个抽象的, 额外的行为可能很有帮助. 另一方面, 用一个新类型来满足对丰富抽象性的要求可能很具挑战性. 另一个丰富抽象性的负面后果是它们可能需要用户用更长的时间来学习.

序列具有丰富的抽象性因为因为它们在计算机中是如此的无所不在, 以至于需要学习一些复杂的行为是合理的, 一般来说, 大多数用户定义的抽象应该尽可能保持简单.

**深入阅读**. 切片符号收录了各种各样的特殊例子, 例如负的起始值, 结束值以及步进大小. 一个完整的描述出现在Dive Into Python 3的子节中叫做[切片列表][3]. 在这节章中, 我们只会使用到上面提及的基础特性.

#### 2.3.5 字符串

文本值在计算机科学中可能是比数字要更一般的存在. 作为例子, Python程序的都是以文本进行编写以及存储. Python中作为文本的本地数据类型被叫做字符串, 而对应的构造器就是`str`.

在Python中关于字符串的表现, 表达以及操作有很多的细节. 字符串是另一个丰富抽象的例子, 一个需要程序员承诺牢固地掌握的部分. 此部分会用作对基本字符串行为的简明介绍.

字符串字面表达式通过用单引号或者双引号作为记号来包围可以表达任意的文本.

```python
>>> 'I am string!'
'I am string!'
>>> "I've got an apostrophe"
"I've got an apostrophe"
>>> '您好'
'您好'
```

我们已经在代码中见识过字符串了, 如`docstring`, `print`函数的调用中, 以及在`assert`语句中的错误消息.

字符串满足我们在本节最开始介绍的序列的两个基本条件: 它们具有长度以及支持元素选择.

```python
>>> city = 'Berkeley'
>>> len(city)
8
>>> city[3]
'k'
```

属于字符串本身也是字符串, 只不过它们只有一个字符. 字符是字母表的任意单个字符, 标点符号, 或者其他符号. 不像许多其他的编程语言, Python没有分开字符类型; 任何文本都是字符串, 单一一个字符代表一个长度为一的字符串.

就像列表, 字符串也可以用加法或者乘法来进行结合.

```python
>>> 'Berkeley' + ', CA'
'Berkeley, CA'
>>> 'Shabu ' * 2
'Shabu Shabu '
```

**成员**. 字符串的行为发散自Python中的其他序列类型. 字符串抽象不符合我们描述的列表以及区间那样的全序列抽象, 尤其是, 当成员运算符`in`应用到字符串时, 却会有跟应用到序列上完全不同的行为表现. 它匹配的是子字符串而不是元素.

```python
>>> 'here' in "Where's Waldo?"
True
```

**多行文本**. 字符串并不限制只有一行. 三重引号划定了字符串文本可以跨越多行的范围. 我们已经对docstring广泛使用这个三重引号了.

```python
>>> """The Zen of Python
claims, Readability counts.
Read more: import this."""
'The Zen of Python\nclaims, "Readability counts."\nRead more: import this.'
```

在上面打印出来的结果中, 那个`\n`(发音是"backlash en")是一个单元素, 用来代表一个新行. 即使它是用两个字符来表示的(backslash 以及 n), 它在长度以及元素选择上依然被认为是单个字符.

**字符串强制转换**. 一个字符串能够从Python的任何对象中通过调用`str`构造器函数以一个对象作为它的参数来构建. 这个字符串的特性对于从各种类型的对象中构造描述性的字符串是十分有用的.

```python
>>> str(2) + ' is an element of ' + str(digits)
'2 is an element of [1, 8, 2, 8]'
```

**深入阅读**. 编码文本在计算机中是一个复杂的主题. 在这一章中, 我们会抽象出字符串是如何表示的细节. 然而, 对许多应用来说, 字符串是如何被计算机编码的特定细节是是必要的知识. 在[The strings chapter of Dive Into Python3][4]中提供了字符编码以及Unicode的描述

#### 2.3.6 树

我们有将一个列表作为另一个列表内的元素来使用的能力, 在我们的编程语言中提供了一种新的组合手段. 这种能力叫做数据类型的闭包属性. 一般来说, 如果组合数据的方法组合出来的结果本身可以用于这个组合方法就说这个组合方法具有闭包属性. 闭包是任何组合手段的关键源泉, 因为它允许我们去创建分层的结构--由部件组成的结构, 而这个部件本身又是由其他部件构成的等等.

我们可以在环境图中通过块以及指针符号对列表进行可视化, 一个列表描述为一系列包含列表中元素的相邻块. 原始值如数字, 字符串, 布尔值, 以及None值会出现在元素块中, 合成的数据, 如函数值, 以及其他列表, 会用一个箭头来表示.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=one_two%20%3D%20%5B1,%202%5D%0Anested%20%3D%20%5B%5B1,%202%5D,%20%5B%5D,%0A%20%20%20%20%20%20%20%20%20%20%5B%5B3,%20False,%20None%5D,%0A%20%20%20%20%20%20%20%20%20%20%20%5B4,%20lambda%3A%205%5D%5D%5D&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=4&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

将一个列表嵌套到另一个列表中会引入复杂性. 树是基本的数据抽象, 用于加强如何对分层数据进行结构化以及操作的规律性.

一棵树有一个根值以及一系列的分支. 树的每一个分支都是一棵树. 一棵没有分支的树叫做叶子. 任何被包含在另一个树中的树都叫做棵树树的子树(就像一个分支的分支). 而一棵树的一棵子树的根值又被称作这棵树的一个节点(或者节点值).

树的数据抽象由一个构造器`tree`以及选择器`root`和`branches`组合而成. 我们由最简单的版本开始.

```python
>>> def tree(root, branches = []):
        for branch in branches:
            assert is_tree(branch), 'branches must be trees'
        return [root] + list[branches]

>>> def root(tree):
        return tree[0]

>>> def branches(tree):
        return tree[1:]
```

只有当树具有根值并且所有分支也是树时，才会形式一棵良好的树. `is_tree`函数是用在`tree`构造器中用来校验是否所有的分支都形成良好.

```python
>>> def is_tree(tree):
        if type(tree) != list or len(tree) < 1:
            return False
        for branch in branches(tree):
            if not is_tree(branch):
                return False
        return True
```

`is_leaf`函数用来检查一棵树是否有分支.

```python
>>> def is_leaf(tree):
        return not branches(tree)
```

树能够用嵌套表达式来构建, 下面的树`t`有根值3以及两个分支.

```python
>>> t = tree(3, [tree(1), tree(2, [tree(1), tree(1)])])
>>> t
[3, [1], [2, [1], [1]]]
>>> root(t)
3
>>> branches(t)
[[1], [2, [1], [1]]]
>>> root(branches(t)[1])
2
>>> is_leaf(t)
False
>>> is_leaf(branches(t)[0])
True
```

树递归函数可以用来构造一棵树. 例如, 一棵n阶斐波那契树以n阶斐波那契数作为根值, 对于`n > 1`时, 两个分支也是斐波那契树. 一个斐波那契树演示了斐波那契数的树递归计算.

```python
>>> def fib_tree(n):
        if n == 0 or n == 1:
            return tree(n)
        else:
            left, right = fib_tree(n - 2), fib_tree(n - 1)
            fib_n = root(left) + root(right)
            return tree(fib_n, [left, right])

>>> fib_tree(5)
[5, [2, [1], [1, [0], [1]]], [3, [1, [0], [1]], [2, [1], [1, [0], [1]]]]]
```

树递归函数也用于处理树. 例如, `count_leaves`函数用于统计树的树叶的量.

```python
>>> def count_leaves(tree);
        if is_leaf(tree):
            return 1
        else:
            branch_counts = [count_leaves(b) for b in branches(tree)]
            return sum(branch_counts)

>>> count_leaves(fib_tree(5))
8
```

**分区树**. 树可以用来表示整数的划分形式. 一个用最大为m的数划分数n来组成的分区树是一棵二叉树(两个分支), 代表了计算时候的两个选择. 在非叶子分区树中:

- 左边的(下标为0)分支包含了至少使用一个m来划分n的所有方式
- 右边的(下标为1)分支包含了用`m-1`部分来划分的分区树, 以及
- 根的值是m

分区树叶子的值表示了从树的根到叶的路径是否代表一个n的成功分区.

```python
>>> def partition_tree(n, m):
        if n == 0:
            return tree(True)
        elif n < 0 or m == 0:
            return tree(False)
        else:
            left == partition_tree(n - m, m)
            right == partition_tree(n, m - 1)
            return tree(m, [left, right])

>>> partition_tree(2, 2)
[2, [True], [1, [1, [True], [False]], [False]]]
```

从一个分区树打印出分区是另外一个遍历树的树递归过程, 将每一个分区构造成一个列表. 不管是否能够触及True叶子, 分区树都会打印出来.

```python
>>> def print_parts(tree, partition = []):
        if is_leaf(tree):
            if root(tree):
                print(' +'.join(partition))
        else:
            left, right = branches(tree)
            m = str(root(tree))
            print_parts(left, partition + [m])
            print_parts(right, partition)

>>> print_parts(partition_tree(6, 4))
4 + 2
4 + 1 + 1
3 + 3
3 + 2 + 1
3 + 1 + 1 + 1
2 + 2 + 2
2 + 2 + 1 + 1
2 + 1 + 1 + 1 + 1
1 + 1 + 1 + 1 + 1 + 1
```

#### 2.3.7 链接列表

目前为止, 我们只用了原生的数据类型来表示序列. 然而, 我们也可以开发一个不是Python原生的序列表示. 一个序列的常见表示法是由嵌套的成对数据来构成, 叫做列表. 下面的环境图例表示出一个由四个按顺序包含1, 2, 3和4的元素组成的链表.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=four%20%3D%20%5B1,%20%5B2,%20%5B3,%20%5B4,%20'empty'%5D%5D%5D%5D&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

一个链表是一个成对的数据, 包含了序列的第一个元素(在例子中是1)以及剩下的元素的序列(在例子中是2, 3, 4). 第二个元素也是一个链表. 剩下的最里面的链表只包含4, 其余部分是`empty`, 一个用于代表空链表的值.

链表具有递归结构: 链表的其余部分是一个链表或者`empty`值. 我们可以定义一个抽象数据表示来进行验证, 构造以及选择链表的某部分.

```python
>>> empty = 'empty'
>>> def is_link(s):
        """s is a linked list if it is empty or a (first, rest) pair."""
        return s == empty or (len(s) == 2 and is_link(s[1]))

>>> def link(first, rest):
        """Construct a linked list from its first element and the rest."""
        assert is_link(rest), 'rest must be a linked list.'
        return [first, rest]

>>> def first(s):
        """Return the first element of a linked list s."""
        assert is_link(s), 'first only applies to linked lists.'
        assert s != empty, 'empty linked list has no first element.'
        return s[0]

>>> def rest(s):
        """Return the rest of the elements of a linked list s."""
        assert is_link(s), 'rest only applies to linked lists.'
        assert s != empty. 'empty linked list has no rest.'
        return s[1]
```

上面, `link`是一个构造器, `first`以及`rest`是用于代表已经链接的列表抽象数据的选择器. 链表的行为条件是像数据对, 它的构造器以及选择器是其反函数.

- 如果一个链表s是由第一个元素是f以及一个已经是链表的r组成, 那么`first(s)`返回的是f, `rest(s)`返回的是r.

我们可以用构造器以及选择器来操纵链表.

```python
>>> four = link(1, link(2, link(3, link(4, empty))))
>>> first(four)
1
>>> rest(four)
[2, [3, [4, 'empty']]]
```

我们实现的这种类型的抽象数据是数据对, 一个具有两个元素的列表值. 值得注意的是, 我们也可以通过函数来实现对数据, 同时我们也可以用任何对数据来实现链表, 因此我们可以只用函数来实现链表.

链表可以按顺序存储一系列的数据值, 但是我们还没有展示它满足序列抽象的那一部分. 使用我们定义的抽象数据表示, 我们可以实现序列的两个特征行为: 长度以及元素选择.

```python
>>> def len_link(s):
        """Return the length of linked list s"""
        length = 0
        while s != empty
            s, length = rest(s), length + 1
        return length

>>> def getitem_link(s, i):
        """Return the element at index i of linked list s."""
        while i > 0:
            s, i = rest(s), i - 1
        return first(s)
```

现在, 我们可以用这些函数来把链表当做序列来操作. (我们现在还不能用內建的len函数, 元素选择语法, 或者for语句, 但是很快就可以了)

```python
>>> len_link(four)
4
>>> getitem_link(four, 1)
2
```

下面的一系列环境图例演示了`getitem_link`的找寻链表中下标为1的第二个元素的迭代过程. 下面, 我们已经用Python原语来简化图表来定义链表four. 这种实现选择违反了抽象边界, 但是允许我们更容易检视这个例子的计算过程

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20first(s%29%3A%0A%20%20%20%20return%20s%5B0%5D%0Adef%20rest(s%29%3A%0A%20%20%20%20return%20s%5B1%5D%0A%0Adef%20getitem_link(s,%20i%29%3A%0A%20%20%20%20while%20i%20%3E%200%3A%0A%20%20%20%20%20%20%20%20s,%20i%20%3D%20rest(s%29,%20i%20-%201%0A%20%20%20%20return%20first(s%29%0A%0Afour%20%3D%20%5B1,%20%5B2,%20%5B3,%20%5B4,%20'empty'%5D%5D%5D%5D%0Agetitem_link(four,%201%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

首先, 函数`getitem_link`被调用, 创建了一个本地帧:

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20first(s%29%3A%0A%20%20%20%20return%20s%5B0%5D%0Adef%20rest(s%29%3A%0A%20%20%20%20return%20s%5B1%5D%0A%0Adef%20getitem_link(s,%20i%29%3A%0A%20%20%20%20while%20i%20%3E%200%3A%0A%20%20%20%20%20%20%20%20s,%20i%20%3D%20rest(s%29,%20i%20-%201%0A%20%20%20%20return%20first(s%29%0A%0Afour%20%3D%20%5B1,%20%5B2,%20%5B3,%20%5B4,%20'empty'%5D%5D%5D%5D%0Agetitem_link(four,%201%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

while头部的表达式计算得到true, 然后while的内部等式会被执行, 函数`rest`返回以2开头的子列表.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20first(s%29%3A%0A%20%20%20%20return%20s%5B0%5D%0Adef%20rest(s%29%3A%0A%20%20%20%20return%20s%5B1%5D%0A%0Adef%20getitem_link(s,%20i%29%3A%0A%20%20%20%20while%20i%20%3E%200%3A%0A%20%20%20%20%20%20%20%20s,%20i%20%3D%20rest(s%29,%20i%20-%201%0A%20%20%20%20return%20first(s%29%0A%0Afour%20%3D%20%5B1,%20%5B2,%20%5B3,%20%5B4,%20'empty'%5D%5D%5D%5D%0Agetitem_link(four,%201%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

接下来, 局部名称s会更新成以原列表第二个元素为开头的子列表的引用. 运算while头部表达式现在会返回false值, 然后Python运算在返回语句之后的`getitem_link`的最后一行表达式.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20first(s%29%3A%0A%20%20%20%20return%20s%5B0%5D%0Adef%20rest(s%29%3A%0A%20%20%20%20return%20s%5B1%5D%0A%0Adef%20getitem_link(s,%20i%29%3A%0A%20%20%20%20while%20i%20%3E%200%3A%0A%20%20%20%20%20%20%20%20s,%20i%20%3D%20rest(s%29,%20i%20-%201%0A%20%20%20%20return%20first(s%29%0A%0Afour%20%3D%20%5B1,%20%5B2,%20%5B3,%20%5B4,%20'empty'%5D%5D%5D%5D%0Agetitem_link(four,%201%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

最后的环境图例显示调用first的本地帧, 也就是含有绑定到同一个子列表的名称s. first函数选择值2然后返回, 也会从`getitem_link`中返回.

这个例子演示了一个列表计运算的一般模式, 迭代操作中的每一步都会不断得到原列表中较短的后缀. 这查找列表长度以及元素的增量处理过程需要一些时间来运算. Python的內建序列类型是用不同形式实现的, 这让计算序列长度或者检索它的元素都不会导致很大的计算成本. 这种表现的细节已经超出本文的范围.

**递归操作**. `len_link`以及`getitem_link`函数都是迭代的. 它们不断剥离每一层的嵌套数据对直到到达到达列表的最后(在`len_link`函数中)或者到达期望的元素(在`getitem_link`中).我们也可以用递归来实现长度以及元素选择.

```python
>>> def len_link_recursive(s):
        """Return the length of a linked list s."""
        if s == empty:
            return 0
        return 1 + len_link_recursive(rest(s))

>>> def getitem_link_recursive(s, i):
        """Return the element at index i of linked list s."""
        if i == 0:
            return first(s)
        return getitem_link_recursive(rest(s), i - 1)

>>> len_link_recursive(four)
4
>>> getitem_link_recursive(four, 1)
2
```

这些递归实现跟随数据对组成的链直到到达列表的最后(在`len_link_recursive`中)或者到达期望的元素(在`getitem_link_recursive`中).

递归对于转换以及合并链表也是有用的.

```python
>>> def extend_link(s, t):
        """Return a list with the elements of s followed by those of t."""
        assert is_link(s) and is_link(t)
        if s == empty:
            return t
        else:
            return link(first(s), extend_link(rest(s), t))

>>> extend_link(four, four)
[1, [2, [3, [4, [1, [2, [3, [4, 'empty']]]]]]]]

>>> def apply_to_all_link(f, s):
        """Apply f to each element of s."""
        assert is_link(s)
        if s == empty:
            return s
        else:
            return link(f(first(s)), apply_to_all_link(f, rest(s)))

>>> apply_to_all_link(lambda x: x*x, four)
[1, [4, [9, [16, 'empty']]]]

>>> def keep_if_link(f, s):
        """Return a list with elements of s for which f(e) is true."""
        assert is_link(s)
        if s == empty:
            return s
        else:
            kept = keep_if_link(f, rest(s))
            if f(first(s)):
                return link(first(s), kept)
            else:
                return kept

>>> keep_if_link(lambda x: x%2 == 0, four)
[2, [4, 'empty']]

>>> def join_link(s, separator):
        """Return a string of all elements in s separated by separator."""
        if s == empty:
            return ""
        elif rest(s) == empty:
            return str(first(s))
        else:
            return str(first(s)) + separator + join_link(rest(s), separator)

>>> join_link(four, ", ")
'1, 2, 3, 4'
```

**递归构建**. 链表在我们增量地构造序列的时候尤其有用, 这种情况经常在递归计算中出现.

第一章中的`count_partitions`函数通过树递归过程来计算整数n用最大为m的数来进行分割的总数. 通过序列我们也可以通过明确地使用相似的过程来枚举这些切分.

跟我们计算时一样, 我们用跟随问题的相同递归分析: 用最大为m的整数来划分n涉及到

1. 使用最大为m的整数来划分n-m, 或者
2. 使用最大为m-1的整数来划分n

对于基本情况, 我们发现用一个负整数或者用小于1的部分来划分0是不可能的, 因此0的划分数为空.

```python
>>> def partitions(n, m):
        """Return a linked list of partitions of n using parts of up to m.
        Each partition is represented as a linked list.
        """
        if n == 0:
            return link(empty, empty) # A list containing the empty partition
        elif n < 0 or m == 0:
            return empty
        else:
            using_m = partitions(n - m, m)
            with_m = apply_to_all_link(lambda s: link(m, s), using_m)
            without_m = partitions(n, m - 1)
            return extend_link(with_m, without_m)
```

在递归情况下, 我们构建两个分区的子列表. 第一个用m, 因此我们在结果`using_m`中的每个元素前面加上m来构建`with_m`.

partitions的结果是高度嵌套的: 一个链接列表的链接列表, 并且每个链接列表被表示为作为列表值的嵌套对. 在`join_link`函数中用恰当的分隔符, 我们可以用人类可阅读的方式来展示出分区.

```python
>>> def print_partitions(n, m):
        lists = partitions(n, m)
        strings = apply_to_all_link(lambda s: join_link(s, " + "), lists)
        print(join_link(strings, '\n'))

>>> print_partitions(6, 4)
4 + 2
4 + 1 + 1
3 + 3
3 + 2 + 1
3 + 1 + 1 + 1
2 + 2 + 2
2 + 2 + 1 + 1
2 + 1 + 1 + 1 + 1
1 + 1 + 1 + 1 + 1 + 1
```

[1]: http://en.wikipedia.org/wiki/IEEE_floating_point
[2]: http://getpython3.com/diveintopython3/native-datatypes.html
[3]: http://getpython3.com/diveintopython3/native-datatypes.html#slicinglists
[4]: http://getpython3.com/diveintopython3/strings.html