title: 程序构成-第二章
tags:
- 译文
- Design Programs
---

## 第二章: 构筑抽象数据

### 2.1 介绍

在第一章我们集中关注计算过程, 以及函数对程序设计的作用与影响. 我们已经见识过如何使用原始数据(numbers)以及原始操作符(算术), 如何通过组合和控制来组成复合函数, 以及通过给计算过程赋予名称来创建函数抽抽象. 我们也看到高阶函数通过允许我们自行控制, 从而推理出一般计算方法来增强我们的语言的力量. 这就是编程的本质.

这一章主要关注数据. 我们在这里探讨的技术允许我们表达以及操作许多不同领域的信息. 由于因特网的爆炸性增长, 提供给我们大量在线且免费的结构化信息, 并且可以在大范围不同问题上进行计算. 有效使用內建的以及用户定义的数据类型是数据处理程序的根本. 

#### 2.1.1 基本数据类型

每一种数据在Python中都有一个类属, 这个类属决定了这个值是什么类型. 共享的数据同时具有共享的行为. 例如, 整数1以及2都是int类的实例. 这两个值能够进行类似的处理. 例如, 它们都可以被另外一个整数加或者减. 內建的type函数允许我们检查任何数值的类型.

```python
>>> type(2)
<class 'int'>
```

我们目前使用的数值知识少量Python语言的內建_本地_数据类型. 本地数据类型具有以下属性:

1. 有对原生类型的值进行定义的表达式, 叫做常量
2. 有对原生类型的值进行操作的內建函数以及操作符

int类是用来表示整数的原生数据类型. 整型常量(相邻数字序列)表达为int值, 以及数学运算符来操作这些值. 

```python
>>> 12 + 3000000000000000000000000
3000000000000000000000012
```

Python包含有三种本地数据类型: 整型(int), 实数(float), 以及复数(complex). 

```python
>>> type(1.5)
<class 'float'>
>>> type(1+1j)
<class 'complex'>
```

**Floats**: 名字float来源于Python以及许多其他的程序语言实数的表示方式是以: "浮点(floating point)"来表示的. 至于数字是如何表示的这些细节不在我们这一节的讨论范围之内, 而一些int以及float对象的高级差异需要重点了解. 尤其是, int对象能够准确地表示整数, 对其大小没有任何近似以及限制. 另一方面, float对象能够表示较宽范围内的分数, 但不是所有的数字都能够准确表示, 同时它们还具有最小值以及最大值. 因此, float数值应该被视为实际值的近似值来对待. 这些近似值只具有有限的精度. 合并浮点数会导致一些精度错误; 如果不用近似值的话下面的表达式计算后应该会等于7:

```python
>>> 7 / 3 * 3
7.0
>>> 1 / 3 * 7 * 3
6.999999999999999
```

虽然上面是int的组合, 用一个int除以另一个会得到一个float的值: 一个被截断了的近似值, 也就是两个整数相除的实际比率. 

```python
>>> type(1/3)
<class 'float'>
>>> 1/3
0.3333333333333333
```

当我们进行相等性测试的时候就会出现近似值的问题.

```python
>>> 1/3 == 0.333333333333333312345  # Beware of float approximation
True
```

这些int类型与float类型之间的微妙不同, 对程序的编写具有广泛的影响, 因此它们的细节程序员必须要铭记在心. 幸运的是, 只有少量的本地数据类型, 限制了精通编程语言所需要的记忆量. 此外, 这些相同的细节在许多编程语言中也是一致的. 由社区准则强制执行, 如: [IEEE 754 floating point standard][1]

**非数字类型**. 数值能够代表许多其他类型的数据, 例如声音, 图像, 地点, 网址, 网络连接等等. 少量是通过本地数据类型来表示的, 例如代表真(True)和假(False)的布尔(bool)类型. 大多数值的类型都需要程序员来使用本章中研究的组合和抽象手段来进行定义. 

接下来的部分将介绍更多Python的本地数据类型, 侧重于它们在创建有用的数据抽象中所起到的作用. 那些对于更加深入的细节感兴趣的人可以阅读一下深入Python3这本书的[本地数据类型][2]这一章,写出了所有Python的本地数据类型的实用概述以及如何对它们进行操作, 包括大量的用法例子以及练习提示.

### 2.2 数据抽象

当我们考虑世界上的广泛的事物的时候, 我们会想要将它在我们的程序中表现出来, 我们会发现它们大多数都具有复合结构. 例如, 一个地理位置有经度以及纬度坐标. 为了表示位置, 我们会想让我们的程序语言有能力将经度和纬度合在一起以形成一对, 作为一个我们的程序能够操作的一个单一的概念单元, 但是它也具有两个部分可以进行单独考虑.

使用复合数据能够让我们提升程序的模块性, 如果我们能够将地理位置作为一个整体来进行操作, 然后我们就可以对程序使用位置进行计算中是如何对这些地理位置进行表示的细节进行屏蔽. 一般的隔离程序各个部分的技术, 都是处理数据是如何被表示, 以及处理数据是如何被操作的强大的设计方法, 这方法称为数据抽象. 数据抽象让程序更容易被设计, 维护, 以及修改

数据抽象在性质上跟函数抽象那一章相似. 当我们创建一个函数抽象, 函数是如何实现的细节能够被压制, 以及特定的函数本身能够被任何其他的具有相同整体行为的函数进行替换. 换句话说, 我们可以实现一个抽象来将函数使用的方式与函数如何实现的细节上进行分离. 类似地, 数据抽象对复合数据的使用方式与如何构造的细节进行了隔离. 

数据抽象的基本思想是结构化程序, 以便于它们对抽象数据进行操作. 也就是说, 我们的程序应该以尽可能少的以对数据进行假设的方式来使用数据. 同时, 数据的具体表现应该定义为程序的一个独立的部分.

程序的这两个部分, 对数据抽象进行操作的部分以及定义具体表示的部分, 通过一组小的函数进行连接, 这些函数根据具体表示实现抽象数据. 为了说明这种技术, 我们需要考虑如何设计一套函数来操作有理数.

#### 2.2.1 例子: 有理数

一个有理数就是整数的比率, 有理数是构成实数的重要子类. 一个有理数如1/3或者17/29通常写作:

`<numerator>/<denominator>`

而`<numerator>`以及`<denominator>`都是整数的占位符. 这些部分都需要用来准确地表征有理数的值. 实际上整数相除得到一个浮点数的近似值, 失去了整数的精确度.

```python
>>> 1/3
0.3333333333333333
>>> 1/3 == 0.333333333333333300000  # Dividing integers yields an approximation
True
```

然而, 我们可以通过将分子和分母组合在一起来为有理数创建一个精确的表示. 

我们从使用函数的抽象中可以知道, 我们可以在程序的某些部分实现之前开始进行编程. 让我们假设我们已经有办法从一个分子以及一个分母中构造一个有理数开始. 我们还假设, 给定一个有理数, 我们有方法选定它的分子和分母的部分. 让我们进一步假设构造器以及选择器可具有一下的三个功能:

- **rational(n, d)**以分子为n分母为d的形式返回一个有理数
- **numer(x)**返回有理数中的分子x
- **denom(x)**返回有理数中的分母x

在这里我们使用程序设计中的强大策略: _祈愿思维_. 我们还没有讲述一个有理数是如何表示的, 或者函数number, denom, 以及rational应该怎么实现. 即使这样, 如果我们定义了这三个函数, 我们可以对有理数进行加, 乘, 打印, 以及测试相等性等操作:

```python
>>> def add_rationals(x, y):
        nx, dx = numer(x), denom(x)
        ny, dy = numer(y), denom(y)
        return rational(nx * dy + ny * dx, dx * dy)

>>> def mul_rational(x, y):
        return rational(numer(x) * numer(y), denom(x) * denom(y))

>>> def print_rational(x):
        print(numer(x), '/', denom(x))

>>> def rationals_are_equal(x, y):
        return numer(x) * denom(y) == numer(y) * denom(x)
```

现在我们具有定义在选择器函数number以及denom和构造器函数rational之上的操作函数, 但是我们还没有定义这些选择器函数以及构造器函数. 我们需要一种方法来将分子和分母进行粘合, 形成一个复合值.

#### 2.2.2 一对

为了让我们实现正确等级的数据抽象, Python提供了一种复合数据结构叫做list, 能够通过将表达式放到方括号内并用逗号分隔开来构造, 这种表达式就叫做列表字面量.

```python
>>> [10, 20]
[10, 20]
```

列表中的元素可以用两种方式来进行访问, 第一种方式是通过我们熟悉的多重分配的方法, 通过对list对象中的元素进行解包然后绑定每一个元素到不同的名字.

```python
>>> pair = [10, 20]
>>> pair
[10, 20]
>>> x, y = pair
>>> x
10
>>> y
20
```

第二个访问方法是通过list的元素选择运算符, 也通过方括号来进行表达. 不像列表字面量, 一个方括号表达式直接跟在另一个表达式后面不以生成列表值来运行, 而是在前面的表达式中选择一个元素.

```python
>>> pair[0]
10
>>> pair[1]
20
```

在Python中的列表(以及大多数其他的编程语言)是以0索引作为开始的, 这意味着索引0选定第一个元素, 索引1选定第二个, 等等. 一个支持这个索引惯例的直觉是索引代表一个元素偏离列表开始位置有多远. 

跟元素选择操作符相等的函数叫做getitem, 它也用索引0作为开始位置来对列表对象进行选取.

```python
>>> from operator import getitem
>>> getitem(pair, 0)
10
>>> getitem(pair, 1)
20
```

两个元素的列表不是表示一对的唯一方法, 任何将两个值捆绑到一块的方法都可以认为是一对. 只是列表是一种常用的方法. 列表也可以容纳超过两个对象, 正如我们本章接下来要进行讨论的. 

**表示有理数**. 现在我们能够将有理数表示为一对整数的组合: 一个分子和一个分母.

```python
>>> def rational(n, d):
        return [n, d]

>>> def numer(x):
        return x[0]

>>> def denom(x):
        return x[1]
```

结合早先我们定义的算术运算, 我们可以用我们已经定义好的函数来操作有理数.

```python
>>> half = rational(1, 2)
>>> print_rational(half)
1 / 2
>>> third = rational(1, 3)
>>> print_rational(mul_rational(half, third))
1 / 6
>>> print_rational(add_rationals(third, third))
6 / 9
```

像上面例子显示的那样, 我们的有理数的实现不会将有理数减少到最低项. 我们可以通过改变rational函数的实现来修复这个缺陷. 如果我们有一个函数来计算两个整数的最大公分母, 我们就可以在构建有理数对时用它来将分子和分母减少为最底项. 跟许多有用的工具一样, 在Python的库中已经有这样的一个函数了. 

```python
>>> from fractions import gcd
>>> def rational(n, d):
        g = gcd(n, d)
        return (n//g, d//g)
```

整除运算符, `//`, 表示整除, 也就是对相除的结果将向下舍入小数部分. 由于我们已经知道g能够完全整除n以及d, 整除在这种情况下是精确的. 这个rational函数的合理地进行了修正保证了有理数以最低项来表示.

```python
>>> print_rational(add_rationals(third, third))
2 / 3
```

这种改进是通过改进构造函数而不用改变其他函数(即实现实际运算的函数)来完成的.

#### 2.2.3 抽象屏障

在继续(介绍)更多的组合数据和数据抽象的例子之前, 让我们思考一下有理数例子提出的一些问题. 我们根据构造函数rational和选择器numer, denom定义操作. 一般来说, 数据抽象的基础思想是识别一组基础操作, 根据这些操作来表达某种类型的值的所有操作, 然后只使用这些操作来处理数据. 通过限制这些操作的使用方式, 将会更容易改变抽象数据的表示而不用修改程序的行为.

对于有理数, 程序的不同部分使用不同的操作来操纵有理数, 如下表所述:

|**Parts of the program that...**|**Treat rational as...**|**Using only...**|
|:-------------------------------|:-----------------------|:----------------|
|Use rational numbers to perform computation|whole data values|`add_rational`, `mul_rational`, `rationals_are_equal`, `print_rational`|
|Create rationals or implement rational operations|numerators and denominators|`rational`, `numer`, `denom`|
|Implement selectors and constructor for rationals|two-element lists|list literals and element selection|

|**程序的每个部分...**|**将有理数当做...**|**只用作**|
|:------------------|:----------------|:--------|
|用有理数来执行计算|整个数值|`add_rational`, `mul_rational`, `rationals_are_equal`, `print_rational`|
|创建有理数或操作有理数|分子以及分母|`rational`, `numer`, `denom`|
|实现有理数的构造器以及选择器|两个元素的列表|列表字面量以及元素选择|

在上面的每一层, 最后一列的函数实现了一个抽象屏障. 这些函数通过更低层次的抽象来实现来被更高层的函数调用.

违反一个抽象屏障的情况发生在每当可以在较高级别函数中使用程序的一部分时, 却使用较低级别的函数来实现. 举个例子, 一个计算有理数平方的函数最好是根据`mul_rational`来实现, 而无需对有理数的实现进行任何假设.

```python
>>> def square_rational(x):
        return mul_rational(x, x)
```

直接涉及到分子以及分母会违反一层抽象屏障.

```python
>>> def square_rational_violating_once(x):
        return rational(numer(x) * numer(x), denom(x) * denom(x))
```

假设有理数用两个元素的列表表示会违反两层抽象屏障.

```python
>>> def square_rational_violating_twice(x):
        return [x[0] * x[0], x[1] * x[1]]
```

抽象屏障让程序更容易管理与修改. 越少函数依赖于特定的表示, 当想改变其中一个的表示的时候就需要越少的改动. 所有的这些`square_rational`的实现都具有正确的行为, 但是只有第一个对于未知的变化是健壮的. `square_rational`函数即使在我们修改有理数的表示的时候也不需要更新. 相比之下, `square_rational_violating_once`每当选择器或者构造器的特征改变的时候都需要进行修改, 而`square_rational_violating_twice`则在有理数的实现有任何改变时都需要进行更新.

#### 2.2.4 数据的属性

抽象屏障能够塑造我们思考数据的方式. 对有理数进行有效的表示是不限于任何特定的实现的(如具有两个元素的列表); 它是rational函数返回的一个值, 这个值能够输入到numer以及denom当中. 除此之外, 必需维持构造器跟选择器之间恰当的关系. 也就是说, 如果我们从整数n跟d中构造一个有理数x, 应该得到一种情况是numer(x)/denom(x)等于n/d.

一般来说, 我们可以用选择器函数以及构造器函数集合与一些行为条件一起来表示抽象数据. 只要这些行为条件满足(例如上面的除法属性), 选择器以及构造器函数构成了一种数据的有效表示. 在抽象屏障之下的细节可能会有更改, 但是如果行为没有改变, 那数据抽象依然是有效的, 然后任何使用这些数据抽象编写的程序依然是正确的.

这一观点能够进行广泛地应用, 包括我们用于实现有理数的数据对. 我们从没有说过什么是数据对, 只有语言提供的创建以及操作两个元素的列表方法. 我们需要实现的数据对的行为是它能将两个值黏合在一起. 而行为条件,

- 如果一个数据对p由值x跟y构造, 那么select(p, 0)返回x, select(p, 1)返回y.

我们实际上不需要用列表类型来创建数据对, 作为替代, 我们可以实现两个函数pair以及select来满足这个描述, 就像两个元素的列表一样.

```python
>>> def pair(x, y):
        """Return a function that represents a pair."""
        def get(index):
            if index == 0:
                return x
            elif index == 1:
                return y
        return get

>>> def select(p, i):
        """Return the element at index i of pair p."""
        return p(i)
```

有了这个实现, 我们可以创建并操作数据对.

```python
>>> p = pair(20, 14)
>>> select(p, 0)
20
>>> select(p, 1)
14
```

这种高阶函数的使用方式能够跟我们对于数据是什么这种直观的概念进行对应. 然而, 这些函数足够表示我们程序中用到的数据对. 函数足以表示复合数据.

用函数展示数据对的意思不代表Python就是以这种方式来运行的(处于效率的原因, 列表的实现更加的直观)但是它能以这种方式运行. 函数型的表示虽然模糊, 但它完全具有表示数据对的能力, 因为它满足数据对唯一需要满足的条件. 数据抽象的实践允许我们轻易地在各种表示中进行切换.

### 2.3 序列

序列就是一个值的有序集合. 序列在计算机科学中是强大的, 基本的抽象. 序列不是某个特定的內建类型的实例或者抽象数据表示, 而是在一些不同类型的数据之间共享行为的集合. 也就是说, 有许多种类型的序列. 但是它们都共享共同的行为. 尤其是,

**长度**. 一个序列具有有限的长度. 一个空序列的长度是0.

**元素选择**. 一个序列的对于任何小于它长度的非负整数的索引值都对应它的一个元素, 第一个元素从0开始.

Python包含的一些本地数据类型就是序列, 最重要的莫过于**列表**了.

#### 2.3.1 列表

一个列表就是一个具有任意长度的序列. 列表具有一大套內建行为, 以及表示这些行为的特殊语法. 我们已经见识过列表字面量了, 也就是用来运算生成列表实例那个, 以及元素选择表达式, 即用来获取列表中的值的语法. 內建的len函数用于返回一个序列的长度. 下面, digits是一个具有四个元素的列表. 索引为3的元素值是8.

```python
>>> digits = [1, 8, 2, 8]
>>> len(digits)
4
>>> digits[3]
8
```

另外, 列表可以加在一起, 以及与一个整数相乘. 对于序列来说, 加法以及乘法不会添加或者乘里面的元素, 而是复制序列本身并将它们合并在一起. 也就是说, 在operator模块下的add函数(以及符号+)返回的是添加的参数级联后生成的一个列表. 而在operator中的mul函数(以及`*`号)能够传入一个列表以及一个整数然后返回另一个列表, 这个列表是由k次重复的源列表组成的.

```python
>>> [2, 7] + digits * 2
[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]
```

任意的值都可以包含在列表中, 包括其他的列表. 为了选择到包括在列表里面的列表这样深层次嵌套的元素可以多次应用列表元素选择语法.

```python
>>> pairs = [[10, 20], [30, 40]]
>>> pairs[1]
[30, 40]
>>> pairs[1][0]
30
```

#### 2.3.2 序列迭代

在很多情况下, 我们会想要对序列的元素进行迭代然后反过来对每个元素执行一些计算. 这种模式是如此的常见以至于Python有一个额外的控制语句来处理顺序的数据: for语句.

想一下计算一个值在序列中出现的次数这样的一个问题, 我们可以实现一个函数用while循环来进行计数.

```python
>>> def count(s, value):
        total, index = 0, 0
        while index < len(s):
            if s[index] == value:
                total += 1
            index += 1
        return total

>>> count(digits, 8)
2
```

Python的for语句能够简化这个函数体通过直接对元素值进行迭代而根本不需要引入名称index.

```python
>>> def count(s, value):
        total = 0
        for elem in s:
            if elem == value:
                total += 1
        return total

>>> count(digits, 8)
2
```

for语句由单个子句组成, 形式如下:

```
for <name> in <expression>:
    <suite>
```

一个for语句会按照以下的步骤执行:

1. 计算头部表达式`<expression>`, 必须返回一个可迭代的值.
2. 遍历该可迭代值中的每一个元素, 是为了:
    1. 将这个元素值当前域的中的`<name>`进行绑定
    2. 执行`<suite>`

这个执行过程引用的是可迭代的值, 列表是序列的一种, 而序列是一种可迭代的值. 它们的元素按照它们原有的顺序被考虑. Python包括其他的可迭代的值, 但是目前我们会专注于序列; 术语"可迭代"的一般定义出现在第四章的迭代器部分.

这个计算过程的一个重要的意义是`<name>`会在for语句运行后绑定到序列中的最后一个元素. for循环引入了另外一种可以让运行环境随语句执行而更新的方式.

**序列解包**. 在程序中的常见模式是有一个以序列为元素的序列, 但元素都是固定长度的. 一个for语句可能会包含有多个名称在它的头部用来对序列中的每一个序列元素"解包"到各自对应的名称上. 例如, 可能会有一个以包含两个元素的序列为元素的序列:

```python
>>> pairs = [[1, 2], [2, 2], [2, 3], [4, 4]]
```

然后希望从中找到这些序列对中两个数字是相等的序列对

```python
>>> same_count = 0
```

下面的for语句在它的头部有两个变量名x和y, 这两个变量名会分别跟序列对的第一和第二个元素进行绑定:

```python
>>> for x, y in pairs:
        if x == y:
            same_count += 1

>>> same_count
2
```

这种将多个名称以固定长度的顺序绑定到多个值的模式称为序列解包; 这跟我们在赋值语句中看到的绑定多个名称到多个值的模式是一样的.

**范围**. 一个range类型是Python中另一个內建的序列类型, 它代表了一个整数的区间. 区间由range来创造, 需要两个整数作为参数: 第一个数字和一个超出所需范围内的最后一个数字.

```python
>>> range(1, 10) # 包含1, 但不包含10
range(1, 10)
```

调用list构造器计算出在一个在范围内的与范围相符的列表, 因此可以很容易地检查里面的元素.

```python
>>> list(range(5, 8))
[5, 6, 7]
```

如果只给定一个参数, 这被解析为构建一个从零开始到超出所需范围内的最后一个数字的区间.

```python
>>> list(range(4))
[0, 1, 2, 3]
```

区间通常出现在for表达式的头部来指定`<suite>`部位应该执行的次数: 有一个共同的约定是如果在for的头部写入的名称在`<suite>`中没有用到的话就用单个下划线作为名称:

```python
>>> for _ in range(3):
        print('Go Bears!')

Go Bears!
Go Bears!
Go Bears!
```

下划线对于解释器环境而言只是另外的一个名称, 但是它在程序员之间却是具有常规的意义, 那就是表明这个名称不会现在在之后的任何表达式中.

#### 2.3.3 序列处理

序列是一种如此常见的用于组成复合数据的形式以至于整个程序通常都围绕这个单一抽象来进行组织. 模块化组件同时以序列作为输入和输出能够对数据处理过程进行混合以及匹配. 复杂组件能够通过将序列处理操作连接在一起形成管道来进行定义, 而每个处理都是简单和集中的.

**列表推导**. 很多的序列处理操作能够通过为序列中的每个元素计算一个固定的表达式然后收集结果的值到一个结果序列中来表示. 在Python中, 一个列表推导式是一个执行这样的计算的表达式:

```python
>>> odds = [1,3,5,7,9]
>>> [x + 1 for x in odds]
[2,4,6,8,10]
```

上面的for关键词不是for语句的一部分, 而是列表表达式的一部分因为它包含在方括号里面. 而子表达式 x+1 是将x顺序绑定到每一个odds中的元素来进行运算, 然后收集每次运算的结果到列表中.

另一个常见的列表推导操作是去选择一个满足某些结果的子集. 列表推导能够表达这种模式, 例如选择所有odds中的能够整除25的元素:

```python
>>> [x for x in odds if 25 % x == 0]
[1, 5]
```

列表推导的一般形式是:

`[<map expression> for <name> in <sequence expression> if <filter expression>]`

为了运算一个列表推导, Python会计算`<sequence expression>`, 这个表达式必须要返回一个可迭代值. 然后, 对每个元素按照顺序, 将元素的值与`<name>`进行绑定, 接着运算过滤表达式, 然后如果过滤结果返回真值, `map expression`(映射表达式)将会执行, 最后结果会被收集到一个列表中.

**聚合**. 第三个序列处理的一般模式是将一个序列中所有的值聚合到单一的一个值中. 內建函数sum, min, 以及max所有都是聚合函数的例子.

通过结合这些对每个元素进行运算, 选择元素的子集, 以及聚集元素的模式, 我们可以使用序列处理方法来解决问题.

一个完备正整数指的就是一个等于它的除数的总和. n的除数是小于n且能均分n的正整数. 可以通过列表推导来运算从而列出这些n的除数

```python
>>> def divisors(n):
        return [1] + [x for x in range(2, n) if n % x == 0]

>>> divisors(4)
[1, 2]
>>> divisors(12)
[1, 2, 3, 4, 6]
```

使用divisors函数, 我们可以用其他的列表推导来计算出从1到1000的所有的完备数. (1通常也被认为是完备数, 但是它不符合我们对divisors的定义)

```python
>>> [n for n in range(1, 1000) if sum(divisors(n)) == n]
[6, 28, 496]
```

我们可以复用我们定义的divisors来解决另外的问题, 找出一个具有固定面积以及整数长度边长的长方形的最小周长. 长方形的面积等于它的高乘以宽. 而且, 给定面积以及高, 我们可以计算出宽. 我们可以肯定地说, 长和宽都能均分面积的话, 就可以保证边长都是整数.

```python
>>> def width(area, height):
        assert area % height == 0
        return area // height
```

长方形的周长等于它边长的总和

```python
>>> def perimeter(width, height):
        return 2 * width + 2 * height
```

具有整数边长的长方形的高必须是它面积的除数. 我们可以通过考虑它所有的高来计算最小周长.

```python
>>> def minimum_perimeter(area):
        heights = divisors(area)
        perimeters = [perimeter(width(area, h), h) for h in heights]
        return min(perimeters)

>>> area = 80
>>> width(area, 5)
16
>>> perimeter(16, 5)
42
>>> perimeter(10, 8)
36
>>> minimum_perimeter(area)
36
>>> [minimum_perimeter(n) for n in range(1, 10)]
[4, 6, 8, 8, 12, 10, 16, 12, 12]
```

**高阶函数**

我们在序列处理中观察到的一般模式可以用高阶函数来进行表示. 首先, 为序列中的每个元素运行一个表达式可以通过对每一个元素应用函数来来表示.

```python
>>> def apply_to_all(map_fn, s):
        return [map_fn(x) for x in s]
```

通过对每一个元素应用的函数表达式然后仅选择能使表达式结果为真的元素.

```python
>>> def keep_if(filter_fn, s):
        return [x for x in s if filter_fn(x)]
```

最后, 许多形式的聚合可以表示为反复应用一个带有两个参数的函数, 分别是进行**reduced**后的值, 以及顺序应用的每一个元素.

```python
>>> def reduce(reduce_fn, s, initial):
        reduced = initial
        for x in s:
            reduced = reduce_fn(reduced, x)
        return reduced
```

例如, reduce可以用来将序列中的所有元素乘到一起. 使用mul替代`reduce_fn`, 1替代`initial`, reduce可以用来将序列中的数都乘到一起.

```python
>>> reduce(mul, [2, 4, 6, 8], 1)
64
```

我们也可以用这些高阶函数来找寻完备数

```python
>>> def divisors_of(n):
        divides_n = lambda x: n % x == 0
        return [1] + keep_if(divides_n, range(2, n))

>>> divisors_of(12)
[1, 2, 3, 4, 6]
>>> from operator import add
>>> def sum_of_divisors(n):
        return reduce(add, divisors_of(n), 0)

>>> def perfect(n):
        return sum_of_divisors(n) == n

>>> keep_if(perfect, range(1, 1000))
[1, 6, 28, 496]
```

**常规名称**

在计算机科学的社群中, `apply_to_all`一般叫做`map`, `keep_if`一般叫做`filter`. 在Python中, 內建的map以及filter是这些方法的泛化, 且并不返回列表对象. 这些方法会在第四章来进行讨论. 上面的定义相当于用列表构造器到处理內建的map以及filter调用后所返回结果.

```python
apply_to_all = lambda map_fn, s: list(map(map_fn, s))
keep_if = lambda filter_fn, s: list(filter(filter_fn, s))
```

reduce函数构建在Python的标准库的`functools`模块中. 在这个版本中, initial参数是可选的.

```python
>>> from functools import reduce
>>> from operator import mul
>>> def product(s):
        return reduce(mul, s)

>>> product([1, 2, 3, 4, 5])
120
```

在Python程序中, 直接使用列表推导是比使用高阶函数更一般的模式, 但两者在列表处理中都是广泛使用的方法.

#### 2.3.4 序列抽象

我们已经介绍了两种满足序列抽象的本地数据类型: 列表和区间(lists and ranges). 两者都满足这部分开始所设的条件: 长度以及元素选择. Python包含了额外的两个序列类型的行为用来进行序列抽象的拓展.

**成员**. 一个值能够就是否是一个序列的成员来进行测试. Python有两个操作符`in`以及`not in`其计算的结果是True或者False取决于元素是否出现在序列中.

```python
>>> digits
[1, 8, 2, 8]
>>> 2 in digits
True
>>> 1828 not in digits
True
```

**切片**. 序列都包含更小的序列. 一个序列的切片是原有序列的任何一个连续片段, 由一对整数来指定. 就像range构造函数一样, 第一个整数指定了切片的起始下标, 然后第二个整数指定了超过结束下标的数.

在Python中, 序列切片的表达式跟元素选择类似, 用方括号包裹. 一个冒号分割起始以及结束索引. 任何省略的边界都被认定为一个极值: 0是开始下标的极值, 而序列的长度则是结束下标的极值.

```python
>>> digits[0:2]
[1, 8]
>>> digits[1:]
[8, 2, 8]
```

切片也可以用于树的分支上. 例如, 我们可能想要对一些树的分支数进行限制. 一个共同的树转型通过将原始树进行分组组合并调整分支得出的一个二叉树叫做二值化计算.

```python
>>> def right_binarize(tree):
        """Construct a right-branching binary tree."""
        if is_leaf(tree):
            return tree
        if len(tree) > 2:
            tree = [tree[0], tree[1:]]
        return [right_binarize(b) for b in tree]

>>> right_binarize([1, 2, 3, 4, 5, 6, 7])
[1, [2, [3, [4, [5, [6, 7]]]]]]
```

对Python序列抽象中的这些额外行为进行枚举给我们一个机会来反映一个一般有用的数据抽象的组成. 抽象的丰富性(也就是说它包含的行为有多少)是有意义的. 对用户来说, 一个抽象的, 额外的行为可能很有帮助. 另一方面, 用一个新类型来满足对丰富抽象性的要求可能很具挑战性. 另一个丰富抽象性的负面后果是它们可能需要用户用更长的时间来学习.

序列具有丰富的抽象性因为因为它们在计算机中是如此的无所不在, 以至于需要学习一些复杂的行为是合理的, 一般来说, 大多数用户定义的抽象应该尽可能保持简单.

**深入阅读**. 切片符号收录了各种各样的特殊例子, 例如负的起始值, 结束值以及步进大小. 一个完整的描述出现在Dive Into Python 3的子节中叫做[切片列表][3]. 在这节章中, 我们只会使用到上面提及的基础特性.

#### 2.3.5 字符串

文本值在计算机科学中可能是比数字要更一般的存在. 作为例子, Python程序的都是以文本进行编写以及存储. Python中作为文本的本地数据类型被叫做字符串, 而对应的构造器就是`str`.

在Python中关于字符串的表现, 表达以及操作有很多的细节. 字符串是另一个丰富抽象的例子, 一个需要程序员承诺牢固地掌握的部分. 此部分会用作对基本字符串行为的简明介绍.

字符串字面表达式通过用单引号或者双引号作为记号来包围可以表达任意的文本.

```python
>>> 'I am string!'
'I am string!'
>>> "I've got an apostrophe"
"I've got an apostrophe"
>>> '您好'
'您好'
```

我们已经在代码中见识过字符串了, 如`docstring`, `print`函数的调用中, 以及在`assert`语句中的错误消息.

字符串满足我们在本节最开始介绍的序列的两个基本条件: 它们具有长度以及支持元素选择.

```python
>>> city = 'Berkeley'
>>> len(city)
8
>>> city[3]
'k'
```

属于字符串本身也是字符串, 只不过它们只有一个字符. 字符是字母表的任意单个字符, 标点符号, 或者其他符号. 不像许多其他的编程语言, Python没有分开字符类型; 任何文本都是字符串, 单一一个字符代表一个长度为一的字符串.

就像列表, 字符串也可以用加法或者乘法来进行结合.

```python
>>> 'Berkeley' + ', CA'
'Berkeley, CA'
>>> 'Shabu ' * 2
'Shabu Shabu '
```

**成员**. 字符串的行为发散自Python中的其他序列类型. 字符串抽象不符合我们描述的列表以及区间那样的全序列抽象, 尤其是, 当成员运算符`in`应用到字符串时, 却会有跟应用到序列上完全不同的行为表现. 它匹配的是子字符串而不是元素.

```python
>>> 'here' in "Where's Waldo?"
True
```

**多行文本**. 字符串并不限制只有一行. 三重引号划定了字符串文本可以跨越多行的范围. 我们已经对docstring广泛使用这个三重引号了.

```python
>>> """The Zen of Python
claims, Readability counts.
Read more: import this."""
'The Zen of Python\nclaims, "Readability counts."\nRead more: import this.'
```

在上面打印出来的结果中, 那个`\n`(发音是"backlash en")是一个单元素, 用来代表一个新行. 即使它是用两个字符来表示的(backslash 以及 n), 它在长度以及元素选择上依然被认为是单个字符.

**字符串强制转换**. 一个字符串能够从Python的任何对象中通过调用`str`构造器函数以一个对象作为它的参数来构建. 这个字符串的特性对于从各种类型的对象中构造描述性的字符串是十分有用的.

```python
>>> str(2) + ' is an element of ' + str(digits)
'2 is an element of [1, 8, 2, 8]'
```

**深入阅读**. 编码文本在计算机中是一个复杂的主题. 在这一章中, 我们会抽象出字符串是如何表示的细节. 然而, 对许多应用来说, 字符串是如何被计算机编码的特定细节是是必要的知识. 在[The strings chapter of Dive Into Python3][4]中提供了字符编码以及Unicode的描述

#### 2.3.6 树

我们有将一个列表作为另一个列表内的元素来使用的能力, 在我们的编程语言中提供了一种新的组合手段. 这种能力叫做数据类型的闭包属性. 一般来说, 如果组合数据的方法组合出来的结果本身可以用于这个组合方法就说这个组合方法具有闭包属性. 闭包是任何组合手段的关键源泉, 因为它允许我们去创建分层的结构--由部件组成的结构, 而这个部件本身又是由其他部件构成的等等.

我们可以在环境图中通过块以及指针符号对列表进行可视化, 一个列表描述为一系列包含列表中元素的相邻块. 原始值如数字, 字符串, 布尔值, 以及None值会出现在元素块中, 合成的数据, 如函数值, 以及其他列表, 会用一个箭头来表示.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=one_two%20%3D%20%5B1,%202%5D%0Anested%20%3D%20%5B%5B1,%202%5D,%20%5B%5D,%0A%20%20%20%20%20%20%20%20%20%20%5B%5B3,%20False,%20None%5D,%0A%20%20%20%20%20%20%20%20%20%20%20%5B4,%20lambda%3A%205%5D%5D%5D&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=4&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

将一个列表嵌套到另一个列表中会引入复杂性. 树是基本的数据抽象, 用于加强如何对分层数据进行结构化以及操作的规律性.

一棵树有一个根值以及一系列的分支. 树的每一个分支都是一棵树. 一棵没有分支的树叫做叶子. 任何被包含在另一个树中的树都叫做棵树树的子树(就像一个分支的分支). 而一棵树的一棵子树的根值又被称作这棵树的一个节点(或者节点值).

树的数据抽象由一个构造器`tree`以及选择器`root`和`branches`组合而成. 我们由最简单的版本开始.

```python
>>> def tree(root, branches = []):
        for branch in branches:
            assert is_tree(branch), 'branches must be trees'
        return [root] + list[branches]

>>> def root(tree):
        return tree[0]

>>> def branches(tree):
        return tree[1:]
```

只有当树具有根值并且所有分支也是树时，才会形式一棵良好的树. `is_tree`函数是用在`tree`构造器中用来校验是否所有的分支都形成良好.

```python
>>> def is_tree(tree):
        if type(tree) != list or len(tree) < 1:
            return False
        for branch in branches(tree):
            if not is_tree(branch):
                return False
        return True
```

`is_leaf`函数用来检查一棵树是否有分支.

```python
>>> def is_leaf(tree):
        return not branches(tree)
```

树能够用嵌套表达式来构建, 下面的树`t`有根值3以及两个分支.

```python
>>> t = tree(3, [tree(1), tree(2, [tree(1), tree(1)])])
>>> t
[3, [1], [2, [1], [1]]]
>>> root(t)
3
>>> branches(t)
[[1], [2, [1], [1]]]
>>> root(branches(t)[1])
2
>>> is_leaf(t)
False
>>> is_leaf(branches(t)[0])
True
```

树递归函数可以用来构造一棵树. 例如, 一棵n阶斐波那契树以n阶斐波那契数作为根值, 对于`n > 1`时, 两个分支也是斐波那契树. 一个斐波那契树演示了斐波那契数的树递归计算.

```python
>>> def fib_tree(n):
        if n == 0 or n == 1:
            return tree(n)
        else:
            left, right = fib_tree(n - 2), fib_tree(n - 1)
            fib_n = root(left) + root(right)
            return tree(fib_n, [left, right])

>>> fib_tree(5)
[5, [2, [1], [1, [0], [1]]], [3, [1, [0], [1]], [2, [1], [1, [0], [1]]]]]
```

树递归函数也用于处理树. 例如, `count_leaves`函数用于统计树的树叶的量.

```python
>>> def count_leaves(tree);
        if is_leaf(tree):
            return 1
        else:
            branch_counts = [count_leaves(b) for b in branches(tree)]
            return sum(branch_counts)

>>> count_leaves(fib_tree(5))
8
```

**分区树**. 树可以用来表示整数的划分形式. 一个用最大为m的数划分数n来组成的分区树是一棵二叉树(两个分支), 代表了计算时候的两个选择. 在非叶子分区树中:

- 左边的(下标为0)分支包含了至少使用一个m来划分n的所有方式
- 右边的(下标为1)分支包含了用`m-1`部分来划分的分区树, 以及
- 根的值是m

分区树叶子的值表示了从树的根到叶的路径是否代表一个n的成功分区.

```python
>>> def partition_tree(n, m):
        if n == 0:
            return tree(True)
        elif n < 0 or m == 0:
            return tree(False)
        else:
            left == partition_tree(n - m, m)
            right == partition_tree(n, m - 1)
            return tree(m, [left, right])

>>> partition_tree(2, 2)
[2, [True], [1, [1, [True], [False]], [False]]]
```

从一个分区树打印出分区是另外一个遍历树的树递归过程, 将每一个分区构造成一个列表. 不管是否能够触及True叶子, 分区树都会打印出来.

```python
>>> def print_parts(tree, partition = []):
        if is_leaf(tree):
            if root(tree):
                print(' +'.join(partition))
        else:
            left, right = branches(tree)
            m = str(root(tree))
            print_parts(left, partition + [m])
            print_parts(right, partition)

>>> print_parts(partition_tree(6, 4))
4 + 2
4 + 1 + 1
3 + 3
3 + 2 + 1
3 + 1 + 1 + 1
2 + 2 + 2
2 + 2 + 1 + 1
2 + 1 + 1 + 1 + 1
1 + 1 + 1 + 1 + 1 + 1
```

#### 2.3.7 链接列表

目前为止, 我们只用了原生的数据类型来表示序列. 然而, 我们也可以开发一个不是Python原生的序列表示. 一个序列的常见表示法是由嵌套的成对数据来构成, 叫做列表. 下面的环境图例表示出一个由四个按顺序包含1, 2, 3和4的元素组成的链表.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=four%20%3D%20%5B1,%20%5B2,%20%5B3,%20%5B4,%20'empty'%5D%5D%5D%5D&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

一个链表是一个成对的数据, 包含了序列的第一个元素(在例子中是1)以及剩下的元素的序列(在例子中是2, 3, 4). 第二个元素也是一个链表. 剩下的最里面的链表只包含4, 其余部分是`empty`, 一个用于代表空链表的值.

链表具有递归结构: 链表的其余部分是一个链表或者`empty`值. 我们可以定义一个抽象数据表示来进行验证, 构造以及选择链表的某部分.

```python
>>> empty = 'empty'
>>> def is_link(s):
        """s is a linked list if it is empty or a (first, rest) pair."""
        return s == empty or (len(s) == 2 and is_link(s[1]))

>>> def link(first, rest):
        """Construct a linked list from its first element and the rest."""
        assert is_link(rest), 'rest must be a linked list.'
        return [first, rest]

>>> def first(s):
        """Return the first element of a linked list s."""
        assert is_link(s), 'first only applies to linked lists.'
        assert s != empty, 'empty linked list has no first element.'
        return s[0]

>>> def rest(s):
        """Return the rest of the elements of a linked list s."""
        assert is_link(s), 'rest only applies to linked lists.'
        assert s != empty. 'empty linked list has no rest.'
        return s[1]
```

上面, `link`是一个构造器, `first`以及`rest`是用于代表已经链接的列表抽象数据的选择器. 链表的行为条件是像数据对, 它的构造器以及选择器是其反函数.

- 如果一个链表s是由第一个元素是f以及一个已经是链表的r组成, 那么`first(s)`返回的是f, `rest(s)`返回的是r.

我们可以用构造器以及选择器来操纵链表.

```python
>>> four = link(1, link(2, link(3, link(4, empty))))
>>> first(four)
1
>>> rest(four)
[2, [3, [4, 'empty']]]
```

我们实现的这种类型的抽象数据是数据对, 一个具有两个元素的列表值. 值得注意的是, 我们也可以通过函数来实现对数据, 同时我们也可以用任何对数据来实现链表, 因此我们可以只用函数来实现链表.

链表可以按顺序存储一系列的数据值, 但是我们还没有展示它满足序列抽象的那一部分. 使用我们定义的抽象数据表示, 我们可以实现序列的两个特征行为: 长度以及元素选择.

```python
>>> def len_link(s):
        """Return the length of linked list s"""
        length = 0
        while s != empty
            s, length = rest(s), length + 1
        return length

>>> def getitem_link(s, i):
        """Return the element at index i of linked list s."""
        while i > 0:
            s, i = rest(s), i - 1
        return first(s)
```

现在, 我们可以用这些函数来把链表当做序列来操作. (我们现在还不能用內建的len函数, 元素选择语法, 或者for语句, 但是很快就可以了)

```python
>>> len_link(four)
4
>>> getitem_link(four, 1)
2
```

下面的一系列环境图例演示了`getitem_link`的找寻链表中下标为1的第二个元素的迭代过程. 下面, 我们已经用Python原语来简化图表来定义链表four. 这种实现选择违反了抽象边界, 但是允许我们更容易检视这个例子的计算过程

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20first(s%29%3A%0A%20%20%20%20return%20s%5B0%5D%0Adef%20rest(s%29%3A%0A%20%20%20%20return%20s%5B1%5D%0A%0Adef%20getitem_link(s,%20i%29%3A%0A%20%20%20%20while%20i%20%3E%200%3A%0A%20%20%20%20%20%20%20%20s,%20i%20%3D%20rest(s%29,%20i%20-%201%0A%20%20%20%20return%20first(s%29%0A%0Afour%20%3D%20%5B1,%20%5B2,%20%5B3,%20%5B4,%20'empty'%5D%5D%5D%5D%0Agetitem_link(four,%201%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

首先, 函数`getitem_link`被调用, 创建了一个本地帧:

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20first(s%29%3A%0A%20%20%20%20return%20s%5B0%5D%0Adef%20rest(s%29%3A%0A%20%20%20%20return%20s%5B1%5D%0A%0Adef%20getitem_link(s,%20i%29%3A%0A%20%20%20%20while%20i%20%3E%200%3A%0A%20%20%20%20%20%20%20%20s,%20i%20%3D%20rest(s%29,%20i%20-%201%0A%20%20%20%20return%20first(s%29%0A%0Afour%20%3D%20%5B1,%20%5B2,%20%5B3,%20%5B4,%20'empty'%5D%5D%5D%5D%0Agetitem_link(four,%201%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

while头部的表达式计算得到true, 然后while的内部等式会被执行, 函数`rest`返回以2开头的子列表.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20first(s%29%3A%0A%20%20%20%20return%20s%5B0%5D%0Adef%20rest(s%29%3A%0A%20%20%20%20return%20s%5B1%5D%0A%0Adef%20getitem_link(s,%20i%29%3A%0A%20%20%20%20while%20i%20%3E%200%3A%0A%20%20%20%20%20%20%20%20s,%20i%20%3D%20rest(s%29,%20i%20-%201%0A%20%20%20%20return%20first(s%29%0A%0Afour%20%3D%20%5B1,%20%5B2,%20%5B3,%20%5B4,%20'empty'%5D%5D%5D%5D%0Agetitem_link(four,%201%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

接下来, 局部名称s会更新成以原列表第二个元素为开头的子列表的引用. 运算while头部表达式现在会返回false值, 然后Python运算在返回语句之后的`getitem_link`的最后一行表达式.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20first(s%29%3A%0A%20%20%20%20return%20s%5B0%5D%0Adef%20rest(s%29%3A%0A%20%20%20%20return%20s%5B1%5D%0A%0Adef%20getitem_link(s,%20i%29%3A%0A%20%20%20%20while%20i%20%3E%200%3A%0A%20%20%20%20%20%20%20%20s,%20i%20%3D%20rest(s%29,%20i%20-%201%0A%20%20%20%20return%20first(s%29%0A%0Afour%20%3D%20%5B1,%20%5B2,%20%5B3,%20%5B4,%20'empty'%5D%5D%5D%5D%0Agetitem_link(four,%201%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

最后的环境图例显示调用first的本地帧, 也就是含有绑定到同一个子列表的名称s. first函数选择值2然后返回, 也会从`getitem_link`中返回.

这个例子演示了一个列表计运算的一般模式, 迭代操作中的每一步都会不断得到原列表中较短的后缀. 这查找列表长度以及元素的增量处理过程需要一些时间来运算. Python的內建序列类型是用不同形式实现的, 这让计算序列长度或者检索它的元素都不会导致很大的计算成本. 这种表现的细节已经超出本文的范围.

**递归操作**. `len_link`以及`getitem_link`函数都是迭代的. 它们不断剥离每一层的嵌套数据对直到到达到达列表的最后(在`len_link`函数中)或者到达期望的元素(在`getitem_link`中).我们也可以用递归来实现长度以及元素选择.

```python
>>> def len_link_recursive(s):
        """Return the length of a linked list s."""
        if s == empty:
            return 0
        return 1 + len_link_recursive(rest(s))

>>> def getitem_link_recursive(s, i):
        """Return the element at index i of linked list s."""
        if i == 0:
            return first(s)
        return getitem_link_recursive(rest(s), i - 1)

>>> len_link_recursive(four)
4
>>> getitem_link_recursive(four, 1)
2
```

这些递归实现跟随数据对组成的链直到到达列表的最后(在`len_link_recursive`中)或者到达期望的元素(在`getitem_link_recursive`中).

递归对于转换以及合并链表也是有用的.

```python
>>> def extend_link(s, t):
        """Return a list with the elements of s followed by those of t."""
        assert is_link(s) and is_link(t)
        if s == empty:
            return t
        else:
            return link(first(s), extend_link(rest(s), t))

>>> extend_link(four, four)
[1, [2, [3, [4, [1, [2, [3, [4, 'empty']]]]]]]]

>>> def apply_to_all_link(f, s):
        """Apply f to each element of s."""
        assert is_link(s)
        if s == empty:
            return s
        else:
            return link(f(first(s)), apply_to_all_link(f, rest(s)))

>>> apply_to_all_link(lambda x: x*x, four)
[1, [4, [9, [16, 'empty']]]]

>>> def keep_if_link(f, s):
        """Return a list with elements of s for which f(e) is true."""
        assert is_link(s)
        if s == empty:
            return s
        else:
            kept = keep_if_link(f, rest(s))
            if f(first(s)):
                return link(first(s), kept)
            else:
                return kept

>>> keep_if_link(lambda x: x%2 == 0, four)
[2, [4, 'empty']]

>>> def join_link(s, separator):
        """Return a string of all elements in s separated by separator."""
        if s == empty:
            return ""
        elif rest(s) == empty:
            return str(first(s))
        else:
            return str(first(s)) + separator + join_link(rest(s), separator)

>>> join_link(four, ", ")
'1, 2, 3, 4'
```

**递归构建**. 链表在我们增量地构造序列的时候尤其有用, 这种情况经常在递归计算中出现.

第一章中的`count_partitions`函数通过树递归过程来计算整数n用最大为m的数来进行分割的总数. 通过序列我们也可以通过明确地使用相似的过程来枚举这些切分.

跟我们计算时一样, 我们用跟随问题的相同递归分析: 用最大为m的整数来划分n涉及到

1. 使用最大为m的整数来划分n-m, 或者
2. 使用最大为m-1的整数来划分n

对于基本情况, 我们发现用一个负整数或者用小于1的部分来划分0是不可能的, 因此0的划分数为空.

```python
>>> def partitions(n, m):
        """Return a linked list of partitions of n using parts of up to m.
        Each partition is represented as a linked list.
        """
        if n == 0:
            return link(empty, empty) # A list containing the empty partition
        elif n < 0 or m == 0:
            return empty
        else:
            using_m = partitions(n - m, m)
            with_m = apply_to_all_link(lambda s: link(m, s), using_m)
            without_m = partitions(n, m - 1)
            return extend_link(with_m, without_m)
```

在递归情况下, 我们构建两个分区的子列表. 第一个用m, 因此我们在结果`using_m`中的每个元素前面加上m来构建`with_m`.

partitions的结果是高度嵌套的: 一个链接列表的链接列表, 并且每个链接列表被表示为作为列表值的嵌套对. 在`join_link`函数中用恰当的分隔符, 我们可以用人类可阅读的方式来展示出分区.

```python
>>> def print_partitions(n, m):
        lists = partitions(n, m)
        strings = apply_to_all_link(lambda s: join_link(s, " + "), lists)
        print(join_link(strings, '\n'))

>>> print_partitions(6, 4)
4 + 2
4 + 1 + 1
3 + 3
3 + 2 + 1
3 + 1 + 1 + 1
2 + 2 + 2
2 + 2 + 1 + 1
2 + 1 + 1 + 1 + 1
1 + 1 + 1 + 1 + 1 + 1
```

### 2.4 可变数据

我们已经见识过抽象对于帮助我们应对大型系统的复杂性上的重要性了. 有效的编程依赖于有组织的能够指导我们在制定程序的整体设计的规则. 尤其是, 我们需要很多策略来帮助我们构造模块化的大型系统, 这意味着它们会自然分裂成各个相关的部分且能够分头开发以及维护.

有一个强大的创建模块化程序的技术, 那就是合并可能随时间改变状态的数据, 通过这种方式, 单个数据对象可以表示独立于程序的其余部分演进的东西. 改变对象的行为可能会受到其历史的影响, 就像一个真实世界的实体一样. 为数据添加状态是面向对象编程范式的核心要素

#### 2.4.1 对象隐喻

在本文开头, 我们要区分函数跟数据: 函数用于执行操作, 而数据则是在其上被操作. 当我们在我们的数据中包含函数的值的时候, 我们认识到数据也可以具有行为. 函数可以作为数据来操作, 也可以被调用来执行计算.

*对象*将数据值与行为进行组合. 对象代表信息, 同时也表现得像它们所代表的事物. 一个对象跟另一个对象互动的逻辑是跟编码这个对象的值捆绑在一起的. 当一个对象需要被打印出来时, 它知道如何用文本来表示自身, 如果一个对象是由部分组合而成的, 那么它知道如何按需显示这些部分. 对象(包含的)全都是信息以及(处理)过程, (它们)捆绑在一起来表示复杂事物的性质, 相互作用和行为.

对象的行为在Python中是通过专门的对象语法以及相关术语来实现的, 我们可以通过例子来进行介绍, 一个日期是一个对象.

```python
>>> from datetime import date
```

名称`date`绑定到一个类上的. 正如我们看到的, 一个类代表一种值. 个别的日期就叫做这个类的实例. 实例能够通过使用表明这个实例的特征参数来调用类来构建.

```python
>>> tues = date(2014, 5, 13)
```

当用原始数字构造`tues`之后, 它的行为表现得像日期一样, 例如, 将它跟其他的日期相减会返回一个时差, 我们可以打印出来.

```python
>>> print(date(2014, 5, 19) - tues)
6 days, 0:00:00
```

对象具有*属性*, 是一个命名后的对象的一部分的值. 在Python中, 像很多其他的编程语言一样, 我们用点符号来指定一个对象的属性.

`<expression> . <name>`

上面, `<expression>`是一个对象, 然后`<name>`是一个对象属性的名称. 不我们至今为止考虑过的名称, 属性名对于点符号前面的对象实例来说是独特的.

```python
>>> tues.year
2014
```

对象通常也有方法, 也就是属性值为函数的属性. 隐含的意思是, 我们认为这个对象"知道"如何去执行这些方法. 通过实现, (对象)方法是一个用来从它们的参数以及它们的对象中计算结果的函数. 例如, `tues`有一个`strftime`方法(一个经典函数的名称, 意思是"字符串格式的时间")接受一个参数用于指定如何显示日期(例如: %A表示这周的某一天应该完整地拼写出来).

```python
>>> tues.strftime("%A, %B %d")
'Tuesday, May 13'
```

计算`strftime`的返回值需要两个输入: 一个用于描述输出格式的字符串以及绑定在tues中的日期信息. 特定日期逻辑需要应用这个方法来返回结果. 我们从来没有说过2014年5月13号是星期二, 但是知道它对应的是工作日的一部分, 这就意味着它是一个日期. 通过将行为以及信息绑定到一起, 这个Python对象提供给我们一个可信的, 自足的日期抽象.

日期是一个对象, 而且数字, 符串吗, 列表以及区间等也全都是对象. 它们代表一个值, 而且还以符合它们表示的值的方式表现. 它们也有属性以及方法. 比如, 字符串具有一个数组方法用于方便文本处理.

```python
>>> '1234'.isnumeric()
True
>>> 'rOBERT dE nIRO'.swapcase()
'Robert De Niro'
>>> 'eyes'.upper().endswith('YES')
True
```

实际上, 在Python中所有的值都是对象, 也就是说, 所有值都具有行为以及属性. 它们的行为就像它们所代表的值.

#### 2.4.2 序列对象

原始內建的值的实例如数字是不可变的. 这个值在程序的执行过程中是不可变的. 而另一方面列表则是可变的.

可变对象用来代表随时间变化的值. 一个人是在今天到明天依然是同一个人, 尽管变得老了, 剪了头发, 或者以某种方式改变了. 同样地, 一个对象的属性可能会由于可变操作而改变了属性. 例如, 可以改变列表中的内容. 大多数改变通过调用执行列表对象内部的方法.

我们可以通过一个说明扑克牌历史的例子(大大简化)来介绍很多列表的修改操作. 在例子的注释中, 描述了每个方法调用的结果.

扑克牌是在中国发明的, 大约在9世纪. 较早的扑克牌只有三种花式, 分别跟钱的面额对应起来.

```python
>>> chinese = ['coin', 'string', 'myriad'] # 一个文字列表
>>> suits = chinese # 两个名字对应同一个列表
```

随着扑克牌传入欧洲(可能是通过埃及), 只有coin那那个花式还存在西班牙的牌桌上(oro).

```python
>>> suits.pop() # 删除最后一个元素并返回
'myriad'
>>> suits.remove('string') # 删除跟参数相等的第一个元素
```

新增了三个花式(它们的名字还有设计进行了几次更改).

```python
>>> suits.append('cup') # 添加一个元素到最后
>>> suits.extend(['sword', 'club']) # 将所有的元素添加到序列的最后
```

然后意大利人将剑叫做锹.

```python
>>> suits[2] = 'spade' # 替代一个元素
```

得到一副传统的意大利扑克牌.

```python
>>> suits
['coin', 'cup', 'spade', 'club']
```

今天美国用的扑克牌是法国的变种, 修改了前两个花式:

```python
>>> suits[0:2] = ['heart', 'diamond'] # 修改一个切片
>>> suits
['heart', 'diamond', 'spade', 'club']]
```

还存在用于插入, 排序, 以及翻转列表的方法. 所有这些变动的操作都会修改列表的值; 它们不会创建一个新的列表对象.

**共享和标识**. 由于我们已经修改单个列表, 而不是创建一个新的列表, 因此对象绑定的名称`chinese`的值同样也会改变, 因为它跟suits绑定的是同一个列表对象.

```python
>>> chinese  # 名称跟"suits"共同指代同一个被修改的列表
['heart', 'diamond', 'spade', 'club']
```

这种行为是新的. 早先, 如果一个名称没有出现在一个语句中, 那么它的值就不会被这个语句影响到. 对于可变数据, 在一个名称上调用方法能够同时影响到其他的名称.

对于这里例子, 下面的运行环境图展示了跟chinese名称绑定的值是如何在只涉及到suits的语句中被修改的. 观察例子中的每一个步骤来查看这些改变.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=chinese%20%3D%20%5B'coin',%20'string',%20'myriad'%5D%0Asuits%20%3D%20chinese%0Asuits.pop(%29%0Asuits.remove('string'%29%0Asuits.append('cup'%29%0Asuits.extend(%5B'sword',%20'club'%5D%29%0Asuits%5B2%5D%20%3D%20'spade'%0Asuits%5B0%3A2%5D%20%3D%20%5B'heart',%20'diamond'%5D&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

列表对象可以用列表构造器函数来复制. 修改一个列表不会影响到另外一个, 除非它们共享相同的数据结构.

```python
>>> nest = list(suits) # 绑定"nest"到第二个具有相同元素的列表中
>>> nest[0] = suits # 创建一个嵌套的列表
```

根据这种环境, 通过suits引用来修改列表会影响到nest的第一个元素的那个内嵌的列表, 但是不会对其他的元素有影响.

```python
>>> suits.insert(2, 'Joker')  # 在下标为2的地方插入一个元素, 其他的元素进行响应的移位
>>> nest
[['heart', 'diamond', 'Joker', 'spade', 'club'], 'diamond', 'spade', 'club']
```

同样地, 在nest的第一个元素中撤销这个改动同样也会影响到suit

```python
>>> nest[0].pop(2)
'Joker'
>>> suits
['heart', 'diamond', 'spade', 'club']
```

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=suits%20%3D%20%5B'heart',%20'diamond',%20'spade',%20'club'%5D%0Anest%20%3D%20list(suits%29%0Anest%5B0%5D%20%3D%20suits%0Asuits.insert(2,%20'Joker'%29%0Ajoke%20%3D%20nest%5B0%5D.pop(2%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

因为两个列表有可能会有相同的内容, 但是实际上是两个不同的列表, 我们需要一个手段来测试两个对象是否是相同的. Python含有两个比较操作符, 叫做 `is` 以及 `is not`, 用来测试两个表达式实际上是否得到的是相同的对象. 如果两个对象它们的当前值是一样的, 然后任何一个的改动都会反映到另一个对象中, 那么两个对象是相等的. 身份标识是比相等性更强的条件.

```python
>>> suits is nest[0]
True
>>> suits is ['heart', 'diamond', 'spade', 'club']
False
>>> suits == ['heart', 'diamond', 'spade', 'club']
True
```

最后两个比照说明了 `==` 跟 `is` 两者的不同, 前者检查身份, 而后者则是检查内容的的相等性

**列表推导**. 一个列表推导总是会创建一个新的列表. 例如, `unicodedata`模块跟踪Unicode字母表中每一个字符的官方名称. 我们可以查找与名称相对应的字符, 包括那些扑克牌的花式.

```python
>>> from unicodedata import lookup
>>> [lookup('WHITE ' + s.upper() + ' SUIT') for s in suits]
['♡', '♢', '♤', '♧']
```

这些结果列表并没有将它的内容跟suits进行共享, 执行列表表达式也不会改动到suits列表.

你可以在Dive into Python 3中的[Unicode章节][5]中, 查看更多相关的用于表示文本的Unicode标准.

**元组**

一个元组, 是一个內建的`tuple`类型的实例, 是一个不可变序列. 是用元组字面量, 也就是用逗号分割元素来创建的. 括号是可选的, 但是在实践中经常使用. 任何对象都可以放在元组中.

```python
>>> 1, 2 + 3
(1, 5)
>>> ("the", 1, ("and", "only"))
('the', 1, ('and', 'only'))
>>> type( (10, 20) )
<class 'tuple'>
```

空的或者拥有一个元素的元组具有特殊的字面语法.

```python
>>> ()    # 0 elements
()
>>> (10,) # 1 element
(10,)
```

像列表, 元组具有有限的长度, 同时也支持元素选择. 它们同样也具有一些可用于列表的方法, 例如`count`以及`index`.

```python
>>> code = ("up", "up", "down", "down") + ("left", "right") * 2
>>> len(code)
8
>>> code[3]
'down'
>>> code.count("down")
2
>>> code.index("left")
4
```

然而, 对于那些操作列表内容的方法在元组中是不可用的, 因为元组是不可变的.

因此无法改变元组中的元素, 但是可以修改一个包含在元组中的可变元素的值.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=nest%20%3D%20(10,%2020,%20%5B30,%2040%5D%29%0Anest%5B2%5D.pop(%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

多重赋值中隐式地使用元组, 一个将两个值绑定到两个名称中的赋值语句会创建两个元素的元组然后对它进行解包.

#### 2.4.3 字典

字典在Python中是一个內建的数据类型, 用来存储以及操作对应关系. 一个字典包含有多个键值对, 键跟值都是对象. 字典的目的是提供一个抽象化的用于存储以及检索数据并不以连续的整数而是描述性的键值为下标的地方.

通常用字符串来作为键值, 因为我们常用一个字符串名称来表示一样东西. 这个字典字面量给定各种罗马数字的值.

```python
>>> numerals = {'I': 1.0, 'V': 5, 'X': 10}
```

使用元素选择操作符通过它们的键来查看我们先前应用于序列的对应的值.

```python
>>> numerals['X']
10
```

一个字典中每一个键最多只能有一个对应的值. 添加新的键值对或者通过键来修改已经存在的值都可以通过赋值语句实现.

```python
>>> numerals['I'] = 1
>>> numerals['L'] = 50
>>> numerals
{'I': 1, 'X': 10, 'L': 50, 'V': 5}
```

注意到, `L`的值在前面的输出结果中是没有添加的. 字典是无序的键值对集合. 当我们输出一个字典, 键跟值会以某种顺序渲染, 而作为语言的用户, 我们无法预知将会按照何种顺序渲染. 当多次运行程序时这种顺序可能会改变.

字典也可以在环境图例中出现.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=numerals%20%3D%20%7B'I'%3A%201,%20'V'%3A%205,%20'X'%3A%2010%7D%0Anumerals%5B'L'%5D%20%3D%2050&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

字典类型也支持多种用于迭代它包含的作为一个整体的字典内容的方法, `keys`, `values`以及`items`都返回一个可迭代的值

```python
>>> sum(numerals.values())
66
```

由键值对形式组成的列表可以通过调用`dict`构造函数来转化成一个字典. 

```python
>>> dict([(3, 9), (4, 16), (5, 25)])
{3: 9, 4: 16, 5: 25}
```

字典也具有一些限制:

- 字典中的一个键不能对应多个值
- 对于一个给定的键最多只能有一个值.

第一个限制是跟Python字典底层实现相绑定的. 这个限制的细节不是本文的主题. 可以直观地认为键告诉Python在内存中哪里去找这个键值对; 如果这个key值改变了这个对的位置可能就会不见了. 元组通常也是可以在字典中作为键, 因为列表不可以用作键值.

第二个限制是字典抽象的一个必然结果, 那就是设计用一个键来存储以及检索一个值. 如果最多只有一个这样的值存在于字典当中, 我们只能用一个键来检索这个值.

一个由字典来执行的有用的方法是`get`, 这个方法要么会返回一个存在的键所对应的值, 要么返回一个默认值. 而`get`方法的参数就是键以及默认值.

```python
>>> numerals.get('A', 0)
0
>>> numerals.get('V', 0)
5
```

字典也有一个类似于列表的解析式语法. 一个键表达式以及一个值表达式通过一个冒号隔开, 执行一个字典解析会创建一个新的字典对象.

```python
>>> {x: x*x for x in range(3,6)}
{3: 9, 4: 16, 5: 25}
```

#### 2.4.4 本地状态

列表跟字典都有本地状态: 它们在程序运行的任意一个点上修改具有特定内容的值. "状态"这个词暗示了一个演变的过程, 表示这个状态可能会改变.

函数也可以具有本地状态. 例如, 让我们定义一个函数用于模拟从一个银行账户中提款的过程. 我们会创建一个叫做withdraw的函数, 它把一个数额作为它的参数. 如果这个账户具有足够的金额用于提款, 那么`withdraw`会返回提款后的剩余余额. 否则, `withdraw`会返回信息'资金不足', 例如, 如果我们开始有$100在账户内, 我们会希望调用`withdraw`后能够得到下面的一系列的返回值

```python
>>> withdraw(25)
75
>>> withdraw(25)
50
>>> withdraw(60)
'Insufficient funds'
>>> withdraw(15)
35
```

上面表达式`withdraw(25)`, 运算了两次, 返回了不同的值. 因此, 这个用户定义函数是不纯的. 调用这个函数不仅返回一个值, 同时还会带有副作用以某种方式来改变这个函数, 因此下一次用相同的参数来调用函数会返回不同的值. 这个副作用是由`withdraw`函数更改当前环境的一个外部名称值的绑定而造成的.

为了让`withdraw`函数有意义, 它必须用一个具有余额的初始的账户来创建. 而函数`make_withdraw`是一个更高层次的函数, 需要一个初始余额作为参数. 而函数withdraw则是它的返回值.

```python
>>> withdraw = make_withdraw(100)
```

`make_withdraw`的一个实现需要一种新类型的语句: 一个非本地的声明. 当我们调用`make_withdraw`时, 我们绑定名称`balance`到一个初始账户中. 然后我们定义并返回一个本地函数`withdraw`, 当调用这个函数时会更新以及返回`balance`的值.

```python
>>> def make_withdraw(balance):
        """Return a withdraw function that draws down balance with each call."""
        def withdraw(amount):
            nonlocal balance
            if amount > balance:
                return 'Insufficient funds'
            balance = balance - amount
            return balance
        return withdraw
```

`nonlocal`语句声明了无论任何时候我们改变名称`balance`的绑定值, 都会反映到这个`balance`第一个找到的绑定值的环境帧里面. 回想一下没有`nonlocal`声明, 一个赋值语句总是会绑定绑定一个名称到它的当前环境的第一个帧里面. 这个`nonlocal`语句表示名称出现在环境中除第一(本地)帧或最后(全局)帧之外的某处.

接下来的环境图例演示了多次调用`make_withdraw`创建的函数的影响.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20make_withdraw(balance%29%3A%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20nonlocal%20balance%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20balance%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20balance%20%3D%20balance%20-%20amount%0A%20%20%20%20%20%20%20%20return%20balance%0A%20%20%20%20return%20withdraw%0A%0Awd%20%3D%20make_withdraw(20%29%0Awd(5%29%0Awd(3%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

第一个def语句具有通常的效果: 它创建了一个新的用户定义函数并在全局环境绑定名称`make_withdraw`到这个函数. 而随后调用`make_withdraw`创建并返回了一个本地定义的函数`withdraw`. 名称`balance`绑定在这个函数的父级帧中. 至关重要的是, 在该示例的其余部分中将仅存在用于名称`balance`的单个绑定.

接下来, 我们执行一个表达式来用金额为5的参数来调用这个绑定到名称wd上的函数. `withdraw`的函数体执行在新的拓展自`withdraw`被定义的的环境中. 跟踪函数`withdraw`的运行, 演示了`nonlocal`语句在Python中的效果: 一个在第一个局部帧外面的的名称能够通过赋值语句来修改.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20make_withdraw(balance%29%3A%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20nonlocal%20balance%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20balance%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20balance%20%3D%20balance%20-%20amount%0A%20%20%20%20%20%20%20%20return%20balance%0A%20%20%20%20return%20withdraw%0A%0Awd%20%3D%20make_withdraw(20%29%0Awd(5%29%0Awd(3%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

`nonlocal`声明在`withdraw`的定义内修改所有剩余的赋值语句. 在执行`nonlocal balance`之后, 任何跟`balance`相关的把它放在等号左边的赋值语句都不会绑定`balance`到当前环境的第一帧里去. 相反, 它会找到`balance`已经被定义的第一个帧然后在这一帧内将把名称进行重新的绑定. 如果`balance`之前并没有跟一个值进行绑定, 那么`nonlocal`语句会抛出一个错误.

通过修改`balance`的绑定, 我们也修改了`withdraw`函数. 下一次它被调用时, 名称`balance`会执行15而不是20. 因此, 当我们第二次调用`withdraw`时, 我们会看到它返回值12而不是17. 第一次调用对`balance`的修改会反映到第二次调用的结果中去.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20make_withdraw(balance%29%3A%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20nonlocal%20balance%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20balance%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20balance%20%3D%20balance%20-%20amount%0A%20%20%20%20%20%20%20%20return%20balance%0A%20%20%20%20return%20withdraw%0A%0Awd%20%3D%20make_withdraw(20%29%0Awd(5%29%0Awd(3%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

通常来说, 第二次调用`withdraw`会创建第二个本地帧. 然而, 两个`withdraw`帧具有相同的父级. 也就是说, 它们都拓展自那个包含有`balance`的绑定的`make_withdraw`的环境中. 因此, 它们共享那个特定的名称绑定. 调用`withdraw`函数具有改变环境的局部影响, 且会把这个影响延展到`withdraw`未来的调用中去. `nonlocal`声明允许`withdraw`函数来改变`make_withdraw`帧中的名称的绑定.

自从我们第一次遇到嵌套的def语句以来, 我们已经意识到本地定义函数可以访问它本地帧以外的名称. 访问非本地名称不需要`nonlocal`语句. 相比之下, 只有在`nonlocal`声明之后, 一个函数才能在这些帧里面修改名称的绑定.

通过介绍`nonlocal`声明, 我们已经为赋值语句创建了一个双重角色. 不管它们是修改本地绑定, 还是修改`nonlocal`绑定. 实际上, 赋值语句已经具有了双重性, 它们不仅可以创建新的绑定也可以重新绑定已经存在的名称. 赋值也可以修改列表以及字典的内容. Python中赋值中的许多角色会掩盖执行赋值语句的影响. 这取决于你作为一个程序员是如何文档化你的代码以清晰地表明赋值的影响来让其他人可以明白.

**Python细节**. 这种`non-local`模式的赋值是一个具有高阶函数以及词法作用域的编程语言的一般特性. 大部分其他的编程语言一点都不需要`nonlocal`声明. 反而, `non-local`赋值通常是赋值语句的默认行为.

Python对于名称的查找也具有一个不同寻常的限制: 在函数体内, 所有的名称的实例必须要指向同一帧. 因此, Python在一个`non-local`帧内不能查找到名称的值, 并绑定相同的名称到本地帧内, 因为相同的名称会在两个不同的帧内被同一个程序访问到. 这个限制允许Python在函数体执行前预先计算包含每个名称的帧. 当这个限制被违反时, 会产生混乱的错误结果信息. 作为演示, 下面重复`make_withdraw`示例, 并去除nonlocal语句.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20make_withdraw(balance%29%3A%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20balance%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20balance%20%3D%20balance%20-%20amount%0A%20%20%20%20%20%20%20%20return%20balance%0A%20%20%20%20return%20withdraw%0A%0Awd%20%3D%20make_withdraw(20%29%0Awd(5%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

出现了这个`UnboundLocalError`错误是因为`balance`在第五行被本地分配了一个本地值, 因此Python假设所有对`balance`的引用也必须出现在本地帧内. 这个错误出现在第五行被执行前, 意味着Python在执行第三行之前已经以某种方式考虑了第五行. 当我们学习解析器设计时, 我们会了解到在函数体执行之前进行预编译是相当普遍的事情. 在这个例子中, Python的预编译限制帧内可能出现`balance`, 因此预先阻止找到该名称. 添加一个`nonlocal`声明可以修复这个错误. `nonlocal`声明在Python 2中是不存在的.

#### 非本地赋值的好处

非本地赋值在我们将程序看作是一个独立与自治的对象(也就是对象之间相互交互但各自管理他们自己内部的状态)的路上是重要的一步.

尤其是非本地赋值赋予了我们能力来管理一些函数的内部状态, 但是在调用这个函数时会发展出过度的连续性. `balance`与特定的`withdraw`函数相联系并共享于这函数的所有调用中. 然而为`balance`绑定到相联系的withdraw实例在程序的其余地方是不可访问的. 只有`wd`在它定义的`make_withdraw`帧内是可访问的. 如果`make_withdraw`再次被调用那么它会创建包含一个单独的`balance`绑定的一个单独的帧.

我们可以扩展我们的例子来演示这一点. 第二次调用`make_withdraw`返回第二个具有一个不同父级的`withdraw`函数.我们绑定这第二个函数到全局帧的名称wd2上.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20make_withdraw(balance%29%3A%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20nonlocal%20balance%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20balance%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20balance%20%3D%20balance%20-%20amount%0A%20%20%20%20%20%20%20%20return%20balance%0A%20%20%20%20return%20withdraw%0A%0Awd%20%3D%20make_withdraw(20%29%0Awd2%20%3D%20make_withdraw(7%29%0Awd2(6%29%0Awd(8%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

现在我们可以看到那里其实有两个对`balance`的绑定在两个不同的帧里面，同时每一个`withdraw`函数都有一个不同的父级. 名称wd绑定到一个具有`balance`为20的函数上, 同时wd2绑定到一个具有`balance`为7的不同函数上.

调用wd2会修改它的非本地绑定名称`balance`, 但不会影响绑定到`withdraw`名称的函数. wd之后的调用不会受到wd2中改变的`balance`的影响, 它的`balance`依然是20

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20make_withdraw(balance%29%3A%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20nonlocal%20balance%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20balance%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20balance%20%3D%20balance%20-%20amount%0A%20%20%20%20%20%20%20%20return%20balance%0A%20%20%20%20return%20withdraw%0A%0Awd%20%3D%20make_withdraw(20%29%0Awd2%20%3D%20make_withdraw(7%29%0Awd2(6%29%0Awd(8%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

通过这种方式, 每一个`withdraw`的实例维护着它自己的`balance`状态, 但是这个状态对于程序中其他任何一个函数来说都是不可访问的. 在高层级来看这种情况, 我们已经创建了一个会管理它自己的内部但是以某种方式活动的生活中的账户模型的银行账户的抽象.

#### 2.4.6 非本地赋值的成本

我们的计算环境模型清晰地拓展到解释非本地赋值的影响. 然而, 非本地赋值介绍了一些在我们思考名称以及值的方式上的重要的细微差别.

之前, 我们的值是不会修改的; 只有我们的名称以及绑定会修改, 当两个名称a以及b都绑定到一个值 4 上时, 它们是否绑定到相同的或者是不同的 4 是无所谓的, 据我们所知, 只有一个 4 对象且从不改变.

然而, 具有状态的函数不是以这种行为方式. 当两个名称 wd 以及 wd2 都绑定到一个`withdraw`函数上时, 对于它们是否绑定到同一个函数或者这个函数的不同实例上是有关系的. 考虑一下下面的例子, 它与我们刚刚分析的例子相对比. 在这种情况下, 调用命名为 wd2 的函数会修改命名为 wd 的函数的值, 因为这些名字都是引用同一个函数.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20make_withdraw(balance%29%3A%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20nonlocal%20balance%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20balance%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20balance%20%3D%20balance%20-%20amount%0A%20%20%20%20%20%20%20%20return%20balance%0A%20%20%20%20return%20withdraw%0A%0Awd%20%3D%20make_withdraw(12%29%0Awd2%20%3D%20wd%0Awd2(1%29%0Awd(1%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

世界上用两个名称共同引用同一个值是很常见的, 所以它存在我们的程序当中. 但是, 值会随着时间而变化, 我们必须要小心理解对于修改其他名称而影响到这些名称会带来的结果.

正确地分析带有分本地赋值的代码的关键是要记住, 只有函数调用可以引入新的帧. 赋值语句总是在已存在的帧内修改绑定. 在这种情况下, 除非调用`make_withdraw`两次, 否则只能绑定一次`balance`.

**相同和改变**. 提出这些细微之处是因为随着会修改分本地环境的非纯函数的引入, 我们已经改变了表达式的性质. 一个表达式只包含纯函数调用的话是可靠透明的; 如果我们用其子表达式的值替换其子表达式之一, 它的值不会修改.

重新绑定操作符违反了透明引用这个条件因为它们除了返回一个值还做了更多的事情; 它们修改了环境. 当我们引入任意重绑定, 我们就遇到了一个棘手的认识论问题: 它意味着两个值是相等的. 在我们的计算环境模型中, 分别定义的两个函数不是相同的, 因为修改一个应该不会关联到另外一个.

一般来说, 只要我们从来没有修改数据对象, 我们可以认为复合数据对象恰好就是它所有部分的总和. 例如, 一个有理数取决于给定它一个分子和分母. 但是这种观点在存在变化的情况下已经不在有效, 也就是一个复合数据对象具有一个"身份标识", 用来跟它组成的片段来进行区分的. 一个银行账户依然是"同一个"银行账户, 即使我们通过支取来修改了余额; 反过来, 我们可以有两个恰巧有相同余额的账户, 但是是两个不同的对象.

尽管它引入了复杂性, 非本地赋值依然是一个创建模块化程序的强力工具. 程序的不同部分对应着不同的环境帧, 能够随着软件的执行来分别演进. 此外, 使用带有本地状态的函数, 我们能够实现可变数据类型. 实际上, 我们可以实现相当于上面提到的內建的list以及dict类型的抽象数据类型.

#### 2.4.7 列表以及字典的实现

Python语言并不允许我们访问列表的实现, 只是內建了序列抽象以及变动方法到语言里面去. 可以通过具有本地状态的函数来理解可变列表是如何进行表示的, 现在我们将会开发一个可变的链表实现.

我们会通过一个具有链表作为它的本地状态的函数来表现一个可变链表, 列表需要有一个身份, 就像其他任何可变值. 尤其是, 我们不能用 None 来代表一个空的可变列表, 因为两个空的列表不是相同的值(例如: 为其中一个列表插入元素并不会插入到另一个当中), 但是 None 就是 None. 另一方面, 两个都具有`empty`作为它的本地状态的不同的函数将足以用来区分两个空列表.

如果一个可变链表是一个函数, 它会需要什么传入什么参数呢? 答案展示了编程中的一般模式: 这个函数是一个调度函数同时它的参数首先是一个消息, 后面跟着参数化该方法的其他参数. 这个消息是一个字符串名称表示这个函数应该做什么. 调度函数实际上集合了许多的函数: 用消息确定函数的行为, 以及将额外的参数用在这个行为上.

我们的可变列表会回应5种不同的消息: `len`, `getitem`, `push_first`, `pop_first`, 以及`str`. 前两个实现序列抽象的行为. 接下来的两个用于增加或者移除列表的第一个元素. 最后一个消息返回代表整个链表的字符串.

```python
>>> def mutable_link():
        """Return a functional implementation of a mutable linked list."""
        contents = empty
        def dispatch(message, value=None):
            if message == 'len':
                return len_link(contents)
            elif message == 'getitem':
                return getitem_link(contents, value)
            elif message == 'push_first':
                contents = link(value, contents)
            elif message == 'pop_first':
                f = first(contents)
                contents = rest(contents)
                return f
            elif message == 'str':
                return join_link(contents, ', ')
        return dispatch
```

我们也可以增加一个简便函数来从任何的內建序列中构造一个实现了功能的链表, 简单地相反的顺序来添加每一个元素.

```python
>>> def to_mutable_link(source):
        """Return a functional list with the same contents as source."""
        s = mutable_link()
        for element in reversed(source)
            s('push_first', element)
        return s
```

在上面的定义中, 函数`reversed`接受并返回一个可迭代的值; 这是另一个函数处理序列的例子.

到现在, 我们可以构造一个实现了功能的可变链表. 要注意这个链表本身是一个函数.

```python
>>> s = to_mutable_link(suits)
>>> type(s)
<class 'function'>
>>> print(s('str'))
heart, diamond, spade, club
```

此外, 我们可以输入信息到列表 `s` 来改变它的内容, 为实例移除它的第一个元素.

```python
>>> s('pop_first')
'heart'
>>> print(s('str'))
diamond, spade, club
```

原则上, `push_first`以及`pop_first`足以对列表进行任意更改. 我们可以总是清空整个列表然后用期望的结果来替换它的旧内容.

**消息传递**. 给定一些时间, 我们可以实现很多Python列表的有用的变动操作. 例如`extend`以及`insert`. 对此我们可以进行选择: 我们可以使用已存在的消息`pop_first`以及`push_first`来进行所有的更改将它们都实现在一个函数里面. 或者, 我们可以添加额外的`elif`条件到`dispatch`函数体中, 每一个对一种消息进行检查(例如: `extend`)以及直接应用适当的修改到内容当中.

第二种方法, 就是将所有操作的逻辑封装到响应不同消息的一个函数内的数据值上, 这是一种称为消息传递的规则. 一个使用消息传递来定义调度函数的程序, 每一个这种函数都可以具有局部状态, 以及通过传递"消息"作为第一个参数来组织计算. 消息是对应特殊行为的字符串.

**实现字典**. 我们还可以实现一个具有跟字典类似行为的值. 在这种情况下, 我们用一个键值对的列表来保存字典的内容. 每个对是一个两个元素的列表.

```python
>>> def dictionary():
        """Return a functional implementation of a dictionary."""
        records = []
        def getitem(key):
            matches = [r for r in records if r[0] == key]
            if len(matches) == 1:
                key, value = matches[0]
                return value
        def setitem(key, value):
            nonlocal records
            non_matches = [r for r in records if r[0] != key]
            records = non_matches + [[key, value]]
        def dispatch(message, key=None, value=None):
            if message == 'getitem':
                return getitem(key)
            elif message == 'setitem':
                setitem(key, value)
            return dispatch
```

再一次, 我们用消息传输方法来组织我们的实现. 我们已经支持两个消息: `getitem`和`setitem`. 为一个键插入一个值, 我们过滤出任何给定键的存在记录, 然后添加一个. 通过这种方式, 我们保证每一个键值在记录中只出现一次. 要为一个键找出它的值, 我们过滤出符合给定的键的值. 我们现在可以用我们的实现来保存以及检索值.

```python
>>> d = dictionary()
>>> d('setitem', 3, 9)
>>> d('setitem', 4, 16)
>>> d('getitem', 3)
9
>>> d('getitem', 4)
16
```

这种实现的字典没有为快速查找作优化, 因为每一次调用必须要过滤全部的记录. 內建的字典类型是十分高效的. 它的实现方式超出了本文的范围.

#### 2.4.8 调度字典

调度函数是为抽象数据实现消息传递接口的一般方法. 为了实现消息调度, 迄今为止我们使用条件语句来对比消息字符串跟已知消息的固定集.

內建的字典数据类型提供一个一般的方法来查找一个键的值. 而不是使用条件来实现派发, 我们可以用字符串作为字典的键.

下面的可变`account`数据类型实现为一个字典. 它有一个构造器`account`以及一个选择器`check_balance`, 以及用于存储(deposit)或者取出(withdraw)资金的函数. 此外, 账户的本地状态也被保存在字典周围实现它的功能的函数中.

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20account(initial_balance%29%3A%0A%20%20%20%20def%20deposit(amount%29%3A%0A%20%20%20%20%20%20%20%20dispatch%5B'balance'%5D%20%2B%3D%20amount%0A%20%20%20%20%20%20%20%20return%20dispatch%5B'balance'%5D%0A%20%20%20%20def%20withdraw(amount%29%3A%0A%20%20%20%20%20%20%20%20if%20amount%20%3E%20dispatch%5B'balance'%5D%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20'Insufficient%20funds'%0A%20%20%20%20%20%20%20%20dispatch%5B'balance'%5D%20-%3D%20amount%0A%20%20%20%20%20%20%20%20return%20dispatch%5B'balance'%5D%0A%20%20%20%20dispatch%20%3D%20%7B'deposit'%3A%20%20%20deposit,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'withdraw'%3A%20%20withdraw,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'balance'%3A%20%20%20initial_balance%7D%0A%20%20%20%20return%20dispatch%0A%0Adef%20withdraw(account,%20amount%29%3A%0A%20%20%20%20return%20account%5B'withdraw'%5D(amount%29%0Adef%20deposit(account,%20amount%29%3A%0A%20%20%20%20return%20account%5B'deposit'%5D(amount%29%0Adef%20check_balance(account%29%3A%0A%20%20%20%20return%20account%5B'balance'%5D%0A%0Aa%20%3D%20account(20%29%0Adeposit(a,%205%29%0Awithdraw(a,%2017%29%0Acheck_balance(a%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

`account`构造器函数体内的`dispatch`到一个包含由帐户接受的消息作为键的字典进行绑定. 当存款以及取款消息绑定跟函数绑定, 余额就是一个数字. 这些函数能够访问`dispatch`字典, 同时, 它们也可以查看以及修改余额. 通过保存余额在dispatch字典中而不是直接保存在在account函数帧中, 我们避免了在`deposit`以及`withdraw`中需要用到`nonlocal`声明.

`+=`以及`-=`操作是Python(以及其他许多语言)中用于组合查找和重新分配的简便方法. 相当于下面的最后两行.

```python
>>> a = 2
>>> a = a + 1
>>> a += 1
```

#### 2.4.9 传播约束

可变数据允许我们去模拟具有改变的系统, 也允许我们去构建新类型的抽象. 在这个扩展例子中, 我们组合非本地声明, 列表, 以及字典来构建一个基础约束的系统, 它支持多种说明的计算. 作为约束的表达式程序是声明性编程的一种类型, 也就是一个程序员声明要去解决的问题的结构, 但是抽象出了究竟如何计算问题的解决方案的细节。.

计算机程序传统上是组织为单方向计算的, 也就是在预先指定的参数上执行操作来生产期望的输出. 另一方面, 我们通常想要以数量的关系来对系统建模. 例如, 我们以前思考过的理想气体定律, 它是通过玻尔兹曼常数(k)来跟压力(p), 体积(v), 数量(n), 以及温度(t)相关的.

`p * v = n * k * t`

这样的一个方程不是单项的. 有任意四个给定的数量, 我们可以用这个等式来计算第五个. 然而将这个等式转换到传统的计算机语言中或迫使我们去选择一个数量并用其他四个数量来计算出它. 因此, 一个计算压力的函数无法被用来计算温度, 即使所有需要计算的数量都源自同一个等式.

在本节中, 我们用线性关系来勾勒出一般模型的设计. 我们定义保留在数量之间的原始约束, 例如一个`adder(a, b, c)`约束会强制得到数学关系`a + b = c`.

我们还定义了一种组合方法, 因此原始约束可以被组合来表达出更多复杂的关系. 通过这种方式, 我们的程序就类似于一个程序语言. 我们通过构建一个由连接器连接来连接约束的网络来组合约束. 一个连接器是一个持有一个值以及并且可以参与一个或多个约束的对象.

例如, 我们知道华氏度以及摄氏度之间的关系是: `9 * c = 5 * (f - 32)`

[1]: http://en.wikipedia.org/wiki/IEEE_floating_point
[2]: http://getpython3.com/diveintopython3/native-datatypes.html
[3]: http://getpython3.com/diveintopython3/native-datatypes.html#slicinglists
[4]: http://getpython3.com/diveintopython3/strings.html
[5]: http://getpython3.com/diveintopython3/strings.html#one-ring-to-rule-them-all
