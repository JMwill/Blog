title: 程序构成-第二章
tags:
- 译文
- Design Programs
---

## 第二章: 构筑抽象数据

### 2.1 介绍

在第一章我们集中关注计算过程, 以及函数对程序设计的作用与影响. 我们已经见识过如何使用原始数据(numbers)以及原始操作符(算术), 如何通过组合和控制来组成复合函数, 以及通过给计算过程赋予名称来创建函数抽抽象. 我们也看到高阶函数通过允许我们自行控制, 从而推理出一般计算方法来增强我们的语言的力量. 这就是编程的本质.

这一章主要关注数据. 我们在这里探讨的技术允许我们表达以及操作许多不同领域的信息. 由于因特网的爆炸性增长, 提供给我们大量在线且免费的结构化信息, 并且可以在大范围不同问题上进行计算. 有效使用內建的以及用户定义的数据类型是数据处理程序的根本. 

#### 2.1.1 基本数据类型

每一种数据在Python中都有一个类属, 这个类属决定了这个值是什么类型. 共享的数据同时具有共享的行为. 例如, 整数1以及2都是int类的实例. 这两个值能够进行类似的处理. 例如, 它们都可以被另外一个整数加或者减. 內建的type函数允许我们检查任何数值的类型.

```python
>>> type(2)
<class 'int'>
```

我们目前使用的数值知识少量Python语言的內建_本地_数据类型. 本地数据类型具有以下属性:

1. 有对原生类型的值进行定义的表达式, 叫做常量
2. 有对原生类型的值进行操作的內建函数以及操作符

int类是用来表示整数的原生数据类型. 整型常量(相邻数字序列)表达为int值, 以及数学运算符来操作这些值. 

```python
>>> 12 + 3000000000000000000000000
3000000000000000000000012
```

Python包含有三种本地数据类型: 整型(int), 实数(float), 以及复数(complex). 

```python
>>> type(1.5)
<class 'float'>
>>> type(1+1j)
<class 'complex'>
```

**Floats**: 名字float来源于Python以及许多其他的程序语言实数的表示方式是以: "浮点(floating point)"来表示的. 至于数字是如何表示的这些细节不在我们这一节的讨论范围之内, 而一些int以及float对象的高级差异需要重点了解. 尤其是, int对象能够准确地表示整数, 对其大小没有任何近似以及限制. 另一方面, float对象能够表示较宽范围内的分数, 但不是所有的数字都能够准确表示, 同时它们还具有最小值以及最大值. 因此, float数值应该被视为实际值的近似值来对待. 这些近似值只具有有限的精度. 合并浮点数会导致一些精度错误; 如果不用近似值的话下面的表达式计算后应该会等于7:

```python
>>> 7 / 3 * 3
7.0
>>> 1 / 3 * 7 * 3
6.999999999999999
```

虽然上面是int的组合, 用一个int除以另一个会得到一个float的值: 一个被截断了的近似值, 也就是两个整数相除的实际比率. 

```python
>>> type(1/3)
<class 'float'>
>>> 1/3
0.3333333333333333
```

当我们进行相等性测试的时候就会出现近似值的问题.

```python
>>> 1/3 == 0.333333333333333312345  # Beware of float approximation
True
```

这些int类型与float类型之间的微妙不同, 对程序的编写具有广泛的影响, 因此它们的细节程序员必须要铭记在心. 幸运的是, 只有少量的本地数据类型, 限制了精通编程语言所需要的记忆量. 此外, 这些相同的细节在许多编程语言中也是一致的. 由社区准则强制执行, 如: [IEEE 754 floating point standard][1]

**非数字类型**. 数值能够代表许多其他类型的数据, 例如声音, 图像, 地点, 网址, 网络连接等等. 少量是通过本地数据类型来表示的, 例如代表真(True)和假(False)的布尔(bool)类型. 大多数值的类型都需要程序员来使用本章中研究的组合和抽象手段来进行定义. 

接下来的部分将介绍更多Python的本地数据类型, 侧重于它们在创建有用的数据抽象中所起到的作用. 那些对于更加深入的细节感兴趣的人可以阅读一下深入Python3这本书的[本地数据类型][2]这一章,写出了所有Python的本地数据类型的实用概述以及如何对它们进行操作, 包括大量的用法例子以及练习提示.

### 2.2 数据抽象

当我们考虑世界上的广泛的事物的时候, 我们会想要将它在我们的程序中表现出来, 我们会发现它们大多数都具有复合结构. 例如, 一个地理位置有经度以及纬度坐标. 为了表示位置, 我们会想让我们的程序语言有能力将经度和纬度合在一起以形成一对, 作为一个我们的程序能够操作的一个单一的概念单元, 但是它也具有两个部分可以进行单独考虑.

使用复合数据能够让我们提升程序的模块性, 如果我们能够将地理位置作为一个整体来进行操作, 然后我们就可以对程序使用位置进行计算中是如何对这些地理位置进行表示的细节进行屏蔽. 一般的隔离程序各个部分的技术, 都是处理数据是如何被表示, 以及处理数据是如何被操作的强大的设计方法, 这方法称为数据抽象. 数据抽象让程序更容易被设计, 维护, 以及修改

数据抽象在性质上跟函数抽象那一章相似. 当我们创建一个函数抽象, 函数是如何实现的细节能够被压制, 以及特定的函数本身能够被任何其他的具有相同整体行为的函数进行替换. 换句话说, 我们可以实现一个抽象来将函数使用的方式与函数如何实现的细节上进行分离. 类似地, 数据抽象对复合数据的使用方式与如何构造的细节进行了隔离. 

数据抽象的基本思想是结构化程序, 以便于它们对抽象数据进行操作. 也就是说, 我们的程序应该以尽可能少的以对数据进行假设的方式来使用数据. 同时, 数据的具体表现应该定义为程序的一个独立的部分.

程序的这两个部分, 对数据抽象进行操作的部分以及定义具体表示的部分, 通过一组小的函数进行连接, 这些函数根据具体表示实现抽象数据. 为了说明这种技术, 我们需要考虑如何设计一套函数来操作有理数.

#### 2.2.1 例子: 有理数

一个有理数就是整数的比率, 有理数是构成实数的重要子类. 一个有理数如1/3或者17/29通常写作:

`<numerator>/<denominator>`

而`<numerator>`以及`<denominator>`都是整数的占位符. 这些部分都需要用来准确地表征有理数的值. 实际上整数相除得到一个浮点数的近似值, 失去了整数的精确度.

```python
>>> 1/3
0.3333333333333333
>>> 1/3 == 0.333333333333333300000  # Dividing integers yields an approximation
True
```

然而, 我们可以通过将分子和分母组合在一起来为有理数创建一个精确的表示. 

我们从使用函数的抽象中可以知道, 我们可以在程序的某些部分实现之前开始进行编程. 让我们假设我们已经有办法从一个分子以及一个分母中构造一个有理数开始. 我们还假设, 给定一个有理数, 我们有方法选定它的分子和分母的部分. 让我们进一步假设构造器以及选择器可具有一下的三个功能:

- **rational(n, d)**以分子为n分母为d的形式返回一个有理数
- **numer(x)**返回有理数中的分子x
- **denom(x)**返回有理数中的分母x

在这里我们使用程序设计中的强大策略: _祈愿思维_. 我们还没有讲述一个有理数是如何表示的, 或者函数number, denom, 以及rational应该怎么实现. 即使这样, 如果我们定义了这三个函数, 我们可以对有理数进行加, 乘, 打印, 以及测试相等性等操作:

```python
>>> def add_rationals(x, y):
        nx, dx = numer(x), denom(x)
        ny, dy = numer(y), denom(y)
        return rational(nx * dy + ny * dx, dx * dy)

>>> def mul_rationals(x, y):
        return rational(numer(x) * numer(y), denom(x) * denom(y))

>>> def print_rational(x):
        print(numer(x), '/', denom(x))

>>> def rationals_are_equal(x, y):
        return numer(x) * denom(y) == numer(y) * denom(x)
```

现在我们具有定义在选择器函数number以及denom和构造器函数rational之上的操作函数, 但是我们还没有定义这些选择器函数以及构造器函数. 我们需要一种方法来将分子和分母进行粘合, 形成一个复合值.

#### 2.2.2 结对

[1]: http://en.wikipedia.org/wiki/IEEE_floating_point
[2]: http://getpython3.com/diveintopython3/native-datatypes.html