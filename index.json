[{"content":"偶然的机会，需要使用 Windows 来进行开发，由于我平时主要使用 MacOS 与 Linux 开发，所以在 Windows 上进行开发的时候也必不可少地需要使用命令行。一开始是只使用系统的 CMD 来执行任务，但是 Windows 下的命令行与 Linux 下的有诸多不同，使用起来束手束脚，十分不方便，即使是安装了 Cygwin 或者 cmder，使用起来还是很别扭。\n总的来说，以上的两个工具日常开发是勉强够用的，毕竟就只是运行一下命令。但是，如果已经习惯 Linux 下顺畅的命令行使用体验，且想要在 Windows 上也能实现的话在以前来说需要付出的劳动可不小，还不能保证稳定。不过随着 Windows 推出的 Windows Subsystem for Linux 简称：WSL 功能后，你可以在 Windows 上将 Linux 作为一个应用一样打开使用，在 WSL 中使用命令行开发，必要的时候可以直接使用 Windows 提供的工具。这一刻，Windows 终于放下身段开始与 Linux 交融起来了。如此一来，以 Windows 作为日常开发的操作系统在我看来也不是不可以接受的了。\n引入 WSL 上面说到 WSL 有多么好，但再好，也只有在尝试后才能确定是否是自己的菜，具体的安装方法可以按照官方提供的操作：【官方】安装 WSL，喜欢尝鲜的可以看这里：【官方】安装 WSL 2，值得一提的是许多公司内部的网络对访问的站点进行了自定义的限制，会导致 Windows 的更新以及获取 WSL 安装包的过程受阻，如果遇到无法在应用商店里下载 WSL 运行包的情况的话可以参照：【官方】WSL 离线安装，下载下来的安装包甚至可以直接双击安装，也是很便捷的一种方式。\n安装完 WSL 后，通过呼出开始窗口，输入（假设安装的是 Ubuntu）：Ubuntu ，弹出的窗口里面运行的就是 Ubuntu 版的 WSL。\n到此，一个 Windows 下的 Linux 子系统就好了，基本上 Linux 支持的都可以在这个子系统里面做。但是，如果仅仅是要运行个子系统的话，直接用虚拟机 VMware 之类的早就可以做到。确实，如果只是要用一个 Linux 系统，虚拟机就可以包办。不过讲到融合，虚拟机暂时是追不上的。因为我主要做 Web 开发，下面就介绍我的一些开发配置作为参考，其他的大家可以按照需要发掘。\n配置环境 串联 Linux 与 Windows 在 WSL 启动后，除了可以使用常用的 Linux 命令，还有一个十分有用的特定需要用起来，那就是： 调用 Windows 命令 ，如何调用呢？直接输入命令名称。例如：\n1 2 3 4 5 6 7  # 在浏览文件夹的时候突然想要在 Windows 文件夹中查看或者预览 explore.exe ~/folder/you/want/to/open/ # 或者 explore.exe ~/file/you/want/to/open.txt # 当你需要复制文件中的文字时 cat ~/file/you/want.txt | clip.exe   上面的例子通过组合 Linux 以及 Windows 命令，整个开发体验直线上升。\n我个人并不是直接使用 Windows 的命令而是将它 alias 一下，如将 explore.exe 变为 wopen ，与 MacOS 以及 Linux 上的 open 命令对应起来。\n安装 Visual Studio Code Web 开发少不了使用这个热门编辑器，在 Windows 上安装完后，通常我比较习惯在浏览文件夹时直接用 code 命令来打开项目文件夹。一开始使用 WSL 的时候还以为不可以这样做了，很是苦恼了一阵子。后面偶然的机会了解到 WSL 以及 VSCode 的开发人员们已经处理好了这个问题，在 Windows 上安装完后直接在 WSL 上输入 code 指令就会触发安装需要的内容，完成后 VSCode 会打开，并需要安装插件支持，常用的开发插件也会要求你重装。安装的插件可以参考：【官方】在 WSL 上开发，这里的介绍比较完善，不过上面安装的插件应该换成是：Remote - WSL，可能是还没有更新到。\n至此，Web 所需要的基本开发环境就完成了。不过，开发环境这种东西是永远配置不完的，只要一天在开发，就会不断地完善；就像厨师的刀具，不断地磨砺，直到顺手。\n完善环境 在 Linux 之类的环境上开发的时候，我比较喜欢用 Zsh 结合 Oh My Zsh，不过安装完后，如果使用一些主题的话，需要面临字体不合适的问题。如果使用的主题需要的字体找不到的话此时打开的界面将会十分丑陋\n  想要解决这个问题可以遵照以下的步骤：\n 下载所需的字体，如：Nerd Font 遵照 Windows 的指南来将字体安装到系统中 VSCode 需要进行配置，在 config.json 中添加： \u0026quot;terminal.integrated.fontFamily\u0026quot;: \u0026quot;主题需要的字体名称\u0026quot;, 如果仅仅需要用 Shell 可以用 这个方法 来修复主题字体问题，不过，最好的方式是在 PowerShell 的菜单栏右键，选择「属性-字体」修改默认字体为所需字体，或者使用喜欢的第三方 Shell  以上就是完善的设置，如果使用的是 fish shell 的话可以参考这里。\n具体的开发过程中需要使用到的许多软件、工具就不在这里一一列出，实际开发的时候有需要再安装就可以。最后再推荐一下将键盘上的 CapsLock 键利用起来，这个键放在如此方便的位置却只是用作切换大小写实在是太浪费了。有兴趣的可以产考这篇文章来设置。改键工具的文档在这里\n结尾 上面就是这段时间使用 Windows 开发过程中总结下来的经验，期间自己的环境安装文件也出了许多问题，比如：pip 的重命名，pyenv 安装前依赖未确认等，都一并写在这里记录下来作为自己的过程资产吧。\n补充 这里补充一下使用过程中遇到的问题，方便日后索引。\nGit 配置 现今的开发工作基本离不开 Git 等版本管理库，使用 WSL 的过程中，由于公司内部禁止了 ssh 连接，使用 http 下载程序包时就需要输入对应内网的 Gitlab 平台账号密码。为了减少输入密码等工作，在翻找了资料之后找到了解决办法：信任凭证存储，通过存储凭证，能够在输入一次账号密码后即免除后续的重复输入，凭证的设置分为几个等级以及不同平台的处理，对于 WSL，如果无需与 Windows 系统共享的话，可以直接使用 store 选项，存储在文件中，否则则需要安装 Windows 平台对应需要的支持软件。\n对应地，安装了 Windows 软件后，WSL 内的 helper 配置路径就需要设置为 Windows 下的位置，形如： git config --global credential.helper \u0026quot;/mnt/c/Program\\ Files/Git/mingw64/libexec/git-core/git-credential-manager.exe \u0026quot; ，具体可参考这篇文章。\n","description":"","id":0,"section":"posts","tags":null,"title":"WSL，Windows 与 Linux 的丝滑融合","uri":"https://jmwill.github.io/blog/2020/05/17/wslwindows-%E4%B8%8E-linux-%E7%9A%84%E4%B8%9D%E6%BB%91%E8%9E%8D%E5%90%88/"},{"content":"前端程序员。了解与掌握的技术栈有：\n HTML、CSS、JavaScript 前端三板斧 React、Vue、jQuery 等工具库 Webpack、Gulp 等前端工程相关工具使用 Node.js、Python、Shell 等脚本语言编写等 \u0026hellip;  工作经历：\n 爱范儿 | 软件工程师 | 广州 多益网络 | 前端工程师 | 广州  爱好：\n打篮球、读书、听音乐、看电影等等。\n","description":"JMwill's about page","id":1,"section":"","tags":null,"title":"About","uri":"https://jmwill.github.io/blog/about/"},{"content":"到今天为止，已经辞职一年了。在这一年的时间里面，只做了一件事情，虽然最后的结果不是自己想要的，但也算是了了心愿。借着博客的迁移，再次重新出发，努力追赶上一年时间里面落下的东西，巩固已有的能力，顺便在这里记录一下迁移过程。\n为何选用 Hugo？ 我的这个博客已经很久没有更新了，有很多理由可以说，但归根到底是觉得没有可以写的东西。以前每看一本书，或者了解到有新的技术时会做一些笔记，但不会把它写到博客上，然后时间久了之后就忘了这个博客的存在了。最近一年的时间里所做的事情告一段落之后，主动了解一下程序员常用的编辑器： Emacs ，随后又了解到备受赞誉的： Org-mode 。使用 Emacs 的人几乎没有不使用 Org 的，甚至有些是因为 Org 才转用 Emacs 编辑器的。\n因为 Org 的功能强大，在尝试使用后我就决定以后常用 Emacs 以及 Org ，有了这个想法而且在网络上浏览文章时碰到 Hugo 这个静态博客构建系统，就想起来我自己也有一个博客，故此就顺着这个机会把博客迁移到 Hugo 来构建，结合 ox-hugo 来学习并体验 Org 的强大功能。\n迁移 整体迁移过程就比较简单，先把就博客包含的内容都转移到备份的文件夹\n1 2  mv * ../backup hugo new site .   新建完成后将原有的 Git 相关配置文件从 backup 中放回到项目下，因为旧博客使用的 Hexo 来构建，为了保证以前的文章路径不被破坏，或者如果你更喜欢 Hexo 类型的路径形式的话，需要在 config.toml 文件中加入配置：\n1 2 3 4 5 6  [permalinks] posts = \u0026#34;/:year/:month/:day/:slug/\u0026#34; # 这里的 frontmatter 添加也可以，不添加也可以，只是修改 date 的默认行为改为从文件名处先获取 [frontmatter] date = [\u0026#34;:filename\u0026#34;, \u0026#34;:default\u0026#34;]   旧文章迁移过去时有些不兼容的地方需要修改，例如日期格式从 YYYY-MM-DD HH:MM 改为 YYYY-MM-DDTHH:MM:SS+08:00 这种带时区的时间格式，具体可以参考：\n《把博客生成工具从 Hexo 迁移到 Hugo — 配置与设置》1\n迁移过后，根据 Hugo 的新手入门测试一下效果，没问题就可以去主题站点选择一个喜爱的主题来替换，或者可以自己编写。\n自动化 迁移到 Hugo 并不复杂，完成对应配置后，需要修改一下构建的设置文件，原来是使用 Travis CI 来自动构建，本次迁移当然少不了修改配置。\n1 2 3 4 5 6 7 8  language:gogo:- masterdist:xenialaddons:snaps:- hugo  将之前的语言从 Node.js 换为 Go，构建的系统默认是 Linux，因此指定一下为 xenial 发行版。最后指定用 snaps 来安装 Hugo。snaps 上的 Hugo 版本基本与最新版保持同步。避免使用 apt-get 等方式来手动安装，原因是 Travis CI 上的默认 Linux 上的 apt-get 安装的都是旧版 Hugo，没法正确构建，而网上很多在 Travis CI 上安装 Hugo 的方式都是自己从 Github 上拉 *.deb 来安装，个人觉得这种方式更为繁琐且需要复杂的正则来匹配提取准确路径，容易出错。\n1 2 3 4 5 6  before_script:- rm-rfpublic2\u0026gt;/dev/nullscript:- hugoversion- hugo  之后就是在真正重新构建之前将以前构建出来的静态资源文件夹删除掉，然后再执行构建。\n余下的推送到 Github 上的命令则无需更改，因为两者都是用 public 作为静态资源构建的目标文件夹。没有弄过 Travis CI 的可以参考我的配置2\n结尾 博客的迁移工作基本流程就是这样，后续还需要在 Emacs 上安装 ox-hugo，编写一些 org capture template，加上截图函数，添加评论系统到博客等工作，这些就慢慢来吧。\n https://jdhao.github.io/2018/10/10/hexo_to_hugo/ \u0026#x21a9;\u0026#xfe0e;\n https://github.com/JMwill/blog/blob/master/.travis.yml \u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":2,"section":"posts","tags":null,"title":"始于 2020 的 Hugo 迁移","uri":"https://jmwill.github.io/blog/2020/04/19/%E5%A7%8B%E4%BA%8E-2020-%E7%9A%84-hugo-%E8%BF%81%E7%A7%BB/"},{"content":"第四章: 数据处理 4.1 介绍 现代计算机可以处理大量表示世界许多方面的数据. 从这些大数据集合, 我们可以以前所未有的方式学习到人类的相关行为: 语言是如何使用的, 拍摄什么照片, 讨论什么话题, 以及人们是如何跟他们周围的环境来接触的. 为了高效地处理大数据集合, 程序被组织成对有序的数据流进行操作的管道. 在本章, 我们会考虑一套的技术来处理并操纵有序数据流.\n在第二章, 我们会引入序列接口, 通过内置的数据类型(如列表和范围)来在Python中实现. 在这章中, 我们将会拓展序列数据的概念, 包括不具边界甚至是无限大小的集合. 两个数学上的无限序列例子是正整数以及斐波那契数列. 具有无限长度的序列数据集合也出现在其他计算领域. 例如, 通过电话塔发送的电话序列, 由计算机用户进行的鼠标移动的序列, 以及飞机上传感器的加速度测量序列随着世界的发展而无限延伸.\n4.2 隐含序列 一个序列可以无需对每个元素进行明确存储在计算机的存储器中而表示出来. 也就是说, 我们可以构造一个对象来提供访问某些顺序数据集的所有元素而不用提前计算所有这些元素并保存它们. 相反, 我们按需来计算元素.\n这个想法的一个简单的例子出现在第二章介绍的range序列类型中. 一个range表示一个连续, 有界的整数序列. 然而, 序列的每个元素在这个情况下并不是明确存在于内存中的. 相反, 当range中的元素被请求时, 它会计算出这个元素. 因此, 我们可以表示非常大的整数而不用大块的内存. 只有range的终结点存储为range对象的一部分.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; r = range(10000, 1000000000) \u0026gt;\u0026gt;\u0026gt; r = [45006230] 45006230   在这个例子中, 不是所有在999,990,000这个范围的整数在创建的时候都会被存储. 相反, 范围对象添加第一个元素10,000一直到到下标45,006,230来产出元素45,016,230. 一旦请求就会计算值而不是从一个已存在的表示来检索它们, 这是一个懒计算的例子. 在计算机科学, 懒计算描述任何延迟计算的程序, 直到需要该值为止.\n一个迭代器是一个对象, 它提供对底层顺序数据集的顺序访问. 迭代器在很多程序中是内建对象, 包括Python. 迭代器的抽象具有两个部分, 一个在一个底层元素中检索下一个元素的机制以及一个发出已经到达序列的终点并没有更多元素的信号机制. 在具有内建对象系统的编程语言中, 这个抽象通常来说对应到特定的可以通过类来实现的接口. Python提供的迭代器接口描述会在下一节中描述.\n迭代器的有用性源于一个事实即: 迭代器的底层数据序列可能不会在存储器中明确表示. 迭代器提供了一个机制来顺序考量一系列数据的值, 但同时所有的元素不需要存储在内存中. 相反, 当下一个元素被迭代器请求, 元素可以根据需要计算而不是从现有内存源中检索.\n范围类可以对一个列表的元素进行懒计算因为所表示的序列是均匀的, 同时任何元素都容易从range的开始和结束的边界计算. 迭代器允许懒生成更广泛类型的底层顺序数据集, 因为它们不需要提供对任意元素的底层序列的访问. 相反, 迭代器只需要在每次请求一个元素时按顺序去计算该序列中的下一个元素. 虽然不像访问序列的任意元素一样灵活(称为随机访问), 顺序访问顺序数据序列通常来说足以用于数据处理应用.\n4.2.1 Python迭代器 Python的迭代器接口是用一个叫做__next__的方法来定义的, 它会返回它所代表的一些底层序列数据的下一个元素. 响应调用__next__方法, 迭代器可以执行任意计算以便检索或者计算出下一个元素. 调用__next__会为迭代器带来突变型的改变: 它推进了迭代器的位置. 因此, 多次调用__next__会返回一个底层序列的序列元素. Python在调用__next__期间通过发出StopInteration异常的形式来表示一个底层序列已经到达尽头.\n下面的LetterIter类迭代一个以某些字母开头的而不包括某些字母结束的底层序列. 实例属性next_letter保存下一个字母用来返回. __next__方法返回这个字母并使用它来计算新的next_letter.\n1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; class LetterIter: \u0026#34;\u0026#34;\u0026#34;An iterator over letters of the alphabet in ASCII order.\u0026#34;\u0026#34;\u0026#34; def __init__(self, start=\u0026#39;a\u0026#39;, end=\u0026#39;e\u0026#39;): self.next_letter = start self.end = end def __next__(self): if self.next_letter == self.end: raise StopIteration letter = self.next_letter self.next_letter = chr(ord(letter)+1) return letter   使用这个类, 我们可以顺序地访问字母通过__next__方法或者内建的next函数, 这个函数会调用传入的参数上的__next__方法.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026gt;\u0026gt;\u0026gt; letter_iter = LetterIter() \u0026gt;\u0026gt;\u0026gt; letter_iter.__next__() \u0026#39;a\u0026#39; \u0026gt;\u0026gt;\u0026gt; letter_iter.__next__() \u0026#39;b\u0026#39; \u0026gt;\u0026gt;\u0026gt; next(letter_iter) \u0026#39;c\u0026#39; \u0026gt;\u0026gt;\u0026gt; letter_iter.__next__() \u0026#39;d\u0026#39; \u0026gt;\u0026gt;\u0026gt; letter_iter.__next__() Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 12, in next StopIteration   迭代器是可变的, 当它们演变事, 它们会跟踪某些底层序列值的位置. 当到达最后的值时, 迭代器就用完了. 一个LetterIter实例只可以被迭代一次. 在它的__next__()方法抛出StopIteration异常之后, 从这时起这个迭代器就会一直这样做. 通常, 一个迭代器是不可以重置的; 而是创建一个新实例来开始一个新的迭代.\n迭代器也允许我们通过实现一个永远不会抛出StopIteration异常的__next__方法来表示一个无限序列. 例如, 下面的Positives类用来迭代无限的正整数序列. 在Python中内建的next方法会调用它参数上的__next__方法.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026gt;\u0026gt;\u0026gt; class Positives: def __init__(self): self.next_positive = 1; def __next__(self): result = self.next_positive self.next_positive += 1 return result \u0026gt;\u0026gt;\u0026gt; p = Positives() \u0026gt;\u0026gt;\u0026gt; next(p) 1 \u0026gt;\u0026gt;\u0026gt; next(p) 2 \u0026gt;\u0026gt;\u0026gt; next(p) 3   4.2.2 可迭代对象 如果一个对象在调用它的__iter__方法时返回一个迭代器那么这个对象是可迭代的. 可迭代值代表数据集, 并且它们提供可能产生多于一个迭代器的固定表示.\n例如, 下面的Letters类的实例表示一个连续的字母序列. 每一次它的__iter__方法被调用, 一个新的LetterIter实例就被构造, 它允许顺序访问到序列的内容.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; class Letters: def __init__(self, start=\u0026#39;a\u0026#39;, end=\u0026#39;e\u0026#39;): self.start = start self.end = end def __iter__(self): return LetterIter(self.start, self.end)   内建的iter函数调用传入的参数上的__iter__方法. 在下面的序列表达式中, 两个迭代器衍生自相同的可迭代的序列并独立地返回序列中的字母.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026gt;\u0026gt;\u0026gt; b_to_k = Letters(\u0026#39;b\u0026#39;, \u0026#39;k\u0026#39;) \u0026gt;\u0026gt;\u0026gt; first_iterator = b_to_k.__iter__() \u0026gt;\u0026gt;\u0026gt; next(first_iterator) \u0026#39;b\u0026#39; \u0026gt;\u0026gt;\u0026gt; next(first_iterator) \u0026#39;c\u0026#39; \u0026gt;\u0026gt;\u0026gt; second_iterator = iter(b_to_k) \u0026gt;\u0026gt;\u0026gt; second_iterator.__next__() \u0026#39;b\u0026#39; \u0026gt;\u0026gt;\u0026gt; first_iterator.__next__() \u0026#39;d\u0026#39; \u0026gt;\u0026gt;\u0026gt; first_iterator.__next__() \u0026#39;e\u0026#39; \u0026gt;\u0026gt;\u0026gt; second_iterator.__next__() \u0026#39;c\u0026#39; \u0026gt;\u0026gt;\u0026gt; second_iterator.__next__() \u0026#39;d\u0026#39;   可迭代的Letters实例b_to_k以及LetterIter的迭代器实例first_iterator以及second_iterator与Letters实例的不同之处在于Letter实例不会更改, 而迭代器实例会随着每一次next调用(或者等效的__next__调用)之后改变. 迭代器通过顺序数据跟踪进度, 而可迭代表示数据本身.\n在Python中的很多内建函数接受可迭代参数并返回一个迭代器. 例如, map函数, 接受一个函数以及一个可迭代的值. 它返回对可迭代参数的每个元素应用到传入函数后的返回结果组成的一个迭代器.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; caps = map(lambda x: x.upper(), b_to_k) \u0026gt;\u0026gt;\u0026gt; next(caps) \u0026#39;B\u0026#39; \u0026gt;\u0026gt;\u0026gt; next(caps) \u0026#39;C\u0026#39;   map函数是惰性函数, 调用它时并不会执行计算其元素结果所需的计算. 相反, 一个迭代器对象被创建后, 如果使用next函数查询则可以返回结果. 我们可以在下面的例子中观察到这个事实, 打印的操作被延迟到了对应元素被doubled迭代器请求才操作.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026gt;\u0026gt;\u0026gt; def double_and_print(x): print(\u0026#39;***\u0026#39;, x, \u0026#39;=\u0026gt;\u0026#39;, 2*x, \u0026#39;***\u0026#39;) return 2*x \u0026gt;\u0026gt;\u0026gt; s = range(3, 7) \u0026gt;\u0026gt;\u0026gt; doubled = map(double_and_print, s) # double_and_print not yet called \u0026gt;\u0026gt;\u0026gt; next(doubled) # double_and_print called once *** 3 =\u0026gt; 6 *** 6 \u0026gt;\u0026gt;\u0026gt; next(doubled) # double_and_print called again *** 4 =\u0026gt; 8 *** 8 \u0026gt;\u0026gt;\u0026gt; list(doubled) # double_and_print called twice more *** 5 =\u0026gt; 10 *** *** 6 =\u0026gt; 12 *** [10, 12]   filter, zip以及reversed函数也是返回迭代器的.\n4.2.3 声明 在Python中的for声明用于操作迭代器. 对象如果具有一个__iter__方法, 返回一个迭代器, 那么它是可以迭代的(一个接口). 可迭代对象可以是for声明头部的\u0026lt;expression\u0026gt;中的值:\n1 2  for \u0026lt;name\u0026gt; in \u0026lt;expression\u0026gt;: \u0026lt;suite\u0026gt;   为了执行for声明, Python执行头部\u0026lt;expression\u0026gt;, 这个expression必须返回一个迭代器值. 然后, 在该至上调用__iter__方法. 直到StopIteration异常被抛出, Python反复调用在这个迭代器上的__next__方法以及绑定结果到\u0026lt;name\u0026gt;在for声明中. 然后, 它执行\u0026lt;suite\u0026gt;.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; counts = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; for item in counts: print(item) 1 2 3   在上面的例子中, counts列表从它的__iter__()方法中返回一个迭代器. for声明之后不断地调用这个迭代器的__next__()方法, 同时每次都将返回值分配到item上. 这个过程一直持续直到迭代器抛出StopIteration异常, for声明在这个点上结束执行.\n随着我们对迭代器的了解, 我们可以以while, 赋值, 以及try声明, 实现执行for的规则.\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; items = counts.__iter__() \u0026gt;\u0026gt;\u0026gt; try: while True: item = items.__next__() print(item) except StopIteration: pass 1 2 3   上面, 通过调用counts迭代器的__iter__方法并将返回的值绑定到名称items上, 这样就可以依次查询每个元素. 处理StopIteration异常的处理机制什么都不会做, 但是这个处理机制提供了一个控制机制来跳出while循环.\n在for循环中使用一个迭代器, 这个迭代器也必须具有一个__iter__方法. Python文档中的Iterator类型章节建议一个迭代器具有一个__iter__方法, 这个方法返回迭代器本身, 因此所有的迭代器都是可迭代的.\n4.2.4 生成器以及yield声明 上面的Letters以及Positives对象需要我们去引入一个新的域self.current到我们的对象来跟踪序列进度. 使用如上面展现的这样简单的序列, 可以很容易完成. 然而对于复杂的序列, __next__方法就很难在计算中保持它的位置. 生成器允许我们利用Python解析器的功能去定义更复杂的迭代.\n生成器就是通过一个特殊类型的函数返回一个迭代器对象的函数. 生成器函数有别于常规的函数的地方在于它们的函数体内不是包含return声明, 它们使用yield声明来返回序列的元素.\n生成器并不使用对象的属性来追踪序列的步进过程. 相反, 它们控制生成器函数的执行过程, 每一次生成器的__next__方法被调用就会一直执行直到下一个yield声明被执行才停止. Letters迭代器可以使用生成器函数来实现得更加紧凑.\n1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; def letters_generator(): current = \u0026#39;a\u0026#39; while current \u0026lt;= \u0026#39;d\u0026#39;: yield current current = chr(ord(current)+1) \u0026gt;\u0026gt;\u0026gt; for letter in letters_generator(): print(letter) a b c d   即使我们从来没有明确地定义__iter__或者__next__方法, yield声明指出我们正在声明一个生成器函数. 当函数被调用时, 生成器函数不是返回一个特定的产生的值, 而是一个生成器(它的类型是一个迭代器)它本身可以返回产生的值. 生成器对象具有__iter__以及__next__方法, 同时每一次调用__next__会继续从上一次生成器函数离开的地方继续执行生成器函数直到另一个yield声明被执行.\n第一次调用__next__, 程序会执行来自letters_generator函数主体的语句, 直到它遇到yield声明. 然后, 它暂停并返回值给current. yield声明并不会销毁最新创建的环境, 它们将保留下来. 当__next__再次被调用, 执行过程恢复到它停止的地方, current的结果以及其他在这个letters_generator域之中绑定了的名称都会保留直到随后的__next__调用.\n我们可以通过手动调用__next__()来遍历生成器:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026gt;\u0026gt;\u0026gt; letters = letters_generator() \u0026gt;\u0026gt;\u0026gt; type(letters) \u0026lt;class \u0026#39;generator\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; letters.__next__() \u0026#39;a\u0026#39; \u0026gt;\u0026gt;\u0026gt; letters.__next__() \u0026#39;b\u0026#39; \u0026gt;\u0026gt;\u0026gt; letters.__next__() \u0026#39;c\u0026#39; \u0026gt;\u0026gt;\u0026gt; letters.__next__() \u0026#39;d\u0026#39; \u0026gt;\u0026gt;\u0026gt; letters.__next__() Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; StopIteration   生成器不会开始执行其生成函数的任何body语句, 直到__next__第一次被调用. 当生成器结束时会抛出StopIteration异常.\n4.2.5 创建带有yield的可迭代对象 在Python, 迭代器只能单向通过底层迭代序列的元素. 在这之后, 迭代器在__next__再次被调用时会继续抛出StopIteration异常. 很多程序需要重复元素多次. 例如, 我们要迭代列表多次来枚举所有元素对.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; def all_pairs(s): for item1 in s: for item2 in s: yield (item1, item2) \u0026gt;\u0026gt;\u0026gt; list(all_pairs([1, 2, 3])) [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]   序列本身并不是迭代器, 而是可迭代对象. 在Python中的可迭代接口由单个消息组成, __iter__, 它返回一个迭代器. 在Python中的内建序列类型在它们的__iter__方法被调用时返回新的迭代器的实例. 如果一个可迭代对象每次__iter__方法被调用时就返回一个新的实例, 那么它就可以迭代多次.\n新的可迭代类可以通过实现可迭代接口来定义. 例如, 下面的_可迭代_LettersWithYield类每次在__iter__被调用时返回一个新的建立在字母上的迭代器.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; class LettersWithYield: def __init__(self, start=\u0026#39;a\u0026#39;, end=\u0026#39;e\u0026#39;): self.start = start self.end = end def __iter__(self): next_letter = self.start while next_letter \u0026lt; self.end: yield next_letter next_letter = chr(ord(next_letter) + 1)   __iter__方法是一个生成器函数; 它返回一个生成器对象这个生成器对象返回字母a到d然后就停止. 每次我们调用这个方法, 一个新的生成器会开始迭代一个新的序列数据.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; letters = LettersWithYield() \u0026gt;\u0026gt;\u0026gt; list(all_pairs(letters))[:5] [(\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;), (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;), (\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;), (\u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;), (\u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;)]   4.2.6 流 流通常是隐含地表示序列数据的另一种方式. 流是一个懒计算的链接列表. 跟第二章的Link类类似, Stream实例响应请求它的第一个元素以及流剩下的元素. 跟Link类类似, Stream剩下的部分也是Stream. 跟Link不相似的是一个流剩下的部分只在它被查询的时候才计算, 而不是提前存储起来. 也就是说, 流剩下来的部分是懒计算的.\n要实现这个懒运算, 流需要保存一个函数, 这个函数计算流剩下的部分. 无论何时函数被调用, 它返回的值会作为流的一部分被存储到一个叫做_rest的属性上, 以下划线来命名是为了标识它不应该被直接访问.\n可访问的属性rest是一个属性方法, 它返回流剩下的部分, 在必要时进行计算. 有了这个设计, 流存储了如何计算流的剩余部分, 而不用总是明确地保存剩余的部分.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026gt;\u0026gt;\u0026gt; class Stream: \u0026#34;\u0026#34;\u0026#34;A lazily computed linked list.\u0026#34;\u0026#34;\u0026#34; class empty: def __repr__(self): return \u0026#39;Stream.empty\u0026#39; empty = empty() def __init__(self, first, compute_rest=lambda: empty): assert callable(compute_rest), \u0026#39;compute_rest must be callable.\u0026#39; self.first = first self._compute_rest = compute_rest @property def rest(self): \u0026#34;\u0026#34;\u0026#34;Return the rest of the stream, computing it if necessary.\u0026#34;\u0026#34;\u0026#34; if self._compute_rest is not None: self._rest = self._compute_rest() self._compute_rest = None return self._rest def __repr__(self): return \u0026#39;Stream({0}, \u0026lt;...\u0026gt;)\u0026#39;.format(repr(self.first))   链表是通过嵌套表达式来定义的. 例如, 我们可以创建一个下面的表示具有元素1, 然后是元素5的Link:\n1  \u0026gt;\u0026gt;\u0026gt; r = Link(1, Link(2 + 3, Link(9)))   同样地, 我们可以创建一个Stream表示相同的序列, Stream实际上并不计算第二个元素5, 直到剩余的stream被请求, 我们可以通过创建匿名函数来达到这个效果.\n1  \u0026gt;\u0026gt;\u0026gt; s = Stream(1, lambda: Stream(2 + 3, lambda: Stream(9)))   这里, 1是流的第一个元素, 然后接下来的lambda表达式返回一个函数来计算剩余的流.\n访问链表r的元素跟流s的元素的过程是相似的. 然而, 5已经存在r里面, 而s是在第一次被请求的时候按需求来进行加法计算的.\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; r.first 1 \u0026gt;\u0026gt;\u0026gt; s.first 1 \u0026gt;\u0026gt;\u0026gt; r.rest.first 5 \u0026gt;\u0026gt;\u0026gt; s.rest.first 5 \u0026gt;\u0026gt;\u0026gt; r.rest Link(5, Link(9)) \u0026gt;\u0026gt;\u0026gt; s.rest Stream(5, \u0026lt;...\u0026gt;)   而r的rest是一个具有两个元素的链表, 而s的rest则包括一个用于计算剩余部分的函数; 而它将会返回一个空的流的事实可能尚未被发现.\n当一个Stream实例构建后, self._rest区域是None, 表示剩余的Stream部分尚未被计算. 当rest属性被通过点表达式请求, rest属性方法被调用就会触发self._rest = self._compute_rest()执行运算. 因为Stream的缓存机制, compute_rest函数只会调用一次, 然后会被丢弃.\ncompute_rest函数的基本属性是它不需要参数, 同时它返回一个Stream或者Stream.empty.\n懒惰执行让我们有能力去用流来表示一个无限序列数据集. 例如, 我们可以表示增长的整数, 以任何first值开始.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; def integer_stream(first): def compute_rest(): return integer_stream(first+1) return Stream(first, compute_rest) \u0026gt;\u0026gt;\u0026gt; positives = integer_stream(1) \u0026gt;\u0026gt;\u0026gt; positives Stream(1, \u0026lt;...\u0026gt;) \u0026gt;\u0026gt;\u0026gt; positives.first 1   当integer_stream第一次被调用, 它返回一个流, 这个流的first是在序列中的第一个整数. 然而, integer_stream实际上是递归的, 因为这个流的compute_rest会再次以一个增长了的参数来调用integer_stream. 我们说integer_stream是懒惰的是因为递归调用integer_stream只会在剩下整数流被请求的时候才会调用.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; positives.first 1 \u0026gt;\u0026gt;\u0026gt; positives.rest.first 2 \u0026gt;\u0026gt;\u0026gt; positives.rest.rest Stream(3, \u0026lt;...\u0026gt;)   同样用来处理序列的高阶函数 \u0026ndash;map以及filter\u0026ndash; 同样也可以应用到流上去, 即使它们的实现必须要改成惰性地应用它们的参数函数. 函数map_stream映射函数到整个流上, 这会产生一个新的流. 内部定义的compute_rest函数确保在剩下的流被计算时函数会被映射到剩余的流中去.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; def map_stream(fn, s): if s is Stream.empty: return s def compute_rest(): return map_stream(fn, s.rest) return Stream(fn(s.first), compute_rest)   流可以通过定义\t一个compute_rest函数来应用过滤函数到剩余的流中来进行过滤. 如果过滤函数拒绝流的第一个元素, 剩下来的会马上被计算. 因为filter_stream是递归的, 剩下的流可能会被计算数次, 直到第一个有效的值被找到.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; def filter_stream(fn, s): if s is Stream.empty: return s def compute_rest(): return filter_stream(fn, s.rest) if fn(s.first): return Stream(s.first, compute_rest) else: return compute_rest()   map_stream以及filter_stream函数展示了流处理的共同模式: 本地定义compute_rest函数每当在需要计算剩余部分的时候递归地应用过程函数到流剩余的部分中.\n为了检查流里面的内容, 我们可以将第一个元素强制转为Python中的list类型.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; def first_k_as_list(s, k): first_k = [] while s is not Stream.empty and k \u0026gt; 0: first_k.append(s.first) s, k = s.rest, k-1 return first_k   这些便利函数允许我们去校验我们的map_stream实现, 一个简单的例子就是将从3到7的整数进行平方.\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; s = integer_stream(3) \u0026gt;\u0026gt;\u0026gt; s Stream(3, \u0026lt;...\u0026gt;) \u0026gt;\u0026gt;\u0026gt; m = map_stream(lambda x: x*x, s) \u0026gt;\u0026gt;\u0026gt; m Stream(9, \u0026lt;...\u0026gt;) \u0026gt;\u0026gt;\u0026gt; first_k_as_list(m, 5) [9, 16, 25, 36, 49]   我们可以使用我们的filter_stream函数通过使用Eratosthenes的筛子来定义一个素数流, 它过滤整数流来移除所有是第一个元素的倍数的所有数字. 通过连续过滤每个素数，从流中删除所有复合数。\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; def primes(pos_stream): def not_divible(x): return x % pos_stream.first != 0 def compute_rest(): return primes(filter_stream(not_divible, pos_stream.rest)) return Stream(pos_stream.first, compute_rest)   通过截断primes流, 我们可以列举任何素数的前缀\n1 2 3  \u0026gt;\u0026gt;\u0026gt; prime_numbers = primes(integer_stream(2)) \u0026gt;\u0026gt;\u0026gt; first_k_as_list(prime_numbers, 7) [2, 3, 5, 7, 11, 13, 17]   流与迭代器不同的是它们可以被传递给纯函数多次并且每次都返回相同的结果. 素数流通过将其转换成列表时并没有被\u0026quot;用完\u0026rdquo;. 也就是说, prime_numbers第一个元素在转换流的前缀为列表之后依旧是2.\n1 2  \u0026gt;\u0026gt;\u0026gt; prime_numbers.first 2   就像链表提供简单的序列抽象实现一样, 流通过使用高阶函数实现懒惰计算从而提供简单, 功能强大的递归式数据结构.\n4.3 声明式编程 除了流以外, 数据值通常也保存在大型的库中, 这个库称为数据库. 数据库由包含数据值的数据存储以及用于检索和转换这些值的接口. 每个存储在数据库中的值都被称为_记录_. 记录具有相似的结构且被分组成表. 记录使用查询(这是一种查询语言)来进行检索和转换. 到目前为止, 这是使用最广泛的查询语言被称为结构化查询语言或者SQL(读作 \u0026ldquo;sequel\u0026rdquo;).\nSQL是声明式编程语言的一个例子. 声明并不直接描述计算, 而是描述期望的某些计算结果. 这是数据库系统查询解析器的作用是设计并执行计算过程来产出这样的结果.\n这种交互与Python或Scheme这样的程序编程范例有很大的不同. 在Python, 计算过程是由程序员来直接指定的, 而声明式语言抽象程序细节, 而不是关注结果的形式.\n4.3 表 SQL语言是标准化的, 但是大多数数据库系统会实现一些语言的自定义变体, 其带有某些专有功能. 在本文中, 我们会描述SQL的一个小的集合它被实现在Sqlite中. 你可以通过下载Sqlite或者使用在线的SQL解析器.\n表, 也称为关联, 具有固定数量的命名和类型列, 表的每一行表示一个数据记录且每列都具有一个值. 例如, 一个城市的表可能会具有的列有latitude, longitude两者所持有的都是数值型的值, 还有一列为name所持有的值为字符串. 每一行通过它的纬度以及经度值来表示一个城市的坐标位置.\n   Latitude Longitude Name     38 122 Berkeley   42 71 Cambridge   45 93 Minneapolis    可以通过SQL语言中的select声明来创建一个表中的单个行, 行中值是被逗号给分隔开的, 后接一个关键词\u0026quot;as\u0026quot;以及紧随的每列的名称. 所有的SQL声明都以分号作为结尾.\n1 2  sqlite\u0026gt; select 38 as latitude, 122 as longitude, \u0026#34;Berkeley\u0026#34; as name; 38|122|Berkeley   第二行是输出, 每一条包含由竖线分隔开的列来组成.\n多行表格可以通过_union_来构造, 这用来组合两个表的行. 左边的表格的列名在构建的表中使用. 而间隔在一行之内并不影响结果.\n1 2 3 4 5 6  sqlite\u0026gt; select 38 as latitude, 122 as longitude, \u0026#34;Berkeley\u0026#34; as name union ...\u0026gt; select 42, 71, \u0026#34;Cambridge\u0026#34; union ...\u0026gt; select 45, 93, \u0026#34;Minneapolis\u0026#34;; 38|122|Berkeley 42|71|Cambridge 45|93|Minneapolis   表格可以用create table声明来给定一个名称. 而这个声明也可以用来创建空表, 我们将会关注给定名称给一个已经通过select声明定义的存在的表格这种形式.\n1 2 3 4  sqlite\u0026gt; create table cities as ...\u0026gt; select 38 as latitude, 122 as longitude, \u0026#34;Berkeley\u0026#34; as name union ...\u0026gt; select 42, 71, \u0026#34;Cambridge\u0026#34; union ...\u0026gt; select 45, 93, \u0026#34;Minneapolis\u0026#34;;   一旦一个表格被命名了, 这个名称可以用在select声明的from子句中. 表格中的所有列可以使用特殊形式的select *来展示.\n1 2 3 4  sqlite\u0026gt; select * from cities; 38|122|Berkeley 42|71|Cambridge 45|93|Minneapolis   4.3.2 Select声明 select声明定义一个新的表, 通过列出值在单一的一行或者更一般地通过from子句投影已经存在的表:\nselect [column description] from [existing table name]\n结果表中的列通过一个以逗号分隔的表达式列表来描述, 对现有输入表的每一行执行运算.\n例如, 我们可以创建两列的表, 这个表描述了每个城市距离伯克利的北部或者南部有多远. 每个纬度的每一度表示距离北方60海里.\n1 2 3 4  sqlite\u0026gt; select name, 60*abs(latitude-38) from cities; Berkeley|0 Cambridge|240 Minneapolis|420   列描述在语言中是一个表达式它分享了Python中的许多特性, 添加操作符如+以及%, 内建函数如abs以及round, 以及括号用来描述运算的顺序. 在这些表达式中的名称, 例如上面的latitude, 执行后得到列的值来形成数据行.\n可选地, 每个表达式可以后接关键字as以及一个列的名称. 当整个表格被赋予一个名称时, 通常给每个列一个名称是很有用的, 这方便将来在select语句中被引用. 由简单名称描述的列将会自动命名.\n1 2 3 4 5 6  sqlite\u0026gt; create table distances as ...\u0026gt; select name, 60*abs(latitude-38) as distance from cities; sqlite\u0026gt; select distance/5, name from distances; 0|Berkeley 48|Cambridge 84|Minneapolis   Where子句, select声明也可以包含具有过滤表达式的where子句. 这表达式过滤映射的行. 只有经过滤表达式运算后得到的值为真的行才会被用于在结果表中生成一行记录.\n1 2 3 4  sqlite\u0026gt; create table cold as ...\u0026gt; select name from cities where latitude \u0026gt; 43; sqlite\u0026gt; select name, \u0026#34;is cold!\u0026#34; from cold; Minneapolis|is cold!   Order子句. select声明也可以对结果表进行排序. order子句包含一个排序表达式, 这表达式对每个未经过滤的行执行运算. 这个表达式的结果值用作结果表的排序标准.\n1 2 3 4  sqlite\u0026gt; select distance, name from distances order by -distance; 84|Minneapolis 48|Cambridge 0|Berkeley   这些特性的组合允许select语句将输入表的各种映射表达到相关的输出表中.\n4.3.3 连接 通常来说, 数据库会包含多个表同时查询可以要求包含在不同的表中的信息来计算出期望的结果. 例如, 我们可能会有第二表描述了不同城市的平均日高温.\n1 2 3 4  sqlite\u0026gt; create table temps as ...\u0026gt; select \u0026#34;Berkeley\u0026#34; as city, 68 as temp union ...\u0026gt; select \u0026#34;Chicago\u0026#34; , 59 union ...\u0026gt; select \u0026#34;Minneapolis\u0026#34; , 55;   通过将多个表连接在一起来组合数据, 这是数据库系统的基本操作. 有很多方法来进行连接, 所有都是密切相关的, 但是在本文中我们会只专注于一个方法. 当表被连接时结果表包含所有输入的表组合而成的新的行. 如果两个表被连接同时左边的表具有m行, 右边的表具有n行, 那么连接后的表就会具有m*n行. 连接在SQL中的表达是通过在select语句中的from子句中用逗号分隔表格名称来实现的.\n1 2 3 4 5 6 7 8 9 10  sqlite\u0026gt; select * from cities, temps; 38|122|Berkeley|Berkeley|68 38|122|Berkeley|Chicago|59 38|122|Berkeley|Minneapolis|55 42|71|Cambridge|Berkeley|68 42|71|Cambridge|Chicago|59 42|71|Cambridge|Minneapolis|55 45|93|Minneapolis|Berkeley|68 45|93|Minneapolis|Chicago|59 45|93|Minneapolis|Minneapolis|55   连接一般会伴随有where子句来表达两个表之间的关系. 例如, 如果我们想要收集数据到一个表中, 这个表允许我们关联纬度以及温度, 我们会从连接中选择那些两个表中都提及到的城市来组成行. 在cities表中, 城市的名称被保存在名为name的列中. 在temps表中, 城市名称被保存在名为city的列中. where子句在连接表中选择那些值相等的行. 在SQL, 使用单个=符号来测试数字等式.\n1 2 3  sqlite\u0026gt; select name, latitude, temp from cities, temps where name = city; Berkeley|38|68 Minneapolis|45|55   表可能会具有重叠的列名称, 因此我们需要一种通过表来消除列名称歧义的方法, 一个表也可能与它自己来进行连接, 因此我们需要一种方法来消除表名称的歧义. 为了这样做, SQL允许我们在from子句中用as关键字来为表格起别名并通过使用点表达式来在特定表格中引用列名称. 下面的select语句计算两个不相等的城市的温度差. 在where子句中具有按之母顺序的约束确保每一对数据只会在结果中出现一次.\n1 2 3 4 5  sqlite\u0026gt; select a.city, b.city, a.temp - b.temp ...\u0026gt; from temps as a, temps as b where a.city \u0026lt; b.city; Berkeley|Chicago|10 Berkeley|Minneapolis|15 Chicago|Minneapolis|5   我们在SQL中组合表的两种方法, 连接以及合并(join以及union), 允许语句具有极大的表现力.\n4.3.4 解释SQL 为了创建迄今为止介绍的一个SQL子集的解析器, 我们需要创建表格的表示, 用文本写成的语句的解析器以及解析语句的执行器. sql解析器的例子介绍了所有这些部分, 提供简单但是能演示功能的声明式语言解析器.\n在这个实现中, 每个表具有它自己的类, 在表中的每行数据通过这个表格类的实例来进行表示. 行在表中的每一列都具有一个属性, 同时, 表格是一系列的行.\n表格的类是使用Python标准库中的collections包中namedtuple函数来创建的, 它会返回一个新的tuple的子类, 并给元组中的每个元素命名.\n想一下来自前面章节的cities表, 表示如下.\n1 2 3 4  sqlite\u0026gt; create table cities as ...\u0026gt; select 38 as latitude, 122 as longitude, \u0026#34;Berkeley\u0026#34; as name union ...\u0026gt; select 42, 71, \u0026#34;Cambridge\u0026#34; union ...\u0026gt; select 45, 93, \u0026#34;Minneapolis\u0026#34;;   下面的Python语句构造了这表格的表示\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; from collections import namedtuple \u0026gt;\u0026gt;\u0026gt; CitiesRow = namedtuple(\u0026#34;Row\u0026#34;, [\u0026#34;latitude\u0026#34;, \u0026#34;longitude\u0026#34;, \u0026#34;name\u0026#34;]) \u0026gt;\u0026gt;\u0026gt; cities = [CitiesRow(38, 122, \u0026#34;Berkeley\u0026#34;), CitiesRow(42, 71, \u0026#34;Cambridge\u0026#34;), CitiesRow(43, 93, \u0026#34;Minneapolis\u0026#34;)]   select语句的结果可以用序列操作来进行解析. 回想一下来自前面章节的distances表, 表示如下.\n1 2 3 4 5 6  sqlite\u0026gt; create table distances as ...\u0026gt; select name, 60*abs(latitude-38) as distance from cities; sqlite\u0026gt; select distance/5, name from distances; 0|Berkeley 48|Cambridge 84|Minneapolis   这个表格是由cities表格中的name以及latitude列产生的. 这结果列表可以通过在输入表的行上映射函数来形成, 这个函数为每一个CitiesRow返回DistancesRow.\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; DistancesRow = namedtuple(\u0026#34;Row\u0026#34;, [\u0026#34;name\u0026#34;, \u0026#34;distance\u0026#34;]) \u0026gt;\u0026gt;\u0026gt; def select(cities_row): latitude, longitude, name = cities_row return DistancesRow(name, 60*abs(latitude-38)) \u0026gt;\u0026gt;\u0026gt; distances = list(map(select, cities)) \u0026gt;\u0026gt;\u0026gt; for row in distances: print(row) Row(name=\u0026#39;Berkeley\u0026#39;, distance=0) Row(name=\u0026#39;Cambridge\u0026#39;, distance=240) Row(name=\u0026#39;Minneapolis\u0026#39;, distance=300)   我们的SQL解析器的设计概括了这个方法. select语句表示为由select子句构造的类Select的实例.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026gt;\u0026gt;\u0026gt; class Select: \u0026#34;\u0026#34;\u0026#34;select [columns] from [tables] where [condition] order by [order].\u0026#34;\u0026#34;\u0026#34; def __init__(self, columns, tables, condition, order): self.columns = columns self.tables = tables self.condition = condition self.order = order self.make_row = create_make_row(self.columns) def execute(self, env): \u0026#34;\u0026#34;\u0026#34;Join, filter, sort, and map rows from tables to columns.\u0026#34;\u0026#34;\u0026#34; from_rows = join(self.tables, env) filtered_rows = filter(self.filter, from_rows) ordered_rows = self.sort(filtered_rows) return map(self.make_row, ordered_rows) def filter(self, row): if self.condition: return eval(self.condition, row) else: return True def sort(self, rows): if self.order: return sorted(rows, key=lambda r: eval(self.order, r)) else: return rows   execute方法连接输入表, 过滤并排序结果行, 然后映射函数make_row调用到这些结果行中. make_row函数是在Select构造器中通过调用create_make_row来创建的, 这个高阶函数为结果表创建一个新的类并定义如何将输入行投影到输出行. (这个函数具有更多错误处理以及特殊情况的版本出现在sql中.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026gt;\u0026gt;\u0026gt; def create_make_row(description): \u0026#34;\u0026#34;\u0026#34;Return a function from an input environment (dict) to an output row. description -- a comma-separated list of [expression] as [column name] \u0026#34;\u0026#34;\u0026#34; columns = description.split(\u0026#34;, \u0026#34;) expressions, names = [], [] for column in columns: if \u0026#34; as \u0026#34; in column: expression, name = column.split(\u0026#34; as \u0026#34;) else: expression, name = column, column expressions.append(expression) names.append(name) row = namedtuple(\u0026#34;Row\u0026#34;, names) return lambda env: row(*[eval(e, env) for e in expressions])   最后, 我们需要定义join函数来创建输入行. 给定一个env字典包含现有表(行的列表)并以它们的名字作为key值, join函数将所有行的组合, 用itertools包中的product函数组合到输出表中. 它映射一个叫做make_env的函数到已经连接完成的行当中去, 这个函数将每个行的组合转换为字典, 以便它可以用来执行表达式. (这个函数具有更多错误处理以及特殊情况的版本出现在sql中)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; from itertools import product \u0026gt;\u0026gt;\u0026gt; def join(tables, env): \u0026#34;\u0026#34;\u0026#34;Return an iterator over dictionaries from names to values in a row. tables -- a comma-separate sequences of table names env -- a dictionary from global names to tables \u0026#34;\u0026#34;\u0026#34; names = tables.split(\u0026#34;, \u0026#34;) joined_rows = product(*[env[name] for name in names]) return map(lambda rows: make_env(rows, names), joined_rows) \u0026gt;\u0026gt;\u0026gt; def make_env(rows, names): \u0026#34;\u0026#34;\u0026#34;Create an environment of names bound to values.\u0026#34;\u0026#34;\u0026#34; env = dict(zip(names, rows)) for row in rows: for name in row._fields: env[name] = getattr(row, name) return env   上面, row._fields求包含该行的表的列名称的值. _fields属性的存在是因为row的类型是namedtuple类.\n我们的解析器已经足够执行select语句了. 例如我们可以计算从\u0026quot;Berkeley\u0026quot;到其他所有城市的纬度距离, 并以它们的经度来排序.\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; env = {\u0026#34;cities\u0026#34;: cities} \u0026gt;\u0026gt;\u0026gt; select = Select(\u0026#34;name, 60*abs(latitude-38) as distance\u0026#34;, \u0026#34;cities\u0026#34;, \u0026#34;name != \u0026#39;Berkeley\u0026#39;\u0026#34;, \u0026#34;-longitude\u0026#34;) \u0026gt;\u0026gt;\u0026gt; for row in select.execute(env): print(row) Row(name=\u0026#39;Minneapolis\u0026#39;, distance=300) Row(name=\u0026#39;Cambridge\u0026#39;, distance=240)   上面的例子等于接下来的SQL语句.\n1 2 3 4  sqlite\u0026gt; select name, 60*abs(latitude-38) as distance ...\u0026gt; from cities where name != \u0026#34;Berkeley\u0026#34; order by -longitude; Minneapolis|420 Cambridge|240   我们也可以保存这个结果表到环境中并将它跟cities表进行连接, 并检索每个城市的经度.\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; env[\u0026#34;distances\u0026#34;] = list(select.execute(env)) \u0026gt;\u0026gt;\u0026gt; joined = Select(\u0026#34;cities.name as name, distance, longitude\u0026#34;, \u0026#34;cities, distances\u0026#34;, \u0026#34;cities.name == distances.name\u0026#34;, None) \u0026gt;\u0026gt;\u0026gt; for row in joined.execute(env): print(row) Row(name=\u0026#39;Cambridge\u0026#39;, distance=240, longitude=71) Row(name=\u0026#39;Minneapolis\u0026#39;, distance=300, longitude=93)   上面的例子等同于下面的SQL语句.\n1 2  sqlite\u0026gt; select cities.name as name, distance, longitude ...\u0026gt; from cities, distances where cities.name = distances.name   完整的sql例子程序也包含一个用于select语句的简单解析器, 以及create table和union的execute方法. 解析器可以正确地执行所有的SQL语句包括本文目前为止所包含的. 而这个简单的解析器只实现了少量完整的结构化查询语言, 它的结构演示了序列处理操作以及查询语言之间的关系.\n查询计划. 声明式语言描述了结果的形式, 但是没有明确地描述这个结果应该如何被计算得到. 这个解析器总是连接, 过滤, 排序, 然后投影输入行用以计算结果行. 然而, 更有效率的计算相同结果的方式可能是存在的, 同时查询解析器也可以自由地在它们之间做选择. 为计算查询结果选择高效过程也是数据库系统的核心功能.\n例如, 思考一下上面最后的选择语句. 并非是计算连接后的cities以及distances然后过滤出结果, 而是相同的结果可能首先对两个表都以name列来进行排序, 然后只连接具有相同名称的行, 以线性的方式过一遍已经排序过的行. 当表格是巨大的时候, 查询计划选择可以具有很大的效率增益.\n4.3.5 递归选择语句 选择语句可以选择性地包含with子句来生成以及命名另外的用来计算最终结果的表. select语句的完整语法, 不包括联合(unions), 具有以下的形式:\nwith [tables] select [columns] from [names] where [condition] order by [order]\n我们已经展示了[columns]和[names]的允许值. [condition]以及[order]是可以用来执行计算输入行的表达式. [tables]部分是一个用逗号分割的用来描述表格形式的列表.\n[table name]([column names]) as ([select statement])\n任何select语句都可以被用来在[tables]中描述一个表\n例如, 下面的with子句声明了一个表states包含城市以及它们的状态. select语句计算同一州内的城市对.\n1 2 3 4 5 6 7 8 9 10 11 12  sqlite\u0026gt; with ...\u0026gt; states(city, state) as ( ...\u0026gt; select \u0026#34;Berkeley\u0026#34;, \u0026#34;California\u0026#34; union ...\u0026gt; select \u0026#34;Boston\u0026#34;, \u0026#34;Massachusetts\u0026#34; union ...\u0026gt; select \u0026#34;Cambridge\u0026#34;, \u0026#34;Massachusetts\u0026#34; union ...\u0026gt; select \u0026#34;Chicago\u0026#34;, \u0026#34;Illinois\u0026#34; union ...\u0026gt; select \u0026#34;Pasadena\u0026#34;, \u0026#34;California\u0026#34; ...\u0026gt; ) ...\u0026gt; select a.city, b.city, a.state from states as a, states as b ...\u0026gt; where a.state = b.state and a.city \u0026lt; b.city; Berkeley|Pasadena|California Boston|Cambridge|Massachusetts   一个定义在with子句中的表可能会具有递归的情况, 它根据其他输出行来定义输出行. 例如, 下面的with子句定义一个具有5到15的整数的表, 而奇数值会被选择并进行平方.\n1 2 3 4 5 6 7 8 9 10 11 12  sqlite\u0026gt; with ...\u0026gt; ints(n) as ( ...\u0026gt; select 5 union ...\u0026gt; select n+1 from ints where n \u0026lt; 15 ...\u0026gt; ) ...\u0026gt; select n, n*n from ints where n % 2 = 1; 5|25 7|49 9|81 11|121 13|169 15|225   多个表可以被定义在with子句中, 用逗号隔开. 下面的例子计算所有的来自表中的整数的毕达哥斯拉三角数, 它们的平方, 以及平方对的和. 毕达哥斯拉三角数由整数a, b以及c来组成这样的公式\\(a^2 + b^2 = c^2\\)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  sqlite\u0026gt; with ...\u0026gt; ints(n) as ( ...\u0026gt; select 1 union select n+1 from ints where n \u0026lt; 20 ...\u0026gt; ), ...\u0026gt; squares(x, xx) as ( ...\u0026gt; select n, n*n from ints ...\u0026gt; ), ...\u0026gt; sum_of_squares(a, b, sum) as ( ...\u0026gt; select a.x, b.x, a.xx + b.xx ...\u0026gt; from squares as a, squares as b where a.x \u0026lt; b.x ...\u0026gt; ) ...\u0026gt; select a, b, x from squares, sum_of_squares where sum = xx; 3|4|5 6|8|10 5|12|13 9|12|15 8|15|17 12|16|20   设计递归查询涉及到确保每个输入行的相应信息可用于计算输出行. 例如, 计算斐波那契数, 输入行为了要计算出下一个元素需要的不仅是当前元素, 同时前一个元素也需要.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  sqlite\u0026gt; with ...\u0026gt; fib(previous, current) as ( ...\u0026gt; select 0, 1 union ...\u0026gt; select current, previous+current from fib ...\u0026gt; where current \u0026lt;= 100 ...\u0026gt; ) ...\u0026gt; select previous from fib; 0 1 1 2 3 5 8 13 21 34 55 89   这些例子证明了递归是强大的组合手段, 甚至是在声明式语言中.\n建造字符串. 两个字符串可以通过使用在SQL中的||操作符级联成更长的字符串.\n1 2 3 4 5 6 7  sqlite\u0026gt; with wall(n) as ( ....\u0026gt; select 99 union select 98 union select 97 ....\u0026gt; ) ....\u0026gt; select n || \u0026#34; bottles\u0026#34; from wall; 99 bottles 98 bottles 97 bottles   这个特性可以用来通过短语从而构造句子. 例如, 构造英文句子的一种方式是级联一个主题名词短语, 一个动词, 以及一个对象名词短语.\n1 2 3 4 5 6 7 8 9 10 11 12 13  sqlite\u0026gt; create table nouns as ....\u0026gt; select \u0026#34;the dog\u0026#34; as phrase union ....\u0026gt; select \u0026#34;the cat\u0026#34; union ....\u0026gt; select \u0026#34;the bird\u0026#34;; sqlite\u0026gt; select subject.phrase || \u0026#34; chased \u0026#34; || object.phrase ....\u0026gt; from nouns as subject, nouns as object ....\u0026gt; where subject.phrase != object.phrase; the bird chased the cat the bird chased the dog the cat chased the bird the cat chased the dog the dog chased the bird the dog chased the cat   作为练习, 使用一个本地递归表来构建句子, 如: \u0026ldquo;the dog that chased the cat that chased the bird also chased the bird.\u0026rdquo;\n4.3.6 聚合与分组 到目前为止我们介绍的select语句可以连接, 投射, 操纵单个行. 除此之外, select语句还可以执行多行聚合操作. 聚合函数max, min, count以及sum返回列中的最大, 最小, 数字以及总和值. 多种聚合函数可以通过定义多个列应用到相同的行集合里面. 只有包含在where子句中的列才会被认为是在这个集合中.\n1 2 3 4 5 6 7 8 9 10 11 12 13  sqlite\u0026gt; create table animals as ....\u0026gt; select \u0026#34;dog\u0026#34; as name, 4 as legs, 20 as weight union ....\u0026gt; select \u0026#34;cat\u0026#34; , 4 , 10 union ....\u0026gt; select \u0026#34;ferret\u0026#34; , 4 , 10 union ....\u0026gt; select \u0026#34;t-rex\u0026#34; , 2 , 12000 union ....\u0026gt; select \u0026#34;penguin\u0026#34; , 2 , 10 union ....\u0026gt; select \u0026#34;bird\u0026#34; , 2 , 6; sqlite\u0026gt; select max(legs) from animals; 4 sqlite\u0026gt; select sum(weight) from animals; 12056 sqlite\u0026gt; select min(legs), max(weight) from animals where name \u0026lt;\u0026gt; \u0026#34;t-rex\u0026#34;; 2|20   distinct关键字确保聚合中没有包含列中重复的值. 在animals表中的legs只出现了两个不同的值. 特殊的count(*)句法统计行的数量.\n1 2 3 4 5 6  sqlite\u0026gt; select count(legs) from animals; 6 sqlite\u0026gt; select count(*) from animals; 6 sqlite\u0026gt; select count(distinct legs) from animals; 2   每一个select语句都产出具有一行数据的表. select语句中的group by以及having子句是用来将行分成组并仅选择组的一个子集. 任何在having子句中的聚合函数或者列描述会被单独地应用到每一组, 而不是表中的整个行的集合.\n例如, 计算来自这个表的所有四条腿以及两条腿的动物中重量最大的那个, 下面的第一个语句将狗和猫组合在一起为一个组, 同时鸟作为一个分组. 结果表明最大重量的两条腿的动物是3(鸟), 而对于四条腿的动物则是20(狗). 第二个查询列出了至少有两个不同名称的legs列中的值.\n1 2 3 4 5  sqlite\u0026gt; select legs, max(weight) from animals group by legs; 2|12000 4|20 sqlite\u0026gt; select weight from animals group by weight having count(*)\u0026gt;1; 10   多列以及完整表达可以出现在group by子句中, 同时, 组将为每个独特的组合值形成结果. 通常, 用在分组的表达式也会出现列描述, 因此这很容易去确定每个组产生的结果行.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  sqlite\u0026gt; select max(name) from animals group by legs, weight order by name; bird dog ferret penguin t-rex sqlite\u0026gt; select max(name), legs, weight from animals group by legs, weight ....\u0026gt; having max(weight) \u0026lt; 100; bird|2|6 penguin|2|10 ferret|4|10 dog|4|20 sqlite\u0026gt; select count(*), weight/legs from animals group by weight/legs; 2|2 1|3 2|5 1|6000   having作为where的子句可以包含相同的过滤, 但是也可以包含调用聚合函数. 为了最快地执行的同时清晰使用这门语言, 基于其内容过滤单个行的条件应显示在where子句中, 而having子句应该只在聚合需要条件语句时使用(例如, 确定组的最小的count)\n当使用group by子句, 列描述可以包含非聚合的表达式, 在某些情况下, SQL解析器将从包含聚合的另一列对应的行中选择值. 例如, 下面的语句给出最大weight的动物的name.\n1 2 3 4 5  sqlite\u0026gt; select name, max(weight) from animals; t-rex|12000 sqlite\u0026gt; select name, legs, max(weight) from animals group by legs; t-rex|2|12000 dog|4|20   然而, 每当对应于聚合的行是不确定的时候(例如, 当用count而不是max聚合时), 选择的值可能是任意的. 为了最清晰同时最可预测地使用这门语言, select语句包含group by子句的话至少应该包含聚合列同时只有当非聚合列的内容可以从聚合中预测时, 才去包含它.\n4.4 逻辑编程 在这一章中, 我们介绍一个声明式查询语言, 它叫做logic, 特别为本文来设计的. 它建立在Prolog以及在计算机程序构造与解析声明式语言之上. 数据记录是作为Scheme列表来表示的, 同时查询表示为Scheme值. logic解析器是一个基于前一章的Scheme项目之上的完整实现.\n4.4.1 事实和疑问 数据存储记录代表系统中的事实. 查询解析器的目的是直接检索从数据库记录中抽取的事实的集合, 以及使用逻辑推理从数据库中推断出新的事实. 在logic语言中的fact语句包含一个或多个遵循关键字fact的列表. 一个简单的事实是单一的一个列表. 对美国总统感兴趣的狗饲养员可以使用logic语言记录她收集的狗的家谱, 如下:\n1 2 3 4 5 6 7  (fact (parent abraham barack)) (fact (parent abraham clinton)) (fact (parent delano herbert)) (fact (parent fillmore abraham)) (fact (parent fillmore delano)) (fact (parent fillmore grover)) (fact (parent eisenhower fillmore))   在Scheme表达式中, 每个fact不是一个应用程序, 而是声明的关系. \u0026ldquo;Abraham狗是Barack狗的父亲,\u0026rdquo; 声明第一个事实. 关系类型不需要提前定义. 关系并不是用来应用, 而是用于匹配查询.\n一个查询也由一个或多个列表组成但是以关键字query开头. 一个查询可能包含变量, 它以问号符号作为开头. 变量通过查询解析器与事实进行匹配.\n1 2 3 4  (query (parent abraham ?child)) Success! child: barack child: clinton   查询解析器以Success!作为响应来表明查询匹配某些事实. 接下来的几行展示变量?child的替换匹配在数据库中查询的事实.\n复合事实. 事实可能也会包含变量以及多个子表达式. 一个多表达式事实从结论开始, 其次是假设. 要想结论是真实的, 那么所有的假设必须要满足:\n(fact \u0026lt;conclusion\u0026gt; \u0026lt;hypothesis0\u0026gt; \u0026lt;hypothesis1\u0026gt; ... \u0026lt;hypothesisN\u0026gt;)\n例如, 关于孩子的事实可以以已经存在数据中的父级的事实为基础来声明:\n(fact (child ?c ?p) (parent ?p ?c))\n上面的事实可以被读作: \u0026ldquo;?c 是 ?p 的孩子. 倘若 ?p 是 ?c 的父级.\u0026rdquo; 一个查询现在可以被索引到这个事实:\n1 2 3 4 5  (query (child ?child fillmore)) Success! child: abraham child: delano child: grover   上面的查询需要查询解析器来组合那些各个父级事实被定义为fillmore的子级的事实. 语言的用户不需要知道这些信息是如何被组合的, 只需要知道结果具有特定的形式. 这是由查询解析器来证明在给定的可用事实下(child abraham fillmore)是对的.\n查询不需要包括变量; 它可能只是简单地验证一个事实:\n1 2  (query (child herbert delano)) Success!   查询如果没有匹配任何的事实会返回失败(消息):\n1 2  (query (child eisenhower ?parent)) Failed.   否定. 我们可以用关键词not来检查查询语句是否没有匹配任何的事实:\n(query (not \u0026lt;relation\u0026gt;))\n如果\u0026lt;relation\u0026gt;失败, 则查询成功, 如果\u0026lt;relation\u0026gt;成功, 则查询失败. 这一思想被称为否定为失败.\n1 2 3 4 5  (query (not (parent abraham clinton))) Failed. (query (not (parent abraham barack))) Failed.   有时候, 否定为失败对于期望否定能够有效是有悖常理的. 想一下下面的查询的结果:\n(query (not (parent abraham ?who)))\n为什么这个查询会失败? 可以肯定的是这里有许多符号可以绑定到这个被保留的变量?who中. 然而, 否定的步骤表明我们首先检查的关系是(parent abraham ?who). 这个关联是成功的, 因为?who可以被绑定到barack或者clinton中. 由于这个关联成功了, 这个关联的否定则必然失败.\n4.4.2 递归事实 logic语言也允许递归事实. 也就是说, 事实的结论可能取决于一个假设, 这个假设包含了相同的符号. 例如, 祖先关系被定义为两个事实. 某些?a如果是?y的父级或者是?y的祖先的父级, 则它是?y的祖先.\n1 2  (fact (ancestor ?a ?y) (parent ?a ?y)) (fact (ancestor ?a ?y) (parent ?a ?z) (ancestor ?z ?y))   单个查询可以列出所有的herbert的祖先:\n1 2 3 4 5  (query (ancestor ?a herbert)) Success! a: delano a: fillmore a: eisenhower   复合查询. 查询可能具有多个子表达式, 在这种情况下, 所有这些都必须同时通过将符号分配到变量来同时满足. 如果一个变量在一次查询中出现多于一次, 那么它必须在每个上下文中都具有相同的值. 接下来的查询查找herbert以及barack的共同祖先:\n1 2 3 4  (query (ancestor ?a barack) (ancestor ?a herbert)) Success! a: fillmore a: eisenhower   递归事实可能需要一长串的推论来将查询与数据库中的现有事实相匹配. 例如, 要证明事实(fillmore herbert的祖先), 我们必须要证明每一个具有继承性的下列事实:\n1 2 3 4  (parent delano herbert) ; (1), a simple fact (ancestor delano herbert) ; (2), from (1) and the 1st ancestor fact (parent fillmore delano) ; (3), a simple fact (ancestor fillmore herbert) ; (4), from (2), (3), \u0026amp; the 2nd ancestor fact   通过这种方式, 某个事实可以意味着一大堆额外的事实, 甚至是无限多的, 只要这个查询解析器能够发现它们.\n分级事实. 到目前为止, 每个事实以及查询表达式都是符号列表. 除此之外, 事实以及查询列表可以包含列表, 提供了一种方式来表示分级数据. 每只狗的颜色可能会与名称一起存储在附加记录中:\n1 2 3 4 5 6 7 8  (fact (dog (name abraham) (color white))) (fact (dog (name barack) (color tan))) (fact (dog (name clinton) (color white))) (fact (dog (name delano) (color white))) (fact (dog (name eisenhower) (color tan))) (fact (dog (name fillmore) (color brown))) (fact (dog (name grover) (color tan))) (fact (dog (name herbert) (color brown)))   查询可以表达层次结构的完整结构, 或者它们可以将变量匹配到整个列表:\n1 2 3 4 5 6 7  (query (dog (name clinton) (color ?color))) Success! color: white (query (dog (name clinton) ?info)) Success! info: (color white)   数据库中的大部分功能在于查询解析器在一次查询中将多种事实连接的能力. 下面的查询寻找所有的以一对形式组成的狗, 其中一个是另一个的祖先, 并且它们共享同一种颜色:\n1 2 3 4 5 6 7 8  (query (dog (name ?name) (color ?color)) (ancestor ?ancestor ?name) (dog (name ?ancestor) (color ?color))) Success! name: barack\tcolor: tan\tancestor: eisenhower name: clinton\tcolor: white\tancestor: abraham name: grover\tcolor: tan\tancestor: eisenhower name: herbert\tcolor: brown\tancestor: fillmore   变量可以在分层记录中引用列表, 而且还使用点符号. 一个变量紧跟着一个点符号将会匹配列表中的其他的事实. 带点的列表可以出现在事实或者查询中. 下面的例子通过列出它们的祖先链来构建狗的血统. 年轻的barack循着著名的总统宠物的这条线上:\n1 2 3 4 5 6 7 8 9 10 11  (fact (pedigree ?name) (dog (name ?name) . ?details)) (fact (pedigree ?child ?parent . ?rest) (parent ?parent ?child) (pedigree ?parent . ?rest)) (query (pedigree barack . ?lineage)) Success! lineage: () lineage: (abraham) lineage: (abraham fillmore) lineage: (abraham fillmore eisenhower)   声明式或者逻辑式编程可以以显著的效率表达事实之间的关系. 例如, 如果我们希望表达两个列表可以附加形成一个更长的列表以第一个列表的元素为先随后跟着的元素是第二个列表的, 为此我们声明两个规则. 首先, 基础情况是声明将空列表添加到任何列表中并返回这个列表:\n(fact (append-to-form () ?x ?x))\n接着, 一个递归事实声明具有第一个元素为?a以及余下元素?r的列表附加到列表?y中来形成一个列表, 它具有的第一个元素为?a以及余下被附加的?z. 为了保持这种关系, 它必须要是?r和?y附加形成?z这种情况:\n(fact (append-to-form (?a . ?r) ?y (?a . ?z)) (append-to-form ?r ?y ?z))\n使用这两个事实, 查询解析器可以计算附加任意两个列表到一起的结果:\n1 2 3  (query (append-to-form (a b c) (d e) ?result)) Success! result: (a b c d e)   此外, 它还可以计算?left以及?right的所有可能的列表对来附加形成列表(a b c d e):\n1 2 3 4 5 6 7 8  (query (append-to-form ?left ?right (a b c d e))) Success! left: ()\tright: (a b c d e) left: (a)\tright: (b c d e) left: (a b)\tright: (c d e) left: (a b c)\tright: (d e) left: (a b c d)\tright: (e) left: (a b c d e)\tright: ()   尽管看起来我们的查询解析器很智能, 但我们可以看到它通过一个简单的操作重复很多次来查找这些组合: 匹配在环境中包含变量的两个列表.\n4.5 统一 本节描述一个能够执行推理logic语言的查询解析器的实现. 这个解析器是一个一般问题的解决者, 但是在它可以解决的问题的规模以及类型上具有实质性的限制. 存在着更加复杂逻辑编程语言, 但是高效推理程序的构建仍然是计算机科学积极研究的课题.\n通过查询解析器执行的基本操作被称为统一. 统一是匹配查询到一个事实的一般方法, 每一个都可能包含变量. 查询解析器反复地应用这个操作, 首先去匹配原始的查询来对做出事实的结论, 然后匹配事实对于在数据库中的其他结论的假设. 在这样做之后, 查询解析器通过所有与事实查询有关的事实之间来执行搜索. 如果它找到一个方法来支持使用赋值给变量进行查询, 它会将该工作作为成功的结果返回.\n4.5.1 模式匹配 为了返回匹配查询的简单事实, 解析器必须要匹配包含不具有事实的变量的查询. 例如, 查询(query (parent abraham ?child))以及如果变量?child具有值barack那么事实(fact (parent abraham barack))与之匹配.\n一般来说, 一个模式匹配某些表达式(一个可能的嵌套Scheme列表), 如果有变量名与值的绑定, 将这些值转换为模式, 则会生成表达式.\n例如, 表达式((a b) c (a b))匹配模式(?x c ?x)其中?x绑定到值(a b). 相似的表达式匹配模式((a ?y) ?z (a b))其中变量?y绑定到b同时?z绑定到c.\n4.5.2 代表事实和查询 下面的例子可以通过引入提供的logic例子程序来复现.\n1  \u0026gt;\u0026gt;\u0026gt; from logic import *   所有的查询以及事实都使用在逻辑语言中的Scheme列表来表示, 使用之前章节中相同的Pair类以及nil对象. 例如, 查询表达式(?x c ?x)是被表示为嵌套的Pair实例.\n1 2  \u0026gt;\u0026gt;\u0026gt; read_line(\u0026#34;(?x c ?x)\u0026#34;) Pair(\u0026#39;?x\u0026#39;, Pair(\u0026#39;c\u0026#39;, Pair(\u0026#39;?x\u0026#39;, nil))))   就像在Scheme项目中一样, 将符号绑定到值的环境用Frame类的实例来表示, 它具有一个称为bindings的属性.\n在logic语言中执行模式匹配的函数被叫做unify. 它接受两个输入, e和f, 以及一个记录了将变量绑定到值的env环境.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; e = read_line(\u0026#34;((a b) c (a b))\u0026#34;) \u0026gt;\u0026gt;\u0026gt; f = read_line(\u0026#34;(?x c ?x)\u0026#34;) \u0026gt;\u0026gt;\u0026gt; env = Frame(None) \u0026gt;\u0026gt;\u0026gt; unify(e, f, env) True \u0026gt;\u0026gt;\u0026gt; env.bindings {\u0026#39;?x\u0026#39;: Pair(\u0026#39;a\u0026#39;, Pair(\u0026#39;b\u0026#39;, nil))} \u0026gt;\u0026gt;\u0026gt; print(env.lookup(\u0026#39;?x\u0026#39;)) (a b))   上面, 来自unify的返回值True表明模式f能够匹配表达式e. 结果统一的结果被记录在以绑定到约束在env中的(a b)到?x.\n4.5.3 统一算法 统一是概括模式匹配中尝试去寻找两个可能都具有变量的表达式之间的映射. unify函数通过一个递归过程在两个表达式的相应部分执行统一直到遇到矛盾或者建立对所有变量的可行约束来实现统一.\n让我们以一个例子来作为开始, 模式(?x ?x)可以匹配模式((a ?y c) (a b ?z))因为有一个没有变量的表达式可以匹配它们两者: ((a b c) (a b c)). 统一通过下面的步骤来识别这一解决方案:\n 匹配每个模式的第一个元素, 变量?x被绑定到表达式(a ?y c). 匹配每个模式的第二个元素, 首先变量?x被它的值给替代. 然后, 通过绑定?y到b以及?z到c使得(a ?y c)跟(a b ?z)相符合.  因此, 传递给unify的绑定环境包含了条目?x, ?y, 以及?z:\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; e = read_line(\u0026#34;(?x ?x)\u0026#34;) \u0026gt;\u0026gt;\u0026gt; f = read_line(\u0026#34; ((a ?y c) (a b ?z))\u0026#34;) \u0026gt;\u0026gt;\u0026gt; env = Frame(None) \u0026gt;\u0026gt;\u0026gt; unify(e, f, env) True \u0026gt;\u0026gt;\u0026gt; env.bindings {\u0026#39;?z\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;?y\u0026#39;: \u0026#39;b\u0026#39;, \u0026#39;?x\u0026#39;: Pair(\u0026#39;a\u0026#39;, Pair(\u0026#39;?y\u0026#39;, Pair(\u0026#39;c\u0026#39;, nil)))}   统一的结果可能会绑定变量到一个表达式, 这个表达式本身也可能包含变量, 就像我们上面看到的?x绑定为(a ?y c). bind函数递归且重复地在一个表达式上绑定它们的值到所有的变量上直到没有遗留需要绑定的变量.\n1 2  \u0026gt;\u0026gt;\u0026gt; print(bind(e, env)) ((a b c) (a b c))   一般来说, 统一通过检查几个条件来执行. unify的实现直接遵循下面的描述.\n 输入e以及f如果它们两者是变量则它们会被值给替换 如果e以及f相等, 统一则成功执行. 如果e是一个变量, 统一成功执行同时e被绑定到f. 如果f是一个变量, 统一成功执行同时f被绑定到e. 如果两者都不是一个变量, 都不是一个列表, 同时它们也不相等, 那么e以及f就不能统一, 因此统一执行失败. 如果这些情况都不成立, 那么e和f都是pairs, 因此统一则需要在它第一和第二个对应的部分上执行.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026gt;\u0026gt;\u0026gt; def unify(e, f, env): \u0026#34;\u0026#34;\u0026#34;Destructively extend ENV so as to unify (make equal) e and f, returning True if this succeeds and False otherwise. ENV may be modified in either case (its existing bindings are never changed).\u0026#34;\u0026#34;\u0026#34; e = lookup(e, env) f = lookup(f, env) if e == f: return True elif isvar(e): env.define(e, f) return True elif isvar(f): env.define(f, e) return True elif scheme_atomp(e) or scheme_atomp(f): return False else: return unify(e.first, f.first, env) and unify(e.second, f.second, env)   4.5.4 证明 思考逻辑语言的一种方式是在正式的系统中以断言来进行证明. 每一个声明的事实都是建立在一个正式系统上的公理中, 同时每个查询必须要由查询解析器来在这些公理之上建立. 也就是说, 每个查询声明对其变量有一些赋值, 使得它的所有子表达式同时遵循系统的事实. 而查询解析器的角色就是去验证的确是这样的.\n例如, 给定有关狗的一系列事实, 我们会断言在这里Clinton以及一条棕色的狗具有相同的祖先. 查询解析器只输出Success!如果它能够确定这个断言是真的. 作为副产品, 它告知我们这个共同祖先以及棕色的狗的名字:\n1 2 3 4 5 6 7  (query (ancestor ?a clinton) (ancestor ?a ?brown-dog) (dog (name ?brown-dog) (color brown))) Success! a: fillmore\tbrown-dog: herbert a: eisenhower\tbrown-dog: fillmore a: eisenhower\tbrown-dog: herbert   展示在结果中的三个任务中的每一个都是用来跟踪在给定的事实下来更大地证明查询是真实的. 一个充分的证明包括所有使用的事实, 例如包含(parent abraham clinton)以及(parent fillmore abraham).\n4.5.5 搜索 为了在系统中已经建立的事实中建立一个查询, 查询解析器在所有可能的事实空间中执行一个查询. 统一是原始操作, 它对两个表达式进行模式匹配. 在查询解析器中的搜索过程选择用哪个表达式来进行统一, 以便找到链接在一起以建立查询的一组事实.\nsearch递归函数为logic语言实现查询过程. 它将在查询中的Scheme列表中的clauses作为输入, 环境env包含当前绑定了值(初始为空)的符号, 而且depth规则链也已经连接到一起了.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026gt;\u0026gt;\u0026gt; def search(clauses, env, depth): \u0026#34;\u0026#34;\u0026#34;Search for an application of rules to establish all the CLAUSES, non-destructively extending the unifier ENV. Limit the search to the nested application of DEPTH rules.\u0026#34;\u0026#34;\u0026#34; if clauses is nil: yield env elif DEPTH_LIMIT is None or depth \u0026lt;= DEPTH_LIMIT: if clauses.first.first in (\u0026#39;not\u0026#39;, \u0026#39;~\u0026#39;): clause = ground(clauses.first.second, env) try: next(search(clause, glob, 0)) except StopIteration: env_head = Frame(env) for result in search(clauses.second, env_head, depth+1): yield result else: for fact in facts: fact = rename_variables(fact, get_unique_id()) env_head = Frame(env) if unify(fact.first, clauses.first, env_head): for env_rule in search(fact.second, env_head, depth+1): for result in search(clauses.second, env_rule, depth+1): yield result   满足所有子句的查询同时也开始于第一个子句, 在我们的第一个子句被否定的特殊情况下, 不是试图将查询的第一个子句与事实统一起来, 而是我们通过递归调用search来检查这里没有这样的统一的可能. 如果这个递归调用没有返回任何东西, 我们以剩余的子句来继续这个查询过程, 如果统一是可能的, 那我们就立即失败了.\n如果我们的第一个子句没有被否定, 那么对于数据库中的每一个事实, search都尝试去将事实的第一个子句跟查询的第一个子句统一起来. 统一是在新的环境env_head中执行的. 作为统一的副作用, 变量被绑定到env_head中的值中.\n如果统一成功了, 那么, 子句匹配当前规则的结论. 接下来的for语句尝试去建立规则的假设, 因此结论可以被建立. 在这里, 递归规则的假设将被递归地传递以便建立进行search.\n最后, 对每个fact.second的成功搜索, 结果那环境绑定到env_rule. 给定这些值的绑定到变量, 最后的for语句搜索建立初始查询的剩余子句. 任何成功的结果都是通过内部的yield语句返回的.\n唯一名称. 统一操作假设在e以及f之间没有共享变量. 然而, 我们常常在logic语言的事实以及查询中复用变量名. 我们不会想将一个事实中的?x与另外一个事实中的?x混淆; 这些变量是不相关的. 在一个事实传入到统一前确保名称是不迷惑的, 其变量名称由使用rename_variables函数通过为事实附加一个唯一的整数替换为唯一的名称.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; def rename_variables(expr, n): \u0026#34;\u0026#34;\u0026#34;Rename all variables in EXPR with an identifier N.\u0026#34;\u0026#34;\u0026#34; if isvar(expr): return expr + \u0026#39;_\u0026#39; + str(n) elif scheme_pairp(expr): return Pair(rename_variables(expr.first, n), rename_variables(expr.second, n)) else: return expr   其余的细节, 包括在logic语言中的用户接口以及各种帮组函数的定义, 都出现在logic的例子中.\n4.6 分布式计算 大型数据处理程序通常会在多个计算机之间对有组织的活动进行协调. 分布式计算程序是一个在多个相互连接但独立计算机之间联合协调计算过程的程序.\n不同的计算机在某种意义上讲是独立的因为它们并不直接共享内存. 相反, 它们用_消息_来彼此通信, 通过网络将消息从一台计算机传递到另一台计算机.\n4.6.1 消息 在计算机之间发送的消息是一系列的位. 发送以及接收的计算机都必须要对消息的含义进行协商来使得交流能够成功. 很多消息协议指定消息必须遵循特定的格式使得在特定位置的位表示特定的条款. 其他使用特殊一个位或几个位序列来界定消息的各个部分, 就像在编程语言中用标点符号来界定子表达式.\n消息协议并非特定的程序或者软件库. 相反它们是可以被应用到多种程序中的规则, 甚至可以用不同的编程语言来编写. 因此, 具有极大不同的软件系统可以简单地通过遵从支配整个系统的消息协议来参与到相同的分发系统中.\nTCP/IP协议. 在网络上, 消息使用网络协议(IP)来从一个机器到另一个机器上传递, 这个协议具体说明了如何在不同的网络中传输包来允许全球网络通信. IP是设计在假设网络内部本身在任何时间点以及动态结构下都是不值得信任的, 此外, 它不会假设有任何通信上的中部跟踪或者监控的存在. 每一个包都包含一个头部, 这个头部包含目的IP地址, 以及其他消息. 所有的包都是在整个网络中向着目的地使用简单的路由协议以最大努力交付为基础来进行转发的.\n这个设计在通讯上施加限制. 包传输使用IP模式实现(IPv4以及IPv6)其具有最大大小为65,535位. 更大的数据值必须切分为多个数据包. IP协议并不保证包会以其发送的相同的顺序来被接收. 一些包可能会丢失, 某些包可能会被传输多次.\n传输控制协议是根据IP协议来抽象定义的用于提供可靠有序传输任意大小字节流的协议. 这个协议通过正确排序IP协议的正确的包来提供这个保证, 删除重复以及请求丢失了的包. 这种改进的可靠性以牺牲延迟为代价, 即将消息从一个点发送到另一个点所需的时间.\nTCP将流数据切分为TCP段, 每个都包含前面带有标题的数据的一部分, 其包含序列以及状态信息来支持有序, 可靠的数据传输. 某些TCP段不包含一点数据, 只是用于建立或者结束两个计算机之间的沟通通讯.\n在两台计算机A以及B之间建立链接需要执行一下三个步骤:\n 发送请求到B的端口来建立TCP链接, 提供一个_端口号_来指定响应发送的端口号. B发送一个响应到A指定的端口号并等待它的响应被确认. A发送响应确认, 验证数据可以进行双向传输.  在进行这三步\u0026quot;握手\u0026quot;之后, TCP连接就建立了, A以及B可以互相之间发送数据. 终止TCP连接也需要一系列的步骤来进行, 其中客户端和服务器端都请求并确认连接的结束.\n4.6.2 客户端/服务器架构 客户端/服务器架构是从中央源分配服务的一种方式, 服务器提供一个服务同时多个客户端与服务器通信来消费该服务. 在这中架构下, 客户端以及服务器扮演不同的角色. 服务器的角色是去响应来自客户端的服务请求, 而客户端的角色是去发起请求以及使用服务器的响应来执行某些任务. 下面的图表说明了这个架构.\n使用这种模型且最有影响力的是现代万维网(World Wide Web). 当网络浏览器展现网页的内容时, 运行在独立计算机上的多个程序使用客户端/浏览器架构来进行交互. 这一节介绍请求网页的过程用以说明客户端/服务器分布式系统中的中心思想.\n角色. 在网络用户计算机上的网络浏览器应用当其请求一个网页的时候扮演的是客户端的角色. 当从一个因特网上的域名请求内容时, 例如www.nytimes.com, 它必须要跟至少两个不同的服务器进行通信.\n用户最开始从域名服务器(DNS)请求位于该域名的的计算机的互联网协议(IP)地址. DNS提供映射域名到IP地址的服务, IP地址是因特网上机器的数字标识符. Python可以直接使用套接字(socket)模块提出这样的请求.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; from socket import gethostbyname \u0026gt;\u0026gt;\u0026gt; gethostbyname(\u0026#39;www.nytimes.com\u0026#39;) \u0026#39;170.149.172.130\u0026#39;   接着客户端会从位于对应IP地址的服务器请求网页的内容. 在这种情况下的响应是HTML文件, 这个文件包含标题和今日新闻的文章摘要, 以及表达并指出网络浏览器应该如何在客户界面上显示内容. Python可以使用urllib.request模块来发起两个请求去获取这些内容.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; from urllib.request import urlopen \u0026gt;\u0026gt;\u0026gt; response = urlopen(\u0026#39;http://www.nytimes.com\u0026#39;).read() \u0026gt;\u0026gt;\u0026gt; response[:15] b\u0026#39;\u0026lt;!DOCTYPE html\u0026gt;\u0026#39;   收到此回复, 浏览器为图片, 视频以及页面的其他部分发起额外的请求. 这些请求被发起是因为原始的HTML文件包含有额外内容的地址以及如何将它们内嵌进页面的描述.\nHTTP请求. 超文本传输协议(HTTP)是一个使用TCP实现的协议, 它是用来管理万维网(WWW)通讯的协议. 它假设网络浏览器以及网络服务器之间是客户端/服务器架构形式. HTTP指定浏览器与服务器之间的消息交换的格式. 所有网络浏览器使用的是HTTP格式来从网络服务器请求页面, 同时所有的网络服务器使用HTTP格式来返回它们的响应.\nHTTP请求具有几种类型, 最常用的是使用GET请求指定的网页. GET请求指定一个位置. 例如, 输入地址http://en.wikipedia.org/wiki/UC_Berkeley到Web浏览器中向en.wikipedia.org所在的Web服务器的端口80发起一个HTTP的GET请求获取位于/wiki/UC_Berkeley的内容.\n服务器返回HTTP响应:\nHTTP/1.1 200 OK Date: Mon, 23 May 2011 22:38:34 GMT Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux) Last-Modified: Wed, 08 Jan 2011 23:11:55 GMT Content-Type: text/html; charset=UTF-8 ... web page content ... 在第一行, 文本200 OK表明在响应请求的过程中没有错误发生. 在头部的后续行中给定关于服务器, 日期以及返回的内容类型的信息.\n如果你输入一个错误的web地址或者点击一个坏了的地址, 你可能会看到这样的消息, 如这个错误:\n404 Error File Not Found 这意味着服务器返回一个以下面所示开始的HTTP头:\nHTTP/1.1 404 Not Found 数字200以及404是HTTP响应码. 一组固定的响应码是消息协议的共同特征. 协议的设计者尝试去预测常用的会通过协议发送并分配固定码以减少传输数据量的大小同时建立公共消息语义的消息. 在HTTP协议中, 200响应码表明成功, 而404指示资源没有找到的错误. 其他各种各样的响应码存在于HTTP1.1标准中.\n模块化客户端和服务器的概念是强大的抽象. 服务器有可能同时对多个客户端提供服务, 而且客户端消费该服务. 客户端不需要知道服务是如何被提供的细节, 或者它们接收的数据是如何被存储以及计算的, 以及服务器不需要知道它的响应将会如何被使用.\n在Web上, 我们认为客户端以及服务器位于不同的机器上, 但即使是在单一的机器上的系统也可以具有客户端/服务器架构. 例如, 来自计算机上的输入设备的信号通常需要可用于计算机上运行的程序. 程序是客户端, 它会消耗鼠标以及键盘的输入数据. 操作系统的设备驱动程序是服务器, 接受物理信号同时为它们提供可用的输入. 此外, 中央处理单元(CPU)以及专门的图形处理单元(GPU)通常也参与进客户端/服务器架构, 其中CPU作为客户端而GPU则作为图形的服务器.\n客户端/服务器系统的缺点是服务器是单点故障. 它是唯一具有发放服务能力的组件. 客户端的数量可以是任意的, 彼此间可以互换, 并根据需要加进来或者除去.\n另一个客户端-服务器系统的缺点是如果客户端过多的话则计算资源会变得稀缺. 客户端增加对系统的需求, 而不贡献任何计算资源.\n4.6.3 点对点系统 客户端/服务器模式很适合面向服务的情况. 然而, 对于还有其他计算目标的系统而言更加平等的分工是一个更好的选择. 术语_点对点_是用来形容分布式系统的, 其中的工作均分在系统的所有部分中. 所有的计算机都发送并接收数据, 同时它们都贡献一定的处理能力以及存储. 随着分布式系统的规模越来越大, 其计算资源的能力也随之上升. 在一个点对点系统中, 系统的所有部分都贡献一些处理能力和内存到分布式计算中.\n在所有的参与者当中均分劳动量是识别点对点系统的特征. 这意味着点需要能够彼此之间进行可靠的通信. 为了确保消息能够准确到达目的地, 点对点系统需要具有一个有组织的网络结构. 在这些系统中的组成部件合作维护足够的关于其他部件的位置的信息来发送消息到目的地.\n在某些点对点系统中, 保持网络健康的工作是由一组专门的组件来进行的. 这样的系统并不是纯粹的点对点系统, 因为他们具有不同类型的组件来提供不同的功能. 这样的部件像脚手架一样支撑点对点系统: 它们帮助网络保持连接, 它们维护关于不同计算机位置的信息, 同时它们帮助新加入的成员在它们的邻居中占据它们自己的位置.\n最常用的点对点系统应用是数据传输以及数据存储. 对于数据传输来说, 每个在系统中的计算机都帮助在网络上发送数据. 如果目的地计算机在是在某个特定的计算机附近, 那么这个计算机也会帮助发送数据. 对于数据存储而言, 数据集可能对于任何单台计算机来说都是过于巨大的, 或者数据过于贵重无法仅存储于一个计算机上. 每个计算机都存储数据的一小部分, 同时相同的数据可能有多个副本分布在不同的计算机上. 当一个计算机出现故障时, 其上的数据可以从其他副本恢复, 并在替换到达时放回去.\nSkype, 语音以及视频聊天服务, 是点对点架构的数据传输应用的一个例子. 当两个在不同计算机上的人进行Skype会话时, 他们的对话会通过点对点网络进行传输. 该网络由运行Skype应用程序的其他计算机组成. 每个计算机都知道一些临近的其他计算机的位置. 一个计算机通过传输数据到它的邻居节点来帮助发送数据包到目的地, 而它的邻居节点也会传输数据到相应的邻居节点等等, 一直到包到达它的预订目的地. Skype并不是一个纯粹的点对点系统, 超级节点的脚手架网络负责登录和注销用户. 维护有关于计算机位置的信息以及在用户进入和退出时修改网络结构.\n4.7 分布式数据处理 分布式系统通常用来收集, 访问, 以及操作大型数据集. 例如, 前面章节描述的数据库系统可以操作保存在多个机器上的数据集. 没有一台机器可能包含响应查询所需的数据, 因此需要通信才能对请求进行服务.\n这一节探讨一个典型的大数据处理场景, 其中由于数据集太大而不能被单个机器处理, 而是分布在许多机器之间, 每个机器处理数据集中的一部分. 计算的结果必须经常在机器之间聚合, 因此一台机器的计算结果可以与其他机器组合. 为了协调这种分布式数据处理, 我们会讨论一个称为MapReduce的编程框架.\n使用MapReduce来创建一个分布式数据处理应用结合了本文中提出的许多想法. 应用程序用纯函数表示, 用于映射大型数据集, 然后将映射的值的序列不断减少直到得到最终结果.\n函数式编程中的熟悉概念用于MapReduce程序中具有巨大的好处. MapReduce要求用于映射和减少数据的函数是纯函数. 一般来说, 仅在纯功能方面表达的程序在如何执行方面具有很大的灵活性. 子表达式可以并行执行并以任意的顺序计算而不影响最终结果. 一个MapReduce应用能够并行运行许多纯函数, 重新排序在分布式系统中有效执行的计算.\nMapReduce的主要优势是它把分布式数据处理应用程序的两个部分之间的问题进行了分离:\n map以及reduce函数用于处理数据并将结果进行组合. 机器之间的沟通和协调.  协调机制处理分布式计算中出现的许多问题, 例如, 机器故障, 网络故障, 以及进度监控. 而管理这些问题为MapReduce应用程序引入了一些复杂性, 而这些复杂性没有暴露给应用程序开发人员. 相反, 构建一个MapReduce应用只需要指定上面(1)中提到的map以及reduce函数即可; 分布式计算的挑战是如何通过抽象来实现隐藏.\n4.7.1 MapReduce MapReduce框架假定输入是巨大, 无序的任意类型的输入值流. 例如, 每个输入可能是某些浩瀚的语料库中的一行文本. 计算过程分为三个步骤.\n map函数应用到每个输入中, 它会输出零个或者更多任意类型的中间键值对. 所有中间键值对都按照键来进行分组, 因此具有相同键的对可以被减少合并在一起. reduce函数对给定的键k的值组合在一起; 它会输出零个或者更多的值, 它们各自与最终输出中的k相关联.  为了执行这个计算, MapReduce框架创建在计算机中执行各种角色的任务(可能在不同的机器上). _map_任务会应用map函数到某些子集的输入数据上并输出中间键值对. _reduce_任务通过键来排序并组合键值对, 然后应用reduce函数到每个键的值上. 所有在map以及reduce任务之间的通信由框架来处理, 按键分组中间键值对的任务也是如此.\n为了在MapReduce应用中利用多台机器, 多个mappers会并行运行在一个map周期中, 而多个reducers并行运行在一个reduce周期中. 在这些周期之间, sort周期通过对它们进行排序来将键值对组合在一起, 因此具有相同键的所有键值对都相邻.\n思考下关于计算文本语料库中的元音数量的问题. 我们可以使用MapReduce框架通过选择合适的map以及reduce函数来解决这个问题. map函数接受一个文本行作为输入并输出键值对, 键值对中元音作为键而值则是数量. 从输出中省略零计数:\n1 2 3 4 5 6  def count_vowels(line): \u0026#34;\u0026#34;\u0026#34;A map function that counts the vowels in a line.\u0026#34;\u0026#34;\u0026#34; for vowel in \u0026#39;aeiou\u0026#39;: count = line.count(vowel) if count \u0026gt; 0: emit(vowel, count)   reduce函数在Python中是内建的sum函数, 它以一个建立在值(对于给定键的所有值)之上的迭代器作为输入并返回它们的总数.\n4.7.2 本地实现 为了详述MapReduce应用, 我们需要实现一个可以让我们插入map以及reduce函数的MapReduce框架. 在接下来的部分中, 我们会使用开源的Hadoop实现. 在这一部分, 我们会使用Unix操作系统内建的工具开发一个最小实现.\nUnix操作系统在计算机的底层硬件以及用户程序中创建了一个抽象屏障. 它为程序相互之间的沟通提供了一个机制, 尤其是允许一个程序消耗另一个程序的输出, 在他们关于Unix编程精粹的文本中, Kernigham以及Pike宣称, \u0026ldquo;系统的能力更多地来自于程序之间的关系而不是程序本身.\u0026rdquo;\nPython文件可以通过在第一行添加一个注释来表明该程序应该使用Python3解析器执行来从而将其转换成Unix程序. Unix程序的输入是一个可迭代对象, 称之为_标准输入_并可通过sys.stdin来访问. 在这个对象之上访问会产生字符串值的文本行. Unix程序的输出被称为_标准输出_并可通过sys.stdout来访问. 内建的print函数写入一行文本到标准输出中. 下面的Unix程序将其输入的每一行的顺序反转后写入到其输出中:\n1 2 3 4 5 6  #!/usr/bin/env python3 import sys for line in sys.stdin: print(line.strip(\u0026#39;\\n\u0026#39;)[::-1])   如果我们保存这个程序到一个名为rev.py的文件中, 我们可以将它作为一个Unix程序来执行. 首先, 我们需要告诉操作系统我们已经创建了一个可执行程序:\n$ chmod u+x rev.py\n接下来, 我们将一些输入传输到这个程序中. 一个程序的输入可以来自于另一个程序. 要达到这个效果我们会使用|符号(称为\u0026quot;管道/pipe\u0026rdquo;), 它用来将位于管道之前的程序的输出用作位于管道之后的程序的输入. 程序nslookup输出IP地址的主机名称(这个例子中用的是纽约时报):\n1 2  $ nslookup 170.149.172.130 | ./rev.py moc.semityn.www   cat程序用于输出文件的内容. 因此, rev.py程序可以用来接收rev.py文件本身的内容:\n1 2 3 4 5 6 7  $ cat rev.py | ./rev.py 3nohtyp vne/nib/rsu/!# sys tropmi :nidts.sys ni enil rof )]1-::[)\u0026#39;n\\\u0026#39;(pirts.enil(tnirp   这些工具已经足够让我们实现一个基本的MapReduce框架. 这个版本只有单一的map任务以及单一的reduce任务, 它们都是用Python实现的Unix程序. 我们使用下面的命令来运行整个MapReduce应用:\n1  $ cat input | ./mapper.py | sort | ./reducer.py   mapper.py以及reducer.py程序必须实现map函数以及reduce函数, 以及一些简单的输入和输出行为. 例如, 为了实现上面说到的统计元音数量的程序, 我们会编写接下来的count_vowels_mappers.py程序:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  #!/usr/bin/env python3 import sys from mr import emit def count_vowels(line): \u0026#34;\u0026#34;\u0026#34;A map function that counts the vowels in a line.\u0026#34;\u0026#34;\u0026#34; for vowel in \u0026#39;aeiou\u0026#39;: count = line.count(vowel) if count \u0026gt; 0: emit(vowel, count) for line in sys.stdin: count_vowels(line)   此外, 我们还会编写下面的sum_reducer.py程序:\n1 2 3 4 5 6 7  #!/usr/bin/env python3 import sys from mr import values_by_key, emit for key, value_iterator in values_by_key(sys.stdin): emit(key, sum(value_iterator))   mr 模块是本文的配套模块, 它提供函数emit来发出键值对以及group_values_by_key来将具有相同键的值组合在一起. 这个模块还包括有MapReduce的Hadoop分布式实现的接口.\n最后, 假设我们有下面的输入文件叫做haiku.txt:\nGoogle MapReduce Is a Big Data framework For batch processing 使用Unix管道符来进行本地执行让我们可以知道每个句子中的元音数量:\n1 2 3 4 5 6  $ cat haiku.txt | ./count_vowels_mapper.py | sort | ./sum_reducer.py \u0026#39;a\u0026#39; 6 \u0026#39;e\u0026#39; 5 \u0026#39;i\u0026#39; 2 \u0026#39;o\u0026#39; 5 \u0026#39;u\u0026#39; 1   4.7.3 分布式实现 Hadoop是一个开源实现的MapReduce框架的名称, 这个框架在一组机器上执行MapReduce应用程序, 分发输入数据并计算有效的并行处理. 它的流接口允许任意的Unix程序去定义map以及reduce函数. 实际上, 我们的count_vowels_mappers.py以及sum_reducer.py可以直接使用Hadoop进行安装来计算大文本语料库上的元音数量.\nHadoop在我们简单的本地MapReduce实现上提供了几个优点. 首先是速度: map以及reduce函数是同时在不同任务, 不同的机器上并行调用的. 第二个是容错: 当任务因为任意原因而失败, 它的结果可以被其他任务来重新计算来完成整体计算. 第三个是监控: 框架提供一个用户接口来追踪MapReduce应用程序的进度.\n为了使用已提供的mapreduce.py模块来运行元音统计程序, 需要安装Hadoop, 修改HADOOP赋值语句为本地安装的根目录, 复制文本文件的集合到Hadoop的分布式文件系统, 然后运行:\n$ python3 mr.py run count_vowels_mapper.py sum_reducer.py [input] [output]\n这里的[input]以及[output]是Hadoop文件系统中的目录.\n想要获取更多关于Hadoop流接口的信息以及系统的使用方法, 可以参考Hadoop流文档.\n4.8 并行计算 从20世纪70年代到2000年代中期, 单个处理器内核的速度在以指数级增长. 这速度方面的增长大部分通过增加时钟频率来实现, 也就是处理器执行基本操作的速率. 然而在2000年代中期, 这种指数级增长由于功率和热限制突然之间就停止了, 同时从那时起单个处理器内核的速度的增长就慢得多了. 作为代替, CPU制造商开始在单个处理器上添加多个内核, 使更多的操作能够同时执行.\n并行性并不是一个新的概念, 大型的并行计算机器已经使用了几十年了, 其主要用于科学计算以及数据分析. 即使在具有单个处理器核心的个人电脑中, 操作系统以及解析器也提供了并发的抽象实现. 这是通过上下文切换来完成的, 或者快速切换不同任务, 无需等待完成. 因此, 多个程序可以同时在相同的机器上运行, 即使这个机器只有单个处理器核心.\n鉴于目前处理器核心数量增加的趋势, 现在的个人应用必须要利用并行性来运行得更快. 在单个程序中, 必须对计算进行安排来让尽可能多的工作并行完成. 然而, 并行性对编写正确的代码引入了新的挑战, 特别是存在共享的, 可变状态的情况下.\n这问题可以在函数式模型中有效地解决, 由于没有共享的可变状态, 并行性引入的问题就会少了很多. 纯函数提供了_透明的参考_, 这意味着表达式可以用它们的值代替而不影响程序的行为, 同时反过来也同样能够成立. 这使得可以并行运行不依赖于彼此的表达式. 如上一节所讲的, MapReduce框架允许程序员以最小的工夫来实现并行指定与运行函数式程序.\n不幸的是, 不是所有的问题都可以用函数式编程来有效地解决的. 伯克利的视觉项目已经确定了出现在科学和工程方面的十三种常见的计算模式, 其中只有一种是MapReduce类型的. 而剩余的模式都需要共享状态.\n在本节的其余部分, 我们将会看到可变共享状态是如何在并行程序中引入各种bug以及如何采取一些方法避免这些bug的出现. 我们将在两个应用程序的上下文中研究这些技术, 一个网络爬虫以及一个粒子模拟器.\n4.8.1 Python中的并行性 在我们更深入地了解并行性的细节之前, 让我们首先探讨下Python对并行计算的支持. Python提供两种并行执行的手段: 线程以及多进程.\n线程. 在线程中, 多个\u0026quot;线程\u0026quot;的执行存在于单个解析器中. 每个线程独立于其他的线程来执行代码, 虽然它们共享相同的数据. 然而, CPython解析器, Python解析器中的主要实现, 一次只能在一个线程中解释代码, 并在它们之间切换以提供并行性的错觉. 另一方面, 在解析器外部执行的操作, 例如等待文件或者访问网络, 也可能是并行运行的.\nthreading模块包含能够创建和同步线程的类. 下面是多线程程序的简单示例:\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; import threading \u0026gt;\u0026gt;\u0026gt; def thread_hello(): other = threading.Thread(target=thread_say_hello, args=()) other.start() thread_say_hello() \u0026gt;\u0026gt;\u0026gt; def thread_say_hello(): print(\u0026#39;hello from\u0026#39;, threading.current_thread().name) \u0026gt;\u0026gt;\u0026gt; thread_hello() hello from Thread-1 hello from MainThread   Thread构造器创建一个新的线程. 它需要一个目标函数来让新线程执行, 以及传输给函数的对应参数. 在Thread对象调用start来标记它已经准备好执行. current_thread函数返回与当前执行线程相关联的Thread对象.\n在这个例子中, 输出可以以任意顺序发生, 因为我们并没有以任何方式来同步它们.\n多进程. Python也可以支持_多进程_, 也就是允许程序产生多个解析器, 或者_进程_, 每个都可以独立执行代码. 这些进程通常不会共享数据, 因此任何共享状态必须在进程之间进行沟通. 另一方面, 进程的并行需要根据底层操作系统以及硬件提供的并行级别来执行. 因此, 如果CPU具有多个处理核心, Python进程可以真正地并发运行.\nmultiprocessing模块包含创建与同步进程的类. 下面就是使用进程的hello例子.\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; import multiprocessing \u0026gt;\u0026gt;\u0026gt; def process_hello(): other = multiprocessing.Process(target=process_say_hello, args=()) other.start() process_say_hello() \u0026gt;\u0026gt;\u0026gt; def process_say_hello(): print(\u0026#39;hello from\u0026#39;, multiprocessing.current_process().name) \u0026gt;\u0026gt;\u0026gt; process_hello() hello from MainProcess \u0026gt;\u0026gt;\u0026gt; hello from Process-1)   如本例所示, multiprocessing中的许多类以及函数都跟threading相似. 这个例子也演示了缺乏同步是如何影响共享状态的, 因为显示器可以被认为是共享状态. 这里, 来自交互进程的的解析器提示出现在其他进程打印的输出之前.\n4.8.2 共享状态的问题 为了说明共享状态的问题, 让我们来看一个简单的共享在两个线程之间的计数器的例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import threading from time import sleep counter = [0] def increment(): count = counter[0] sleep(0) # try to force a switch to the other thread counter[0] = count + 1 other = threading.Thread(target=increment, args=()) other.start() increment() print(\u0026#39;count is now: \u0026#39;, counter[0])   这是一个程序, 两个线程尝试去让同一个计数器加一. CPython解析器几乎可以在任何时间在线程之间进行切换. 只有最基本的操作是原子的, 这意味着它们的似乎是即刻发生的, 在它们运行或者执行期间是没有可能进行切换的. 增长计数器需要多个基本的操作: 读入旧的值, 对它进行加一, 然后写入新的值. 解析器可以在这些操作期间切换到任意的线程.\n为了去显示当解析器在不正确的时间点内切换了线程会发生什么, 我们试图通过停止0秒来强制执行切换. 当这个代码运行时, 解析器通常在线程调用sleep时进行切换. 这可能导致以下操作顺序:\nThread 0 Thread 1 read counter[0]: 0 read counter[0]: 0 calculate 0 + 1: 1 write 1 -\u0026gt; counter[0] calculate 0 + 1: 1 write 1 -\u0026gt; counter[0] 最终的结果是计数器得到的值是1, 即使它被增加了两次! 多么糟糕, 解析器可能很少在错误的时间进行切换, 这就导致了很难去调试. 即使是有调用sleep, 这个程序有时候也会产出正确的统计数2而有时候是错误的统计数1.\n这个问题只出现在共享数据存在可能在一个线程中进行改变的时候另一个线程又访问了它. 这样的冲突称为_竞争条件_, 这是一个仅存在于并行世界中的错误例子.\n为了避免竞争条件, 可能会被多个线程改变与访问的共享数据必须要被保护起来以拒绝同时访问. 例如, 如果我们可以确保线程1只在线程0访问完成后才访问计数器或者反过来, 我们就可以保证得出的结果是正确的. 如果共享数据在并发访问时是被保护的, 我们就可以说共享数据是同步的. 在接下来的几个小节中, 我们将会看到提供同步的多种机制.\n4.8.3 什么时候不同步是必要的 在某些情况下, 访问共享数据并不需要同步进行, 如果是并发访问的话则不能有导致错误的行为. 最简单的例子是只读数据. 由于这样的数据并不会突变, 因此所有的线程不管在什么时候访问数据都总是会读到相同的数据值.\n在极少数情况下, 突变的共享数据可能不需要同步. 然而, 在这种情况下需要深入了解解析器和底层软件与硬件的工作原理. 考虑下下面的例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  items = [] flag = [] def consume(): while not flag: pass print(\u0026#39;items is\u0026#39;, items) def produce(): consumer = threading.Thread(target=consume, args=()) consumer.start() for i in range(10): items.append(i) flag.append(\u0026#39;go\u0026#39;) produce()   在这里, producer线程添加元素到items里去, 而consumber等待直到flag非空为止. 当producer完成添加元素的工作后, 它添加一个元素到flag中, 允许consumer继续执行.\n在大多数Python的实现中, 这个例子会正确执行. 然而, 在其他的编译器以及解析器的常见优化中, 甚至是硬件本身, 都是在不依赖数据的单个线程中重新排序操作的. 在这样的一个系统中, 语句flag.append('go')可能会被移动到循环之前, 因为两者都不取决于其他数据. 一般来说, 你应该避免编写像这样的程序除非你确定基础系统不会重新排序相关操作.\n4.8.4 同步数据结构 共享数据的最简单的方法是去使用提供同步操作的数据结构. queue模块包含一个Queue类, 这个类提供先进先出的同步数据访问. put方法添加一个元素到Queue中, get方法检索一个元素. 类本身确保这些方法是同步的, 因此无论线程操作如何交错, 元素都不会丢失. 这里有一个使用Queue实现的生产者/消费者形式的例子.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  from queue import Queue queue = Queue() def synchronized_consume(): while True: print(\u0026#39;got an item:\u0026#39;, queue.get()) queue.task_done() def synchronized_produce(): consumer = threading.Thread(target=synchronized_consume, args=()) consumer.daemon = True consumer.start() for i in range(10): queue.put(i) queue.join() synchronized_produce()   除了Queue和get以及put调用之外, 还要对代码进行一些修改. 我们已经标记consumer线程作为守护进程, 也就意味着这个程序在退出之前不会等待线程的结束. 这允许我们在consumer中使用一个无限循环. 然而, 我们需要确保主线程能在所有项目都已从Queue消耗之后. consumer调用task_done方法来通知Queue处理一个项目, 并且主线程调用join方法, 该方法等待直到所有项目都被处理, 确保程序在此之后退出.\n一个更加复杂的使用Queue的例子是一个并行的web爬虫, 它用于搜索网站上的死链接. 这个爬虫会跟踪所有由相同网站托管的链接, 因此它必须处理一些URL, 不断地添加新的到Queue中并删除掉要处理的URL. 通过使用同步Queue, 多线程可以安全地同时从数据结构中添加以及移除数据.\n4.8.5 锁 当对特定数据的同步版本不可用时, 我们必须要提供自己的同步版本. _锁_是实现这样做的基础机制. 它最多可以被一个线程获取, 之后没有其他的线程可以获取它, 直到被先前获取的线程释放才可以.\n在Python中, threading模块包含Lock类来提供锁的功能. 一个Lock具有acquire以及release方法来获取以及释放锁, 同时类保证一次只有一个线程可以访问到它. 所有其他尝试去获取已经锁定的锁的线程都会被迫等待直到锁被释放.\n由于锁会保护特定集合的数据, 所有的线程都需要被编程为遵循以下规则: 没有线程会访问到任何的共享数据, 除非它具有特定的锁. 实际上, 所有线程在调用锁的acquire以及release时都需要包装它们对共享数据的操作.\n在并行的web爬虫中, 有一个set是用来保持追踪所有已经被其他线程遇到的URL的, 以便能够避免处理特定的URL次数多于一次(并可能陷入死循环)的情况. 然而, Python并没有提供一个同步的set, 因此我们必须使用锁来保护对正常set的访问:\n1 2 3 4 5 6 7 8 9 10 11  seen = set() seen_lock = threading.Lock() def already_seen(item): seen_lock.acquire() result = True if item not in seen: seen.add(item) result = False seen_lock.release() return result   在这里锁是必须的, 这是为了防止另一个线程在这个线程检查URL是否在当前的集合中以及添加URL到集合中的这段时间段里添加这个URL到集合中. 此外, 添加到集合的操作并不是原子的, 因此同时尝试添加到集合中可能会将内部数据损坏掉.\n在这段代码中, 我们必须要注意在我们释放掉锁之后才能返回. 一般来说, 我们需要确保在不需要锁的时候释放掉它. 这是非常容易出错的, 尤其是在有例外的情况下, 因此Python提供了with复合语句用于为我们处理获取以及释放锁的操作:\n1 2 3 4 5 6  def already_seen(item): with seen_lock: if item not in seen: seen.add(item) return False return True   with语句在执行内部语句之前确保seen_lock是能够获取到锁的并在内部语句以任何原因退出时释放掉锁. (with语句实际上可以被使用到锁定以外的操作, 尽管我们这里不会介绍其他的用途.)\n需要彼此同步的操作应该要用相同的锁. 然而, 需要与同一集合中的操作同步的两个不相交的操作集应该使用两个不同的锁定对象来避免过度同步.\n4.8.6 屏障 另一个避免共享数据访问冲突的方式是将程序分成一个个的阶段, 确保共享数据在没有其他线程能够访问它的阶段中进行突变操作. _屏障_将程序分成几个阶段, 要求所有线程中任意一个在可以执行后续过程之前先获取到这个数据. 在屏障之后执行的代码不能与屏障之前的代码并发执行.\n在Python中, threading模块以Barrier实例的wait方法的形式来提供一个屏障:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  counters = [0, 0] barrier = threading.Barrier(2) def count(thread_num, steps): for i in range(steps): other = counters[1 - thread_num] barrier.wait() # wait for reads to complete counters[thread_num] = other + 1 barrier.wait() # wait for writes to complete def threaded_count(steps): other = threading.Thread(target=count, args=(1, steps)) other.start() count(0, steps) print(\u0026#39;counters:\u0026#39;, counters) threaded_count(10)   在这个例子中, 读入以及写入共享数据发生在不同阶段, 通过屏障来分隔开. 写入发生在相同的阶段, 但它们是不相交的; 这种不相交对于避免同时在相同阶段写入相同数据是必须的. 由于此代码已正确同步, 因此两个计数器始终在最后为10.\n多线程粒子模拟器使用屏障以相似的方式来实现同步访问共享数据. 在模拟器中, 每个线程拥有一定量的粒子, 所有这些粒子都在许多离散时间步长的过程中相互交互. 粒子具有位置, 速度, 以及加速度, 以及在每个时间步长中基于其他粒子位置而计算出的新的加速度. 必须相应地更新颗粒的速度, 并根据其速度更新其位置.\n和上面的简单例子一样, 这里有一个读阶段, 其中所有例子的位置都被所有线程读取. 每个线程在此阶段更新自己的粒子的加速度, 但由于这些都是不相交的写操作, 因此它们不需要同步. 在写入阶段, 每个线程更新它自己的粒子的速度与位置. 再一次地, 这些是不相交的写操作, 同时它们受到阅读阶段的屏障的保护.\n4.8.7 消息传递 最后一种避免共享数据被不当修改的最终机制是完全地避免同时访问相同的数据. 在Python中, 使用多进程而不是使用多线程会自然地导致这一点, 因为进程在具有自己的数据的单独的解析器中运行. 多个进程所需的任何状态可以通过进程间传输消息来进行沟通.\n在multiprocessing模块中的Pipe类提供了一个进程之间的通讯渠道. 默认情况下, 它是双工的, 意味着是双向信道, 通过传入参数False来得到一个单向的信道. send方法在信道上发送一个对象, 而recv方法接收一个对象. 后者是_阻塞_的, 意味着一个进程调用recv方法之后会等待直到接收到一个对象.\n下面的是使用进程以及管道的生产者/消费者的例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def process_consume(in_pipe): while True: item = in_pipe.recv() if item is None: return print(\u0026#39;got an item:\u0026#39;, item) def process_produce(): pipe = multiprocessing.Pipe(False) consumer = multiprocessing.Process(target=process_consume, args=(pipe[0],)) consumer.start() for i in range(10): pipe[1].send(i) pipe[1].send(None) # done signal process_produce()   在这个例子中, 我们只用None消息来标记通信的结束. 在创建消费者进程时, 我们也在传入管道的一端, 将其作为参数传给目标函. 这是必须的, 因为必须要在进程间共享状态.\n多进程版本的粒子模拟器使用管道在每个时间步长中在进程间对粒子的位置进行沟通. 实际上, 使用管道在进程之间建立一个完整的轮流, 为了最小化通信. 每个进程将自己粒子的位置注入到它的管道传递阶段. 最终通过流水线来完成轮流. 在这个回旋的每个步骤中, 一个进程将力量从当前处于其自身流水线阶段的位置应用到其自身的粒子上, 因此在整完成整个轮流之后, 所有的力已经被应用到它的粒子上.\nmultiprocessing模块提供其他的过程同步机制, 包括同步队列, 锁, 以及Python3.3中的屏障. 例如, 一个锁或者一个屏障可以被用来同步打印到屏幕中, 避免了我们以前看到的不正确的显示输出.\n4.8.8 同步陷阱 虽然同步方法对保护共享数据是有效的, 但是它们也会被不正确使用, 未能完成正确的同步, 过同步, 或者导致程序挂起的死锁的结果.\n在同步, 一个常见的并行计算的陷阱是忽略正确的同步共享访问. 在集合的例子中, 我们需要将成员资格检查以及插入同步在一起, 因此其他线程不可以在这两个操作之间执行插入. 未能将这两个操作同步在一起是一个错误, 即使它们是单独同步的.\n过同步, 另一种常见的错误是过度同步程序, 使得不冲突的操作不能同时发生. 作为一个简单的例子, 我们可以通过在线程启动时获取主锁而在线程完成时释放主锁来避免对共享数据的所有冲突访问. 这会使得我们的代码序列化, 因此没有任何部分可以并行运行. 在某些情况下, 这甚至会导致我们的程序无限期挂起. 例如, 思考下生产者/消费者程序中消费者获取到锁同时永不释放它. 这阻止了生产者生产任何产品, 反过来也阻止了消费者去做任何事情因为它没有东西可以进行消费.\n虽然这个例子很微不足道, 但是在实际生产中, 程序员常常在一定程度上过度同步他们的代码, 阻止他们的代码充分利用可用的并行性.\n死锁. 因为它们会导致线程或者进程彼此等待, 同步机制容易受到_死锁_的影响, 这种情况是两个或多个线程或进程卡住了, 等待彼此之间结束运行. 我们刚刚已经看到忽略释放锁可能导致线程无限期卡住. 但即使是线程或进程正确释放锁, 程序仍然会遇到死锁.\n死锁来源于_循环等待_, 如下图所示. 没有一个过程可以继续执行, 因为一个过程在等待其他在等待另一个过程结束的等待这个过程结束的过程.\n作为例子, 我们会建立两个进程的死锁. 假设它们共享双工信道并尝试相互通信, 如下所示:\n1 2 3 4 5 6 7 8 9 10 11 12  def deadlock(in_pipe, out_pipe): item = in_pipe.recv() print(\u0026#39;got an item:\u0026#39;, item) out_pipe.send(item + 1) def create_deadlock(): pipe = multiprocessing.Pipe() other = multiprocessing.Process(target=deadlock, args=(pipe[0], pipe[1])) other.start() deadlock(pipe[1], pipe[0]) create_deadlock()   两个进程都尝试第一时间接收到数据. 回想一下前面说到recv方法阻塞直到接收到一个可用项目. 由于任何进程都没有发送任何内容, 所以两者都将无限期等待另一个发送数据, 因此导致死锁.\n同步操作必须要正确对齐以避免死锁. 这可能需要在接收之前通过管道发送, 以相同的顺序接收获取多个锁, 并确保所有线程在正确的时间到达正确的屏障.\n4.8.9 总结 正如我们看到的, 并行性在编写正确和有效的代码方面提出了新的挑战. 由于在可遇见的将来硬件层面上的并行性将会不断增加, 并行计算在应用程序编程中将变得越来越重要. 有一个非常活跃的研究机构, 使并行性更容易, 程序员更少出错. 我们在这里的讨论只是对这个关键的计算机科学领域的基础介绍.\n《程序构成》来自于John DeNero基于由Harold Abelson以及Gerald Jay Sussman撰写的教科书计算机程序的结构和解释. 基于共享协议: `Creative Commons Attribution-ShareAlike 3.0 Unported License.'\n","description":"","id":3,"section":"posts","tags":["译文","Design Programs"],"title":"程序构成-第四章","uri":"https://jmwill.github.io/blog/2017/06/11/%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"},{"content":"第三章: 解析计算机程序 3.1 介绍 章节1以及2描述了两个程序的基本要素之间的紧密联系: 函数以及数据. 我们已经见识过函数是如何在高阶函数中被当做数据来操作. 我们也见识过数据是如何通过消息传递以及一个对象系统而被赋予行为的. 我们也学习了用来组织大型程序的技术, 例如函数抽象, 数据抽象, 类继承, 以及一般函数. 这些关键概念构成了建立模块化, 可维护, 可扩展的程序的坚实基础.\n本章节专注于编程的第三个基本要素: 程序本身. 一个Python程序只是一个文本的集合. 只有经过解析的过程我们才能基于该文本执行任何有意义的计算. 像Python这样的语言很有用, 因为我们可以定义一个_解析器_, 这是一个可以处理Python的运算以及执行过程的程序. 把这认为是编程的基本思想是毫不夸张的, 一个解析器它能确定表达式在编程语言中的含义, 它本身也就仅仅是另一个程序而已.\n要体会到这一点需要转变我们自己作为程序员的印象. 我们要将自己看做是语言的设计者, 而不仅仅是经由其他人设计的语言的使用者.\n3.1.1 编程语言在它们的句法结构，特征和应用领域都变化很大. 在通用的编程语言之中, 函数定义以及函数应用的结构是普遍存在的. 另一方面, 存在强大的语言, 它并不包括对象系统, 高阶函数, 赋值, 甚至是控制结构如while以及for语句. 以具有这些特性的最小子集的强大的语言作为例子, 我们将会介绍Scheme编程语言, 在本文中介绍的Scheme的子集不允许可变值.\n在这个章节中, 我们学习设计一个解析器以及当它们执行程序时创建的计算过程. 为一个通用编程语言设计一个解析器的景愿可能看起来是令人畏惧的. 然而, 许多解析器具有优雅的共同结构: 两个相互递归函数. 第一个在环境中执行表达式; 第二个则是将函数作为参数来进行应用.\n这些函数都是递归的, 因为它们是相互定义的: 应用一个函数需要执行它内部的表达式, 而执行一个表达式可能涉及到调用一个或者更多个函数.\n3.2 函数式编程 在任何现代计算机上运行的软件都是由各种各样的编程语言编写的. 有物理语言, 如针对特定的计算机的机器语言. 这些语言关注数据的表示以及根据各个位来控制存储以及原始计算机指令. 而机器语言编程员关心的是用给定的硬件来构建系统以及在资源有限的计算机上使得实用程序能高效实施. 高阶语言, 架设在机器语言的基础上, 隐藏对数据表示为位的集合以及程序作为一系列原始计算机指令的表示的关注. 这些语言具有组合以及抽象的手段, 比如函数定义, 这适用于大规模组织的软件系统.\n在这一章节中, 我们要介绍一种鼓励函数式风格的高阶编程语言, 我们学习的对象是Scheme语言的子集, 它使用的计算模型根Python的很相似, 但只使用表达式(没有声明), 专注于符号运算, 同时只使用不可变数据.\nScheme是Lisp的一种方言, 是第二古老的编程语言(在Fortran之后), 它直到今天仍然被广泛地使用. Lisp程序员社区已经持续存在成长了几十年了, 同时新的Lisp的方言比如Clojure具有一些跟现代编程语言一样增长最快的编程员社区. 为了跟上本文的例子, 你可以下载一个Scheme编辑器.\n3.2.1 表达式 Scheme程序由表达式组成, 也叫做表达式或者特殊形式. 一个可调用的表达式由一个操作符表达式伴随着零或多个操作数子表达式组成, 就像Python那样. 操作数以及操作符都是包含在括号中:\n1 2  (quotient 10 2) 5   Scheme只使用前缀符号. 操作符通常是一个符号, 例如+以及*. 调用表达式可以是嵌套的, 同时它们可能会跨越超过一行.\n1 2 3 4 5 6 7 8  (+ (* 3 5) (- 10 6)) 19 (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) 57   跟在Python中那样, Scheme表达式可以是原语或者是组合. 数字文字是原语, 而调用表达式是组合形式其内包含任意子表达式. 调用表达式执行程序跟吻合Python的这些地方: 首先操作符以及操作数表达式被执行, 然后将作为运算符的值的函数应用于作为操作数的值的自变量.\n在Scheme中的if表达式是一种特殊形式, 意味着虽然它看起来在句法上像是一个调用表达式, 但是它具有不同的执行过程. if表达式的一般形式是:\n1  (if \u0026lt;predicate\u0026gt; \u0026lt;consequent\u0026gt; \u0026lt;alternative\u0026gt;)   为了执行一个if表达式, 解析器会开始于执行表达式的\u0026lt;predicate\u0026gt;的部分. 如果\u0026lt;predicate\u0026gt;运行后得到真值, 解析器之后就会执行\u0026lt;consequent\u0026gt;部分然后返回它的值. 否则它会执行\u0026lt;alternative\u0026gt;并返回它的值.\n数值可以用熟悉的比较操作符来进行比较, 但是前缀符号也一样被用在这个例子中:\n1 2  (\u0026gt;= 2 1) true   布尔值#t(或者真)以及#f(或者假)在Scheme中可以以特殊的布尔形式来进行组合, 也具有跟Python类似的运行过程.\n  (and \u0026lt;e1\u0026gt;...\u0026lt;en\u0026gt;) 解析器一次执行一个表达式\u0026lt;e\u0026gt;, 以从左到右的顺序, 如果任何一个\u0026lt;e\u0026gt;执行的结果为假, 那么and表达式的结果就为假, 而剩下的\u0026lt;e\u0026gt;表达式都不会执行, 如果所有的\u0026lt;e\u0026gt;执行的值都为真, 那么and表达式的值就为最后一个(表达式)的值. (or \u0026lt;e1\u0026gt;...\u0026lt;en\u0026gt;) 解析器一次执行一个表达式\u0026lt;e\u0026gt;, 以从左到右的顺序, 如果任何\u0026lt;e\u0026gt;执行得到的值为真值, 那么这个值就会作为or表达式的值被返回, 而剩下的\u0026lt;e\u0026gt;表达式不会执行. 如果所有的\u0026lt;e\u0026gt;执行都得到假值, 那么or表达式的值就为false. (not \u0026lt;e\u0026gt;) 当\u0026lt;e\u0026gt;执行为假时not表达式的值为真, 否则的话就为假.   3.2.2 定义 值可以用define这种特殊形式来进行命名:\n1 2 3  (define pi 3.14) (* pi 2) 6.28   新的函数(在Scheme中称为过程)可以使用define的第二个特殊形式的版本来定义. 例如, 定义一个平方, 我们编写:\n1  (define (square e) ( * x x))   过程定义的一般形式是:\n1  (define (\u0026lt;name\u0026gt; \u0026lt;formal parameters\u0026gt;) \u0026lt;body\u0026gt;)   \u0026lt;name\u0026gt;是一个跟在环境中定义的过程相关联的符号. \u0026lt;formal parameters\u0026gt;是用在过程内部的各个名称, 这些名称与过程中的参数相对应. \u0026lt;body\u0026gt;是一个表达式, 当形式参数被实际参数替换来进行调用时它会返回过程调用后的值. \u0026lt;name\u0026gt;以及\u0026lt;formal parameters\u0026gt;以括号为分组, 就像对被定义的过程进行实际调用一样.\n有了平方的定义之后, 我们现在可以在调用表达式中使用它.\n1 2 3 4 5 6 7 8  (square 21) 441 (square (+ 2 5)) 49 (square (square 3)) 81   用户定义的函数可以接受多个参数以及包含特殊形式:\n1 2 3 4 5 6 7 8 9 10 11 12 13  (define (average x y) (/ (+ x y) 2)) (average 1 3) 2 (define (abs x) (if (\u0026lt; x 0) (- x) x)) (abs -3) 3   Scheme支持具有与Python相同的词法作用域规则的本地定义. 下面, 我们使用嵌套定义以及递归来定义一个迭代过程去计算平方根:\n1 2 3 4 5 6 7 8 9 10 11 12  (define (sqrt x) (define (good-enough? guess) (\u0026lt; (abs (- (square guess) x)) 0.001)) (define (improve guess) (average guess (/ x guess))) (define (sqrt-iter guess) (if (good-enough? guess) guess (sqrt-iter (improve guess)))) (sqrt-iter 1.0)) (sqrt 9) 3.00009155413138   匿名函数是使用lambda特殊形式来创建的, lambda是用来创建过程的方式跟define一样, 除了不需要为过程指定名称:\n1  (lambda (\u0026lt;formal-parameters\u0026gt;) \u0026lt;body\u0026gt;)   这种结果过程跟用define创建过程用得一样多. 唯一的不同是它没有跟环境中的任何一个名称相关联. 实际上, 下面的表达式是一样的:\n1 2  (define (plus4 x) (+ x 4)) (define plus4 (lambda (x) (+ x 4)))   就像任何具有过程作为它的值的表达式一样, 一个lambda表达式可以在调用表达式内用作一个操作符:\n1 2  ((lambda (x y z) (+ x y (square z))) 1 2 3) 12   3.2.3 复合值 数据对在Scheme中是内建的. 由于一些历史原因, 数据对是由cons这个内建函数来创建的, 同时通过car以及cdr来访问数据对中的元素:\n1 2 3 4 5 6 7 8 9 10  (define x (cons 1 2)) x (1 . 2) (car x) 1 (cdr x) 2   递归列表同时也使用数据对来内建到了语言当中. 一个特殊的值, 其表示为nil或者'()表示一个空的列表. 一个递归列表的值是通过放置它的元素到括号内, 并以空格分隔渲染得到的:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  (cons 1 (cons 2 (cons 3 (cons 4 nil)))) (1 2 3 4) (list 1 2 3 4) (1 2 3 4) (define one-through-four (list 1 2 3 4)) (car one-through-four) 1 (cdr one-through-four) (2 3 4) (car (cdr one-through-four)) 2 (cons 10 one-through-four) (10 1 2 3 4) (cons 5 one-through-four) (5 1 2 3 4)   一个列表是否是空的可以使用原语null?来判断. 使用它, 我们可以为计算length以及选择元素来定义标准的序列操作:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  (define (length items) (if (null? items) 0 (+ 1 (length (cdr items))))) (define (getitem items n) (if (= n 0) (car items) (getitem (cdr items) (- n 1)))) (define squares (list 1 4 9 16 25)) (length squares) 5 (getitem squares 3) 16   3.2.4 符号数据 到目前为止我们使用的所有的组合数据对象最终都是由数字来组成的. Scheme的一个强项是与作为抽象符号的数据进行工作.\n为了去操作符号我们的语言需要一个新的元素: 能对数据对象进行引用. 假设我们想要构造一个列表(a, b). 我们不可以通过(list a b)这样来进行构造, 因为这个表达式会构造一个具有值为a跟b的列表而不是符号a跟b本身. 在Scheme中, 我们通过在符号a以及b的前面加上一个单引号来引用符号a以及b而不是它们的值.\n1 2 3 4 5 6 7 8 9 10 11  (define a 1) (define b 2) (list a b) (1 2) (list \u0026#39;a \u0026#39;b) (a b) (list \u0026#39;a b) (a 2)   在Scheme中, 任何为运行的表达式都被称为引用. 这种引用概念派生自经典哲学中事物之间的区分, 例如一个狗, 它在跑动并吠叫, 同时\u0026quot;狗\u0026quot;这个名称是一个用来指定这样的事物的语言结构. 当我们用引号来使用\u0026quot;狗\u0026quot;这个名称时, 我们不是在引用某个特定的狗而是这个字本身. 在语言层面上, 引号允许我们谈及语言本身, 因此它在Scheme中是这样的:\n1 2  (list \u0026#39;define \u0026#39;list) (define list)   引号同样允许我们去输入一个复合对象, 使用列表的常规打印表示:\n1 2 3 4 5  (car \u0026#39;(a b c)) a (cdr \u0026#39;(a b c)) (b c)   完整的Scheme语言包含其他的特性, 例如可变操作, 向量以及映射等. 然而, 到目前为止我们介绍了的子集已经提供给我们丰富的函数式编程语言的能力来实现许多到目前为止在本文中讨论的想法.\n3.2.5 龟图 本章节中, 龟形图作为Scheme的伴随实现, 来说明作为图标开发语言(另一种Lisp方言)的一部分开发环境. 这个龟开始于画布的中间, 根据程序来进行移动以及转动, 同时随着它的移动来进行画线. 虽然发明这个龟图只是用来让儿童参与编程行为, 但是它对于高级程序员来说依然是一个引人入胜的图形工具.\n在课程当中的任何时候执行的Scheme程序, 这个龟都在画布中具有一个位置以及标题. 单一参数程序例如, forward以及right会修改龟的位置以及标题. 通用的程序具有缩写: forward也可以被叫做fd, 等等. 在Scheme中的特殊形式的begin允许单一表达式来包含多个子表达式. 这种形式对于多个命令的发出是有用的:\n1 2 3 4 5 6 7 8 9 10  \u0026gt; (define (repeat k fn) (if (\u0026gt; k 0) (begin (fn) (repeat (- k 1) fn)) nil)) \u0026gt; (repeat 5 (lambda () (fd 100) (repeat 5 (lambda () (fd 20) (rt 144))) (rt 144))) nil   龟程序的完整曲目同样也作为龟型库模块内建在了Python中.\n作为最后的一个例子. Scheme可以通过以一种异常紧凑的形式来使用它的龟图表现出递归绘图. 谢尔宾斯基三角形是一种分形, 通过将每个三角形绘制为三个相邻的三角形同时在包含它们的三角形的底部的中点处具有顶点. 这可以通过Scheme程序来绘画一个有限的递归深度的图形:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026gt; (define (repeat k fn) (if (\u0026gt; k 0) (begin (fn) (repeat (- k 1) fn)) nil)) \u0026gt; (define (tri fn) (repeat 3 (lambda () (fn) (lt 120)))) \u0026gt; (define (sier d k) (tri (lambda () (if (= k 1) (fd d) (leg d k))))) \u0026gt; (define (leg d k) (sier (/ d 2) (- k 1)) (penup) (fd d) (pendown))   trangle过程是一个一般方法来重复绘画某个过程三次并在每次重复中进行左转. sier过程需要一个长度d以及一个递归深度k. 如果深度是1它会绘画一个空的三角形, 否则会绘画一个通过调用leg组成的三角形. leg过程会通过调用sier方法填充前一半的腿部的长度来为谢尔宾斯基三角形绘画一个单一的腿部, 然后通过移动龟图到下一个顶点. 程序penup以及pendown通过举起笔来进行移动并放下来实现停止绘画的过程. sier以及leg的相互递归调用的过程返回了它的结果:\n1  \u0026gt; (sier 400 6)   3.3 异常 程序必须总是要注意那些可能会出现在里面的错误. 其中的例子比比皆是: 一个函数可能没有接收到参数, 但是它的设计是需要接收的, 一个必要的资源可能缺失了, 或者一个跨网络的连接可能丢失了. 当设计一个程序, 我们必须要去预见例外的情况, 这些情况可能会出现并需要适当的措施来处理它们.\n这里没有唯一一个正确的方法来处理程序中出现的错误. 程序设计来提供一些持久服务比如网络服务器对于错误处理应该是强健的, 能够记录他们以作后续考虑, 同时尽可能长地继续服务新的请求. 另一方面, Python解析器通过立即终止并打印一个错误信息来处理错误, 因此程序员能够在问题出现时立即解决问题. 在任何情况下, 程序员必须对他们的程序应该如何对错误情况作出反应而作出合理的选择.\n异常, 是本章的主题, 提供一个一般机制来添加错误处理逻辑到程序里面. 引发异常是一个用来打断程序正常执行流程的技术, 用来表明有异常情况, 并直接返回到程序的被指定对这种情况作出反应的封闭部分. Python解析器每次在一个表达式或者声明中检测到一个错误时都会抛出一个异常. 用户也可以用raise以及assert声明来抛出异常.\n抛出异常. 每个异常都是一个继承自BaseException类的对象实例, 可能是直接继承或者间接继承. 在第一章介绍的assert声明抛出一个类型为AssertionError的异常. 一般情况下, 任何异常实例都可以用raise声明来抛出. 抛出异常的一般形式在Python文档中有描述. 最常见的是使用raise构造出一个异常实例并抛出它.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt;　raise Exception(\u0026#39;An error occurred\u0026#39;); Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; Exception: an error occurred   当一个异常被抛出, 在当前代码块中将不再执行其他语句. 除非这个异常能够被处理(在下面会描述), 解析器会直接返回到解析器的交互式读写循环中, 或者如果Python是以文件参数启动的将会直接终止. 此外, 解析器会打印一个堆栈回溯, 就是一个描述异常抛出时正在执行的函数调用分支的嵌套集的文本结构块, 在上面的例子中, 文件名\u0026lt;stdin\u0026gt;表示异常通过在交互式会话中的用户被抛出而不是从文件的代码中被抛出.\n处理异常. 一个异常可以通过封闭在一个try声明中被处理. 一个try声明由多个条款组成; 首先以try开始然后其他的以except开始:\n1 2 3 4 5  try: \u0026lt;try suite\u0026gt; except \u0026lt;exception class\u0026gt; as \u0026lt;name\u0026gt;: \u0026lt;except suite\u0026gt; ...   \u0026lt;try suite\u0026gt;在执行到try声明时总是马上执行. except条目部分则只在执行\u0026lt;try suite\u0026gt;过程当中有错误被抛出时才会执行. 没一个except语句条目指定了对特殊的异常类型来进行处理. 比如, 如果\u0026lt;exception class\u0026gt;是AssertionError, 那么任何继承自AssertionError的类在执行\u0026lt;try suite\u0026gt;项的过程当中被抛出都会被接下来的\u0026lt;except suite\u0026gt;处理. 在\u0026lt;except suite\u0026gt;内部, 识别器\u0026lt;name\u0026gt;是绑定到被抛出的异常处理对象上的, 但是这个绑定范围并不会超出\u0026lt;except suite\u0026gt;.\n例如, 我们可以通过使用try声明来处理ZeroDivisionError异常, 当有异常被抛出时在异常处理里面把名称x绑定为0.\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; try: x = 1/0 except ZeroDivisionError as e: print(\u0026#39;handling a\u0026#39;, type(e)) x = 0 handling a \u0026lt;class \u0026#39;ZeroDivisionError\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x 0   一个try声明会处理发生在它的\u0026lt;try suite\u0026gt;里面应用的函数的函数体内的异常(不管是直接的还是间接的). 当一个异常被抛出, 控制流直接跳到距离try最近的能处理这种类型异常的\u0026lt;except suite\u0026gt;内部来.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026gt;\u0026gt;\u0026gt; def invert(x): result = 1/x # Raises a ZeroDivisionError if x is 0 print(\u0026#39;Never printed if x is 0\u0026#39;) return result \u0026gt;\u0026gt;\u0026gt; def invert_safe(x): try: return invert(x) except ZeroDivisionError as e: return str(e) \u0026gt;\u0026gt;\u0026gt; invert_safe(2) Never printed if x is 0 0.5 \u0026gt;\u0026gt;\u0026gt; invert_safe(0) \u0026#39;division by zero\u0026#39;   这个例子说明在invert里面发生异常时的print表达式未被执行, 相反控制流被转移到except项的invert_safe里面去. 并迫使ZeroDivisionError e异常通过invert_safe函数的返回变成一个人类可读的字符串: `'division by zero\u0026rsquo;.\n3.3.1 异常对象 异常对象本身可以具有属性, 例如在一个assert中的错误消息状态以及关于异常被抛出时函数执行到哪里的信息. 用户定义的异常可以有额外的属性.\n在第一章, 我们实现了牛顿方法来为任意函数找到零点. 接下来的例子定义了一个异常类型, 这个类型会在任何ValueError发生的时候返回在迭代改进过程当中的最佳猜测值. 当sqrt被应用到一个负数上时会抛出数学领域的错误(类型为ValueError). 这个异常会通过抛出一个IterImproveError来保存得自于牛顿法的最近的值为一个属性.\n首先, 我们定义一个新的继承自Exception的类.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; class IterImproveError(Exception): def __init__(self, last_guess): self.last_guess = last_guess   接下来, 我们定义一个improve通用迭代改进算法的改进版. 这个版本能处理任意的ValueError通过抛出一个IterImproveError来保存最近的猜测值. 像之前, improve以两个函数作为参数, 没个函数取单个数字作为参数. update函数返回新的猜测值, 而done函数返回一个布尔值表明改进已经覆盖为正确的值.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; def improve(update, done, guess=1, max_updates=1000): k = 0 try: while not done(guess) and k \u0026lt; max_updates: guess = update(guess) k = k + 1 return guess except ValueError: raise IterImproveError(guess)   最后, 我们定义find_zero函数, 它会返回improve函数应用的结果到在第一章定义的在这个例子中无需修改的牛顿更新函数newton_update上. find_zero版本的函数通过返回它的最新的猜测值来处理IterImproveError.\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; def find_zero(f, guess=1): def done(x): return f(x) == 0 try: return improve(newton_update(f), done, guess) except IterImproveError as e: return e.last_guess   考虑一下应用find_zero来查找函数$2x^2 + \\sqrt{x}$的零点. 这个函数在0处具有零点, 但是执行它在任意负数上会抛出一个ValueError. 我们第一章实现的牛顿法会抛出这个错误并不会返回任何关于零点的猜测值. 我们修订之前的实现来返回出现错误之前的猜测值.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; from math import sqrt \u0026gt;\u0026gt;\u0026gt; find_zero(lambda x: 2 * x * x + sqrt(x)) -0.030211203830201594   虽然这个近似值距离正确的答案0依然很远, 但是一些应用会更喜欢这个粗略的近似值而不是ValueError.\n异常是另一种用来帮助我们将程序的关注点分解为模块化部件组成的程序的技术. 在本例中, Python的异常机制允许我们分离迭代改进的逻辑, 原有的在try子句中的语句看起来并没有变化, 而处理错误的逻辑将出现在except语句中. 我们也会发现异常在用Python实现解析器的时候会是一个有用的特性.\n3.4 组合语言的解析器 现在我们正在展开用一门语言来构建另一门语言的技术之旅上. 元语言抽象-建立新语言-在工程设计的所有分支上扮演着一个重要的角色. 而它对计算机编程尤为重要, 因为在程序设计中我们不仅能够定制新的语言, 还可以构建这些语言所需要的编译器. 一个语言的编译器是一个函数, 当应用这个函数到这个语言的表达式时, 执行的操作需要通过执行这些表达式来确定.\n我们首先会为Scheme语言的一个有限子集定义一个解析器, 称它为计算器. 然后, 我们会为Scheme整体开发一个素描的编译器. 我们创建的编译器在某种意义上是完备的, 它允许我们编写能充分在Scheme上执行的程序. 为此, 它会为执行我们在第一章介绍的Python程序而实现相同的环境模型.\n在本节中的许多模型都包含在同版的Scheme语法计算器例子中, 但是它们太复杂, 无法适应本文的格式.\n3.4.1 一个Scheme语法的计算器 Scheme语法的计算器(或者简单计算器)是一种算术操作的表达语言, 用来表达加法, 减法, 乘法, 以及除法. 计算器共享Scheme的调用表达式语法以及操作行为. 加法(+)以及乘法(*)操作两者都接收任意数量的参数:\n1 2 3 4 5 6 7 8  \u0026gt; (+ 1 2 3 4) 10 \u0026gt; (+) 0 \u0026gt; (* 1 2 3 4) 24 \u0026gt; (*) 1   减法(-)具有两种行为. 当只有一个参数的时候, 它将参数变成对应的相反数. 最少具有两个参数时, 它以第一个开始减去后续所有的数. 除法(/)具有相似的两个行为: 计算单个参数的乘法逆运算或者以第一个参数开始除以后续的所有参数:\n1 2 3 4 5 6 7 8 9 10  \u0026gt; (- 10 1 2 3) 4 \u0026gt; (- 3) -3 \u0026gt; (/ 15 12) 1.25 \u0026gt; (/ 30 5 2) 3 \u0026gt; (/ 10) 0.1   调用一个表达式就是通过执行它的操作数的子表达式然后应用操作符到得到的结果上来执行的:\n1 2  \u0026gt; (- 100 (* 7 (+ 8 (/ -12 -3)))) 16.0   我们会在Python中实现一个计算器语言的解析器. 也就是我们会编写一个Python程序, 它会接受多行字符串然后返回把这些行当作计算器表达式来执行的结果. 如果计算器表达式不具有恰当的形式我们的解析器会抛出一个适当的异常.\n3.4.2 表达式树 直到这一点之前的课程里, 表达式树一直都是概念上的实体也就是我们之前提到的对计算过程的描述; 我们此前从来没有在我们的程序中将表达式树作为数据来进行表示. 为了去编写一个解析器, 我们必须要将表达式作为数据来进行操作.\n一个原始的表达式就仅仅是一个在计算器中的数字或者字符串: 要们是一个int或者float或者是一个操作符号. 所有的组合的表达式都叫做表达式. 一个调用表达式是一个Scheme列表, 这个列表的第一个元素(也就是操作符)后面会接有零个或更多的操作数表达式\nScheme对. 在Scheme中, 列表就是嵌套的数据对, 但是并不是所有的对都是列表. 为了要在Python中表示Scheme中的数据对以及列表, 我们会定义一个Pair类, 这个类跟前面章节中的Rlist类十分相似. 这个实现出现在scheme_reader.\n空的列表通过用一个叫做nil的对象来表示, 这个对象是nil类的实例. 我们假设有且只有一个nil实例会被创建.\nPair类以及nil对象都是Scheme值在Python中的表示. 它们具有repr这种以Python表达式形式表示的字符串以及str这种以Scheme表达式形式表示的字符串.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; s = Pair(1, Pair(2, nil)) \u0026gt;\u0026gt;\u0026gt; s Pair(1, Pair(2, nil)) \u0026gt;\u0026gt;\u0026gt; print(s) (1 2)   它们实现了基础的Python序列接口包括长度和元素选择以及一个返回Scheme列表的map方法.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; len(s) 2 \u0026gt;\u0026gt;\u0026gt; s[1] 2 \u0026gt;\u0026gt;\u0026gt; print(s.map(lambda x: x+4)) (5 6)   嵌套列表. 嵌套对可以表示一个列表, 但是列表中的元素也可以是列表本身. 因此, 对已经足够用来表示Scheme中的表达式, 它实际上就是嵌套列表.\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; expr = Pair(\u0026#39;+\u0026#39;, Pair(Pair(\u0026#39;*\u0026#39;, Pair(3, Pair(4, nil))), Pair(5, nil))) \u0026gt;\u0026gt;\u0026gt; print(expr) (+ (* 3 4) 5) \u0026gt;\u0026gt;\u0026gt; print(expr.second.first) (* 3 4) \u0026gt;\u0026gt;\u0026gt; expr.second.first.second.first 3   这个例子表明所有的计算器表达式都是嵌套的Scheme列表. 我们的计算器解析器会读入一个嵌套的Scheme列表, 转换它们为表达式树表示为嵌套对实例(在下面的解析表达式一节中), 然后计算表达式树产出值(下面的执行计算器一节).\n3.4.3 解析表达式 解析是从原有输入文本生成表达式树的一个过程. 一个解析器是由两个部分组成的: 一个词法分析器以及一个句法分析器. 首先, 词法分析器将输入的字符串划分成标记, 这标记是这个语言的最小句法单元如名称以及符号. 其次, 句法分析器从这一标记组成的序列中构造一个表达式树. 这个由词法分析器产生的标记序列由句法序列来消耗.\n词法分析. 解析字符串的为标记序列的部分称之为标记器或者词法分析器. 在我们的实现中, 标记器是一个在scheme_tokens中被称为tokenize_line的函数. Scheme标记由空格, 括号, 点或者单引号来进行划分. 分隔符本身也是标记, 符号也数字也是如此. 标记器一个字符接着一个字符地分析一行文本, 验证符号和数字的格式.\n符号化一个形式良好的计算器表达式直接划分所有的符号和分隔符, 但是需要识别多字符数字(如: 2.3)以及转换它们为数字类型.\n1 2  \u0026gt;\u0026gt;\u0026gt; tokenize_line(\u0026#39;(+ 1 (* 2.3 45))\u0026#39;) [\u0026#39;(\u0026#39;, \u0026#39;+\u0026#39;, 1, \u0026#39;(\u0026#39;, \u0026#39;*\u0026#39;, 2.3, 45, \u0026#39;)\u0026#39;, \u0026#39;)\u0026#39;]   词法分析是一个迭代过程, 它可以应用到没一行处于隔离状态的程序输入上.\n句法分析. 翻译标记序列为一个表达式树被称为_句法分析_. 句法分析是一个树递归过程. 同时它必须考虑整个表达式有可能会跨越多行.\n句法分析是通过scheme_reader中的scheme_read函数来实现的. 它是树递归形式的因为分析一个标记序列通常涉及到将这些标记的子序列分析为子表达式, 它本身也一个更大的表达式树的一个分支(比如: 操作数). 递归生成的层次结构最终由运算器来消耗.\nscheme_read函数预期它的输入项src是一个Buffer类型的实例, 提供权限来访问标记序列. Buffer是定义在buffer模块里面, 收集跨越多行的标记到单个的可以被语法分析的对象里面去.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; lines = [\u0026#39;(+ 1\u0026#39;, \u0026#39; (* 2.3 45))\u0026#39;] \u0026gt;\u0026gt;\u0026gt; expression = scheme_read(Buffer(tokenize_lines(lines))) \u0026gt;\u0026gt;\u0026gt; expression Pair(\u0026#39;+\u0026#39;, Pair(1, Pair(Pair(\u0026#39;*\u0026#39;, Pair(2.3, Pair(45, nil))), nil))) \u0026gt;\u0026gt;\u0026gt; print(expression) (+ 1 (* 2.3 45))   scheme_read函数首先检查各种基础的例子, 包括空输入(会抛出一个文档结束异常, 在Python中叫做EOFError)以及原始表达式. 在任何时候遇到(标记指示一个列表的开端的时候read_tail函数就会被递归调用.\nread_tail函数不断地从相同的输入src中读入, 而且预期列表开始后被调用. 它的基础情况是一个空的输入(一个错误)或者一个终止列表的右括号. 它的递归调用用scheme_list函数读入列表的第一个元素, 用read_tail读入其余的项, 然后返回用Pair表示的列表.\nscheme_read的这一实现可以读入形式良好的Scheme列表, 也就是我们的计算器语言所需要的所有东西. 解析点列表以及引号形式就留作一个练习.\n语法错误信息实际上能够提升一个解析器的可用性. SyntaxError异常会包含描述以及遇到的问题来被抛出.\n3.4.4 计算器运算 scalc模块为计算器语言实现了一个运算器. calc_eval函数接收一个表达式作为参数然后返回它的计算结果. 帮助函数simplify, reduce以及as_scheme_list的定义出现在模块里面并在下面会使用到.\n对于计算器而言, 表达式只有两个合法的句法形式, 那就是数字以及调用表达式, 也就是表示良好形式的Scheme列表的Pair实例. 数字是自运算的; 他们可以从calc_eval函数中被直接返回. 调用表达式需要函数应用程序.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; def calc_eval(exp): \u0026#34;\u0026#34;\u0026#34;Evaluate a Calculator expression\u0026#34;\u0026#34;\u0026#34; if type(exp) in (int, float): return simplify(exp) elif isinstance(exp, Pair): arguments = exp.second.map(calc_eval) return simplify(calc_apply(exp.first, arguments)) else: raise TypeError(exp + \u0026#39; is not a number or call expression\u0026#39;)   调用表达式首先通过递归映射calc_eval函数到操作数的列表中来执行运算, 也就是计算arguments列表的值. 然后, 操作符在第二个函数calc_apply中被应用到这些参数上.\n计算器语言简单到足够我们可以轻易地表达应用每一个操作符到单一一个函数体中的逻辑. 在calc_apply函数中, 每一个条件语句对应使用一个操作符.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026gt;\u0026gt;\u0026gt; def calc_apply(operator, args): \u0026#34;\u0026#34;\u0026#34;Apply the named operator to a list of args.\u0026#34;\u0026#34;\u0026#34; if not isinstance(operator, str): raise TypeError(str(operator) + \u0026#39; is not a symbol\u0026#39;) if operator == \u0026#39;+\u0026#39;: return reduce(add, args, 0) elif operator == \u0026#39;-\u0026#39;: if len(args) == 0: raise TypeError(operator + \u0026#39; requires at least 1 argument\u0026#39;) elif len(args) == 1: return -args.first else: return reduce(sub, args.second, args.first) elif operator == \u0026#39;*\u0026#39;: return reduce(mul, args, 1) elif operator == \u0026#39;/\u0026#39;: if len(args) == 0: raise TypeError(operator + \u0026#39; requires at least 1 argument\u0026#39;) elif len(args) == 1: return 1/args.first else: return reduce(truediv, args.second, args.first) else: raise TypeError(operator + \u0026#39; is an unknown operator\u0026#39;)   上面, 每一个判断套件都计算不同的操作符的结果或者在遇到错误的数字或者给定一个错误的参数时抛出一个恰当的TypeError. calc_apply函数可以直接使用, 但它必须被传输一系列的值来作为参数而不是一系列的操作数表达式.\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; calc_apply(\u0026#39;+\u0026#39;, as_scheme_list(1, 2, 3)) 6 \u0026gt;\u0026gt;\u0026gt; calc_apply(\u0026#39;-\u0026#39;, as_scheme_list(10, 1, 2, 3)) 4 \u0026gt;\u0026gt;\u0026gt; calc_apply(\u0026#39;*\u0026#39;, nil) 1 \u0026gt;\u0026gt;\u0026gt; calc_apply(\u0026#39;*\u0026#39;, as_scheme_list(1, 2, 3, 4, 5)) 120 \u0026gt;\u0026gt;\u0026gt; calc_apply(\u0026#39;/\u0026#39;, as_scheme_list(40, 5)) 8.0   calc_eval的作用是在将操作数子表达式作为参数传输给calc_apply之前先正确地调用calc_apply函数计算操作数子表达式的值. 因此, calc_eval可以接受嵌套表达式.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; print(exp) (+ (* 3 4) 5) \u0026gt;\u0026gt;\u0026gt; calc_eval(exp) 17   calc_eval的结构就是一个按类型派发的例子: 按表达式的形式. 第一个表达式的形式是一个数字, 它不需要额外的执行步骤. 通常情况下, 原始表达式不需要额外的称为自运算的运算步骤. 在我们的计算器语言中唯一的自运算表达式是数字, 但是一个一般的编程语言也可能包含字符串, 布尔值等等.\n读取-求值-输出循环. 最常见的与解析器交互的方法就是通过一个读取-求值-输出循环, 或者称为REPL, 也就是一种互动模式会读取表达式, 执行它同时为用户输出结果. Python的互动会话模式就是这样的循环的一个例子.\n实现一个REPL在很大程度上可以独立于它所使用的解析器. 下面的函数read_eval_print_loop缓冲来自用户的输入, 构造表达式需要使用特定的语言函数scheme_read, 然后输出应用calc_eval到这个表达式上的结果.\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; def read_eval_print_loop(): \u0026#34;\u0026#34;\u0026#34;Run a read-eval-print loop for calculator.\u0026#34;\u0026#34;\u0026#34; while True: src = buffer_input() while src.more_on_line: expression = scheme_read(src) print(calc_eval(expression))   这一版本的read_eval_print_loop包含所有交互式界面的必要的组件. 一个会话例子如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt; (* 1 2 3) 6 \u0026gt; (+) 0 \u0026gt; (+ 2 (/ 4 8)) 2.5 \u0026gt; (+ 2 2) (* 3 3) 4 9 \u0026gt; (+ 1 (- 23) (* 4 2.5)) -12   这个循环的实现并没有提供终端或者错误处理机制. 我们可以通过为用户报告错误来改进界面. 我们也可以允许用户通过发出键盘中断信号来退出循环(在UNIX上是Control-C)或者文件末尾异常(在UNIX上是Control-D). 要使这些实现可行, 我们将while声明语句套件部分放到try声明语句部分中, 第一个except条款通过抛出scheme_read来处理SyntaxError以及ValueError错误异常以及通过抛出calc_eval异常来处理TypeError以及ZeroDivisionError错误异常.\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; def read_eval_print_loop(): \u0026#34;\u0026#34;\u0026#34;Run a read-eval-print loop for calculator.\u0026#34;\u0026#34;\u0026#34; while True: try: src = buffer_input() while src.more_on_line: expression = scheme_read(src) print(calc_eval(expression)) except (SyntaxError, TypeError, ValueError, ZeroDivisionError) as err: print(type(err).__name__ + \u0026#39;:\u0026#39;, err) except (KeyboardInterrupt, EOFError): # \u0026lt;Control\u0026gt;-D, etc. print(\u0026#39;Calculation completed.\u0026#39;) return   这个循环的实现了报告错误而不用退出循环. 而不是在遇到错误的时候退出程序, 并在报告错误信息让用户修正他们的表达式后重启循环. 导入readline模块之后, 用户甚至可以使用上箭头或者 Comtrol-P 来再次调用他们之前的输入. 最后的结果是提供了一个内容丰富的错误报告界面:\n1 2 3 4 5 6 7 8 9 10  \u0026gt; ) SyntaxError: unexpected token: ) \u0026gt; 2.3.4 ValueError: invalid numeral: 2.3.4 \u0026gt; + TypeError: + is not a number or call expression \u0026gt; (/ 5) TypeError: / requires exactly 2 arguments \u0026gt; (/ 1 0) ZeroDivisionError: division by zero   当我们将解析器推广到计算器以外的新语言时, 我们会看到read_eval_print_loop是一个通过一个解析函数, 一个执行函数, 以及通过try声明进行异常类型处理的参数化了的函数. 在这些更改之外, 所有的REPL都可以用相同的结构来实现.\n3.5 具有抽象语言的翻译器 计算器语言提供了一种通过嵌套调用表达式来进行组合的手段. 然而, 这样没有办法去定义新的操作符, 给定数值一个名称, 或者表达一般的计算方法. 计算器并不支持任何方式的抽象. 因此, 它并不是一个特别强大或一般的编程语言. 我们现在的任务转为定义一个一般的编程语言以支持抽象用来为值绑定名称以及定义新的操作.\n不像之前的章节那样会以Python源程序来呈现完整的翻译器, 这节会采用描述性的方法. 这个伴生性项目要求你来实现一个功能完善的Scheme翻译器以呈现在这里的这些想法\n3.5.1 构造 这一节描述Scheme解析器的一般构造. 完成这一个项目将会在这里生产出一个在这里描述的解析器的可用实现.\n一个Scheme解析器可以共享大部分的计算器解析器的结构. 一个解析器产出一个给执行器解读的表达式. 执行函数检查表达式的形式, 以及对于调用表达式它调用一个函数来将过程应用于某些参数. 执行器的区别是跟特殊形式, 用户定义函数, 以及实现的环境计算模型有关.\n解析. 来自于计算器解析器的scheme_reader以及scheme_tokens模块几乎已经足够解析任何Scheme表达式. 然而, 它还没有支持引用或者点列表. 一个完整的Scheme解析器应该能够解析以下的输入表达式.\n1 2  \u0026gt;\u0026gt;\u0026gt; read_line(\u0026#34;(car \u0026#39;(1 . 2))\u0026#34;) Pair(\u0026#39;car\u0026#39;, Pair(Pair(\u0026#39;quote\u0026#39;, Pair(Pair(1, 2), nil)), nil))   你在实现Scheme解析器的首要任务将会是拓展scheme_reader去正确地解析点列表以及引用.\n运算. Scheme每一次对一条表达式执行运算. 实现一个运算器的骨架被定义在伴生项目的scheme.py文件中. 每一个表达式从scheme_read中返回后被传递到scheme_eval函数中, 这个函数会在当前的环境env中执行一个表达式expr.\nscheme_eval函数执行在Scheme中不同形式的表达式: 原语, 特殊形式, 以及调用表达式. Scheme中的组合形式可以通过检查它的首个参数来决定. 每一个特殊形式都具有它自己的运算规则. 一个简化的scheme_eval实现出现在下面. 一些错误检查以及特殊形式处理已经被移除以便让我们专注于我们的讨论. 完整的实现在伴生项目中.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; def scheme_eval(expr, env): \u0026#34;\u0026#34;\u0026#34;Evaluate Scheme expression expr in environment env.\u0026#34;\u0026#34;\u0026#34; if scheme_symbolp(expr): return env[expr] elif scheme_atomp(expr): return expr first, rest = expr.first, expr.second if first == \u0026#34;lambda\u0026#34;: return do_lambda_form(rest, env) elif first == \u0026#34;define\u0026#34;: do_define_form(rest, env) return None else: procedure = scheme_eval(first, env) args = rest.map(lambda operand: scheme_eval(operand, env)) return scheme_apply(procedure, args, env)   应用程序. 上面的最后一个例子调用了第二个过程, 应用程序, 它是通过函数scheme_apply来实施的. 在Scheme中的应用程序过程比在计算器中的calc_apply函数更为一般. 它应用两个类型的参数: 一个PrimtiveProcedure或者一个LambdaProcedure. 一个PrimtiveProcedure是在Python中执行的; 它具有一个被绑定到Python函数的实例属性fn. 此外, 它可能会也可能不会需要访问当前环境. 每当程序应用时这个Python函数会被调用.\n一个LambdaProcedure是在Scheme中执行的. 它具有一个body属性, 这个属性是一个Scheme表达式, 每当程序应用时都会被执行. 为了将过程应用于参数列表, 表达式体会在一个新的环境中执行. 为了构建这个环境, 一个新的帧被添加到了这个环境中, 其中过程的正式参数会被绑定到实参上. 表达式体会用scheme_eval来执行.\n执行/应用递归. 运行执行过程的函数, scheme_eval以及scheme_apply, 是相互递归的. 当遇到调用表达式时, 需要应用程序来执行. 应用程序使用执行过程来将操作数表达式计算为参数, 以及去执行用户定义的过程体. 这种相互递归过程的一般构造相当普遍地出现在编译器上: 执行过程是根据应用程序来定义同时应用程序又是是由执行过程来定义的.\n这个递归循环结束于语言的原语. 执行过程具有最基础的情况, 那就是执行一个原始表达式. 有一些特殊的形式也是在没有递归调用的情况下由基础形式构成. 函数应用具有的基础形式就是应用一个原语过程. 这个相互递归结构由一个处理表达式形式的执行函数以及一个处理函数过程的应用函数以及它们的参数之间构成执行过程的本质.\n3.5.2 环境 现在我们已经描述了Scheme解析器的结构, 我们现在要转而实现Frame类用它来形成环境. 没一个Frame实例代表一个环境, 这个环境就是一个绑定到值的符号. 一个帧具有一个绑定字典, 同时全局帧的父级帧是None.\n绑定是不能够直接访问的, 而是通过两个帧方法: lookup以及define来访问. 第一个实现了第一章中对环境模型的计算描述的查找过程. 一个符号与当前帧的绑定相匹配. 如果它被找到, 那么它绑定的值会被返回. 如果找不到, 查看过程最终将进行到父级. 另一方面, define方法总是将符号绑定到当前帧中的值.\n实现lookup以及使用define的就留作练习, 作为使用说明, 思考下下面的Schem程序例子:\n1 2 3 4 5  (define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1))))) (factorial 5) 120   第一个输入表达式是一个define的特殊形式, 通过Python函数do_define_form来运行. 定义一个函数具有下面几个步骤:\n 检查表达式的形式来确保这是一个良好形式的Scheme列表且具有至少两个元素紧跟在define关键词后面. 分析第一个元素, 在这个例子中是Pair, 去寻找函数名称factorial以及形式参数列表(n). 创建一个具有形式参数, 函数体以及父级环境的LambdaProcedure. 在当前环境的第一个帧中绑定符号factorial到这个函数. 在这个例子中, 这个环境只由全局帧组成.  第二个输入是一个调用表达式. 传入到scheme_apply的procedure是那个刚刚创建并绑定到factorial符号的LambdaProcedure. 传入的args是只有一个元素的Scheme列表(5). 为了调用这个过程, 一个新的拓展自全局帧(factorial过程的父级环境帧)的帧会被创建, 在这个帧中, 符号n被绑定到值5. 然后, factorial的函数体会在这个环境中执行, 生成的值会被返回.\n3.5.3 作为程序的数据 在思考执行Scheme表达式的程序时, 比喻类比会是更有用的. 有个关于程序意义的操作视图就是程序其实是一个抽象机器. 例如, 再次考虑计算阶乘的程序:\n1 2  (define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))   我们会用一个等价的Python程序来表示, 使用一个条件表达式.\n1 2  \u0026gt;\u0026gt;\u0026gt; def factorial(n): return 1 if n == 0 else factorial(n - 1)   我们可以将这个程序视为一个包含了减法, 乘法, 和相等测试的部件以及具有两位开关以及其他阶乘机器的机器的描述. (阶乘机器是无穷的, 因为它包含另一个阶乘机器在内部) 下面的图就是阶乘机器的流程图, 展示各个部分是如何连接在一起的.\n以类似的方式, 我们可以将Scheme解析器看作是一个非常特殊的机器, 以输入作为机器的描述. 给定这个输入, 解析器配置它自己模拟机器的描述. 例如, 如果我们为我们的执行器喂入阶乘的定义, 那这个执行器就能够计算阶乘.\n从这个角度看, 我们的Scheme解析器被认为是通用机器. 当这些程序被描述成Scheme程序时, 它会模仿其他的机器(的行为). 它作为被我们的程序语言操作的数据对象跟程序语言本身的桥梁. 想象一下, 一个用户写下一个Scheme表达式输入到正在运行的Scheme解析器中. 从用户的这个角度看, 输入的一个表达式如(+ 2 2)是一个程序语言中能够进行解析的表达式. 然而, 从Scheme解析器的角度看, 表达式只是一句话, 这句话根据已经定义好的一系列规则来进行操作.\n用户的程序是解析器需要的数据并不会是混乱的源头. 实际上, 某些时候能够方便地忽略掉这些区别, 并使用户有能力去明确地将数据对象作为一个表达式来执行. 在Scheme, 每当采用run程序时我们会用到这个设备. 在Python中存在的类似程序: eval函数会执行一个Python表达式而exec函数会执行一个Python声明, 因此,\n1 2  \u0026gt;\u0026gt;\u0026gt; eval(\u0026#39;2+2\u0026#39;) 4   和\n1 2  \u0026gt;\u0026gt;\u0026gt; 2+2 4   都返回相同的结果. 作为构造好的执行过程的一部分来执行表达式在动态编程语言中是一个常见且强有力的特性. 在某几种语言中, 也具有跟Scheme相同的做法, 但是在程序执行过程中构建和执行表达式的能力被证明是任何程序员的宝贵工具.\n","description":"","id":4,"section":"posts","tags":["译文","Design Programs"],"title":"程序构成-第三章","uri":"https://jmwill.github.io/blog/2017/06/11/%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90-%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"content":"第二章: 构筑抽象数据 2.1 介绍 在第一章我们集中关注计算过程, 以及函数对程序设计的作用与影响. 我们已经见识过如何使用原始数据(numbers)以及原始操作符(算术), 如何通过组合和控制来组成复合函数, 以及通过给计算过程赋予名称来创建函数抽抽象. 我们也看到高阶函数通过允许我们自行控制, 从而推理出一般计算方法来增强我们的语言的力量. 这就是编程的本质.\n这一章主要关注数据. 我们在这里探讨的技术允许我们表达以及操作许多不同领域的信息. 由于因特网的爆炸性增长, 提供给我们大量在线且免费的结构化信息, 并且可以在大范围不同问题上进行计算. 有效使用內建的以及用户定义的数据类型是数据处理程序的根本.\n2.1.1 基本数据类型 每一种数据在Python中都有一个类属, 这个类属决定了这个值是什么类型. 共享的数据同时具有共享的行为. 例如, 整数1以及2都是int类的实例. 这两个值能够进行类似的处理. 例如, 它们都可以被另外一个整数加或者减. 內建的type函数允许我们检查任何数值的类型.\n1 2  \u0026gt;\u0026gt;\u0026gt; type(2) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt;   我们目前使用的数值知识少量Python语言的內建_本地_数据类型. 本地数据类型具有以下属性:\n 有对原生类型的值进行定义的表达式, 叫做常量 有对原生类型的值进行操作的內建函数以及操作符  int类是用来表示整数的原生数据类型. 整型常量(相邻数字序列)表达为int值, 以及数学运算符来操作这些值.\n1 2  \u0026gt;\u0026gt;\u0026gt; 12 + 3000000000000000000000000 3000000000000000000000012   Python包含有三种本地数据类型: 整型(int), 实数(float), 以及复数(complex).\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; type(1.5) \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(1+1j) \u0026lt;class \u0026#39;complex\u0026#39;\u0026gt;   Floats: 名字float来源于Python以及许多其他的程序语言实数的表示方式是以: \u0026ldquo;浮点(floating point)\u0026ldquo;来表示的. 至于数字是如何表示的这些细节不在我们这一节的讨论范围之内, 而一些int以及float对象的高级差异需要重点了解. 尤其是, int对象能够准确地表示整数, 对其大小没有任何近似以及限制. 另一方面, float对象能够表示较宽范围内的分数, 但不是所有的数字都能够准确表示, 同时它们还具有最小值以及最大值. 因此, float数值应该被视为实际值的近似值来对待. 这些近似值只具有有限的精度. 合并浮点数会导致一些精度错误; 如果不用近似值的话下面的表达式计算后应该会等于7:\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; 7 / 3 * 3 7.0 \u0026gt;\u0026gt;\u0026gt; 1 / 3 * 7 * 3 6.999999999999999   虽然上面是int的组合, 用一个int除以另一个会得到一个float的值: 一个被截断了的近似值, 也就是两个整数相除的实际比率.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; type(1/3) \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; 1/3 0.3333333333333333   当我们进行相等性测试的时候就会出现近似值的问题.\n1 2  \u0026gt;\u0026gt;\u0026gt; 1/3 == 0.333333333333333312345 # Beware of float approximation True   这些int类型与float类型之间的微妙不同, 对程序的编写具有广泛的影响, 因此它们的细节程序员必须要铭记在心. 幸运的是, 只有少量的本地数据类型, 限制了精通编程语言所需要的记忆量. 此外, 这些相同的细节在许多编程语言中也是一致的. 由社区准则强制执行, 如: IEEE 754 floating point standard\n非数字类型. 数值能够代表许多其他类型的数据, 例如声音, 图像, 地点, 网址, 网络连接等等. 少量是通过本地数据类型来表示的, 例如代表真(True)和假(False)的布尔(bool)类型. 大多数值的类型都需要程序员来使用本章中研究的组合和抽象手段来进行定义.\n接下来的部分将介绍更多Python的本地数据类型, 侧重于它们在创建有用的数据抽象中所起到的作用. 那些对于更加深入的细节感兴趣的人可以阅读一下深入Python3这本书的本地数据类型这一章,写出了所有Python的本地数据类型的实用概述以及如何对它们进行操作, 包括大量的用法例子以及练习提示.\n2.2 数据抽象 当我们考虑世界上的广泛的事物的时候, 我们会想要将它在我们的程序中表现出来, 我们会发现它们大多数都具有复合结构. 例如, 一个地理位置有经度以及纬度坐标. 为了表示位置, 我们会想让我们的程序语言有能力将经度和纬度合在一起以形成一对, 作为一个我们的程序能够操作的一个单一的概念单元, 但是它也具有两个部分可以进行单独考虑.\n使用复合数据能够让我们提升程序的模块性, 如果我们能够将地理位置作为一个整体来进行操作, 然后我们就可以对程序使用位置进行计算中是如何对这些地理位置进行表示的细节进行屏蔽. 一般的隔离程序各个部分的技术, 都是处理数据是如何被表示, 以及处理数据是如何被操作的强大的设计方法, 这方法称为数据抽象. 数据抽象让程序更容易被设计, 维护, 以及修改\n数据抽象在性质上跟函数抽象那一章相似. 当我们创建一个函数抽象, 函数是如何实现的细节能够被压制, 以及特定的函数本身能够被任何其他的具有相同整体行为的函数进行替换. 换句话说, 我们可以实现一个抽象来将函数使用的方式与函数如何实现的细节上进行分离. 类似地, 数据抽象对复合数据的使用方式与如何构造的细节进行了隔离.\n数据抽象的基本思想是结构化程序, 以便于它们对抽象数据进行操作. 也就是说, 我们的程序应该以尽可能少的以对数据进行假设的方式来使用数据. 同时, 数据的具体表现应该定义为程序的一个独立的部分.\n程序的这两个部分, 对数据抽象进行操作的部分以及定义具体表示的部分, 通过一组小的函数进行连接, 这些函数根据具体表示实现抽象数据. 为了说明这种技术, 我们需要考虑如何设计一套函数来操作有理数.\n2.2.1 例子: 有理数 一个有理数就是整数的比率, 有理数是构成实数的重要子类. 一个有理数如1/3或者17/29通常写作:\n\u0026lt;numerator\u0026gt;/\u0026lt;denominator\u0026gt;\n而\u0026lt;numerator\u0026gt;以及\u0026lt;denominator\u0026gt;都是整数的占位符. 这些部分都需要用来准确地表征有理数的值. 实际上整数相除得到一个浮点数的近似值, 失去了整数的精确度.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; 1/3 0.3333333333333333 \u0026gt;\u0026gt;\u0026gt; 1/3 == 0.333333333333333300000 # Dividing integers yields an approximation True   然而, 我们可以通过将分子和分母组合在一起来为有理数创建一个精确的表示.\n我们从使用函数的抽象中可以知道, 我们可以在程序的某些部分实现之前开始进行编程. 让我们假设我们已经有办法从一个分子以及一个分母中构造一个有理数开始. 我们还假设, 给定一个有理数, 我们有方法选定它的分子和分母的部分. 让我们进一步假设构造器以及选择器可具有一下的三个功能:\n **rational(n, d)**以分子为n分母为d的形式返回一个有理数 **numer(x)**返回有理数中的分子x **denom(x)**返回有理数中的分母x  在这里我们使用程序设计中的强大策略: 祈愿思维. 我们还没有讲述一个有理数是如何表示的, 或者函数number, denom, 以及rational应该怎么实现. 即使这样, 如果我们定义了这三个函数, 我们可以对有理数进行加, 乘, 打印, 以及测试相等性等操作:\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; def add_rationals(x, y): nx, dx = numer(x), denom(x) ny, dy = numer(y), denom(y) return rational(nx * dy + ny * dx, dx * dy) \u0026gt;\u0026gt;\u0026gt; def mul_rational(x, y): return rational(numer(x) * numer(y), denom(x) * denom(y)) \u0026gt;\u0026gt;\u0026gt; def print_rational(x): print(numer(x), \u0026#39;/\u0026#39;, denom(x)) \u0026gt;\u0026gt;\u0026gt; def rationals_are_equal(x, y): return numer(x) * denom(y) == numer(y) * denom(x)   现在我们具有定义在选择器函数number以及denom和构造器函数rational之上的操作函数, 但是我们还没有定义这些选择器函数以及构造器函数. 我们需要一种方法来将分子和分母进行粘合, 形成一个复合值.\n2.2.2 一对 为了让我们实现正确等级的数据抽象, Python提供了一种复合数据结构叫做list, 能够通过将表达式放到方括号内并用逗号分隔开来构造, 这种表达式就叫做列表字面量.\n1 2  \u0026gt;\u0026gt;\u0026gt; [10, 20] [10, 20]   列表中的元素可以用两种方式来进行访问, 第一种方式是通过我们熟悉的多重分配的方法, 通过对list对象中的元素进行解包然后绑定每一个元素到不同的名字.\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; pair = [10, 20] \u0026gt;\u0026gt;\u0026gt; pair [10, 20] \u0026gt;\u0026gt;\u0026gt; x, y = pair \u0026gt;\u0026gt;\u0026gt; x 10 \u0026gt;\u0026gt;\u0026gt; y 20   第二个访问方法是通过list的元素选择运算符, 也通过方括号来进行表达. 不像列表字面量, 一个方括号表达式直接跟在另一个表达式后面不以生成列表值来运行, 而是在前面的表达式中选择一个元素.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; pair[0] 10 \u0026gt;\u0026gt;\u0026gt; pair[1] 20   在Python中的列表(以及大多数其他的编程语言)是以0索引作为开始的, 这意味着索引0选定第一个元素, 索引1选定第二个, 等等. 一个支持这个索引惯例的直觉是索引代表一个元素偏离列表开始位置有多远.\n跟元素选择操作符相等的函数叫做getitem, 它也用索引0作为开始位置来对列表对象进行选取.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; from operator import getitem \u0026gt;\u0026gt;\u0026gt; getitem(pair, 0) 10 \u0026gt;\u0026gt;\u0026gt; getitem(pair, 1) 20   两个元素的列表不是表示一对的唯一方法, 任何将两个值捆绑到一块的方法都可以认为是一对. 只是列表是一种常用的方法. 列表也可以容纳超过两个对象, 正如我们本章接下来要进行讨论的.\n表示有理数. 现在我们能够将有理数表示为一对整数的组合: 一个分子和一个分母.\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; def rational(n, d): return [n, d] \u0026gt;\u0026gt;\u0026gt; def numer(x): return x[0] \u0026gt;\u0026gt;\u0026gt; def denom(x): return x[1]   结合早先我们定义的算术运算, 我们可以用我们已经定义好的函数来操作有理数.\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; half = rational(1, 2) \u0026gt;\u0026gt;\u0026gt; print_rational(half) 1 / 2 \u0026gt;\u0026gt;\u0026gt; third = rational(1, 3) \u0026gt;\u0026gt;\u0026gt; print_rational(mul_rational(half, third)) 1 / 6 \u0026gt;\u0026gt;\u0026gt; print_rational(add_rationals(third, third)) 6 / 9   像上面例子显示的那样, 我们的有理数的实现不会将有理数减少到最低项. 我们可以通过改变rational函数的实现来修复这个缺陷. 如果我们有一个函数来计算两个整数的最大公分母, 我们就可以在构建有理数对时用它来将分子和分母减少为最底项. 跟许多有用的工具一样, 在Python的库中已经有这样的一个函数了.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; from fractions import gcd \u0026gt;\u0026gt;\u0026gt; def rational(n, d): g = gcd(n, d) return (n//g, d//g)   整除运算符, //, 表示整除, 也就是对相除的结果将向下舍入小数部分. 由于我们已经知道g能够完全整除n以及d, 整除在这种情况下是精确的. 这个rational函数的合理地进行了修正保证了有理数以最低项来表示.\n1 2  \u0026gt;\u0026gt;\u0026gt; print_rational(add_rationals(third, third)) 2 / 3   这种改进是通过改进构造函数而不用改变其他函数(即实现实际运算的函数)来完成的.\n2.2.3 抽象屏障 在继续(介绍)更多的组合数据和数据抽象的例子之前, 让我们思考一下有理数例子提出的一些问题. 我们根据构造函数rational和选择器numer, denom定义操作. 一般来说, 数据抽象的基础思想是识别一组基础操作, 根据这些操作来表达某种类型的值的所有操作, 然后只使用这些操作来处理数据. 通过限制这些操作的使用方式, 将会更容易改变抽象数据的表示而不用修改程序的行为.\n对于有理数, 程序的不同部分使用不同的操作来操纵有理数, 如下表所述:\n   Parts of the program that\u0026hellip; Treat rational as\u0026hellip; Using only\u0026hellip;     Use rational numbers to perform computation whole data values add_rational, mul_rational, rationals_are_equal, print_rational   Create rationals or implement rational operations numerators and denominators rational, numer, denom   Implement selectors and constructor for rationals two-element lists list literals and element selection       程序的每个部分\u0026hellip; 将有理数当做\u0026hellip; 只用作     用有理数来执行计算 整个数值 add_rational, mul_rational, rationals_are_equal, print_rational   创建有理数或操作有理数 分子以及分母 rational, numer, denom   实现有理数的构造器以及选择器 两个元素的列表 列表字面量以及元素选择    在上面的每一层, 最后一列的函数实现了一个抽象屏障. 这些函数通过更低层次的抽象来实现来被更高层的函数调用.\n违反一个抽象屏障的情况发生在每当可以在较高级别函数中使用程序的一部分时, 却使用较低级别的函数来实现. 举个例子, 一个计算有理数平方的函数最好是根据mul_rational来实现, 而无需对有理数的实现进行任何假设.\n1 2  \u0026gt;\u0026gt;\u0026gt; def square_rational(x): return mul_rational(x, x)   直接涉及到分子以及分母会违反一层抽象屏障.\n1 2  \u0026gt;\u0026gt;\u0026gt; def square_rational_violating_once(x): return rational(numer(x) * numer(x), denom(x) * denom(x))   假设有理数用两个元素的列表表示会违反两层抽象屏障.\n1 2  \u0026gt;\u0026gt;\u0026gt; def square_rational_violating_twice(x): return [x[0] * x[0], x[1] * x[1]]   抽象屏障让程序更容易管理与修改. 越少函数依赖于特定的表示, 当想改变其中一个的表示的时候就需要越少的改动. 所有的这些square_rational的实现都具有正确的行为, 但是只有第一个对于未知的变化是健壮的. square_rational函数即使在我们修改有理数的表示的时候也不需要更新. 相比之下, square_rational_violating_once每当选择器或者构造器的特征改变的时候都需要进行修改, 而square_rational_violating_twice则在有理数的实现有任何改变时都需要进行更新.\n2.2.4 数据的属性 抽象屏障能够塑造我们思考数据的方式. 对有理数进行有效的表示是不限于任何特定的实现的(如具有两个元素的列表); 它是rational函数返回的一个值, 这个值能够输入到numer以及denom当中. 除此之外, 必需维持构造器跟选择器之间恰当的关系. 也就是说, 如果我们从整数n跟d中构造一个有理数x, 应该得到一种情况是numer(x)/denom(x)等于n/d.\n一般来说, 我们可以用选择器函数以及构造器函数集合与一些行为条件一起来表示抽象数据. 只要这些行为条件满足(例如上面的除法属性), 选择器以及构造器函数构成了一种数据的有效表示. 在抽象屏障之下的细节可能会有更改, 但是如果行为没有改变, 那数据抽象依然是有效的, 然后任何使用这些数据抽象编写的程序依然是正确的.\n这一观点能够进行广泛地应用, 包括我们用于实现有理数的数据对. 我们从没有说过什么是数据对, 只有语言提供的创建以及操作两个元素的列表方法. 我们需要实现的数据对的行为是它能将两个值黏合在一起. 而行为条件,\n 如果一个数据对p由值x跟y构造, 那么select(p, 0)返回x, select(p, 1)返回y.  我们实际上不需要用列表类型来创建数据对, 作为替代, 我们可以实现两个函数pair以及select来满足这个描述, 就像两个元素的列表一样.\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; def pair(x, y): \u0026#34;\u0026#34;\u0026#34;Return a function that represents a pair.\u0026#34;\u0026#34;\u0026#34; def get(index): if index == 0: return x elif index == 1: return y return get \u0026gt;\u0026gt;\u0026gt; def select(p, i): \u0026#34;\u0026#34;\u0026#34;Return the element at index i of pair p.\u0026#34;\u0026#34;\u0026#34; return p(i)   有了这个实现, 我们可以创建并操作数据对.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; p = pair(20, 14) \u0026gt;\u0026gt;\u0026gt; select(p, 0) 20 \u0026gt;\u0026gt;\u0026gt; select(p, 1) 14   这种高阶函数的使用方式能够跟我们对于数据是什么这种直观的概念进行对应. 然而, 这些函数足够表示我们程序中用到的数据对. 函数足以表示复合数据.\n用函数展示数据对的意思不代表Python就是以这种方式来运行的(处于效率的原因, 列表的实现更加的直观)但是它能以这种方式运行. 函数型的表示虽然模糊, 但它完全具有表示数据对的能力, 因为它满足数据对唯一需要满足的条件. 数据抽象的实践允许我们轻易地在各种表示中进行切换.\n2.3 序列 序列就是一个值的有序集合. 序列在计算机科学中是强大的, 基本的抽象. 序列不是某个特定的內建类型的实例或者抽象数据表示, 而是在一些不同类型的数据之间共享行为的集合. 也就是说, 有许多种类型的序列. 但是它们都共享共同的行为. 尤其是,\n长度. 一个序列具有有限的长度. 一个空序列的长度是0.\n元素选择. 一个序列的对于任何小于它长度的非负整数的索引值都对应它的一个元素, 第一个元素从0开始.\nPython包含的一些本地数据类型就是序列, 最重要的莫过于列表了.\n2.3.1 列表 一个列表就是一个具有任意长度的序列. 列表具有一大套內建行为, 以及表示这些行为的特殊语法. 我们已经见识过列表字面量了, 也就是用来运算生成列表实例那个, 以及元素选择表达式, 即用来获取列表中的值的语法. 內建的len函数用于返回一个序列的长度. 下面, digits是一个具有四个元素的列表. 索引为3的元素值是8.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; digits = [1, 8, 2, 8] \u0026gt;\u0026gt;\u0026gt; len(digits) 4 \u0026gt;\u0026gt;\u0026gt; digits[3] 8   另外, 列表可以加在一起, 以及与一个整数相乘. 对于序列来说, 加法以及乘法不会添加或者乘里面的元素, 而是复制序列本身并将它们合并在一起. 也就是说, 在operator模块下的add函数(以及符号+)返回的是添加的参数级联后生成的一个列表. 而在operator中的mul函数(以及*号)能够传入一个列表以及一个整数然后返回另一个列表, 这个列表是由k次重复的源列表组成的.\n1 2  \u0026gt;\u0026gt;\u0026gt; [2, 7] + digits * 2 [2, 7, 1, 8, 2, 8, 1, 8, 2, 8]   任意的值都可以包含在列表中, 包括其他的列表. 为了选择到包括在列表里面的列表这样深层次嵌套的元素可以多次应用列表元素选择语法.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; pairs = [[10, 20], [30, 40]] \u0026gt;\u0026gt;\u0026gt; pairs[1] [30, 40] \u0026gt;\u0026gt;\u0026gt; pairs[1][0] 30   2.3.2 序列迭代 在很多情况下, 我们会想要对序列的元素进行迭代然后反过来对每个元素执行一些计算. 这种模式是如此的常见以至于Python有一个额外的控制语句来处理顺序的数据: for语句.\n想一下计算一个值在序列中出现的次数这样的一个问题, 我们可以实现一个函数用while循环来进行计数.\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; def count(s, value): total, index = 0, 0 while index \u0026lt; len(s): if s[index] == value: total += 1 index += 1 return total \u0026gt;\u0026gt;\u0026gt; count(digits, 8) 2   Python的for语句能够简化这个函数体通过直接对元素值进行迭代而根本不需要引入名称index.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; def count(s, value): total = 0 for elem in s: if elem == value: total += 1 return total \u0026gt;\u0026gt;\u0026gt; count(digits, 8) 2   for语句由单个子句组成, 形式如下:\nfor \u0026lt;name\u0026gt; in \u0026lt;expression\u0026gt;: \u0026lt;suite\u0026gt; 一个for语句会按照以下的步骤执行:\n 计算头部表达式\u0026lt;expression\u0026gt;, 必须返回一个可迭代的值. 遍历该可迭代值中的每一个元素, 是为了:  将这个元素值当前域的中的\u0026lt;name\u0026gt;进行绑定 执行\u0026lt;suite\u0026gt;    这个执行过程引用的是可迭代的值, 列表是序列的一种, 而序列是一种可迭代的值. 它们的元素按照它们原有的顺序被考虑. Python包括其他的可迭代的值, 但是目前我们会专注于序列; 术语\u0026quot;可迭代\u0026quot;的一般定义出现在第四章的迭代器部分.\n这个计算过程的一个重要的意义是\u0026lt;name\u0026gt;会在for语句运行后绑定到序列中的最后一个元素. for循环引入了另外一种可以让运行环境随语句执行而更新的方式.\n序列解包. 在程序中的常见模式是有一个以序列为元素的序列, 但元素都是固定长度的. 一个for语句可能会包含有多个名称在它的头部用来对序列中的每一个序列元素\u0026quot;解包\u0026quot;到各自对应的名称上. 例如, 可能会有一个以包含两个元素的序列为元素的序列:\n1  \u0026gt;\u0026gt;\u0026gt; pairs = [[1, 2], [2, 2], [2, 3], [4, 4]]   然后希望从中找到这些序列对中两个数字是相等的序列对\n1  \u0026gt;\u0026gt;\u0026gt; same_count = 0   下面的for语句在它的头部有两个变量名x和y, 这两个变量名会分别跟序列对的第一和第二个元素进行绑定:\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; for x, y in pairs: if x == y: same_count += 1 \u0026gt;\u0026gt;\u0026gt; same_count 2   这种将多个名称以固定长度的顺序绑定到多个值的模式称为序列解包; 这跟我们在赋值语句中看到的绑定多个名称到多个值的模式是一样的.\n范围. 一个range类型是Python中另一个內建的序列类型, 它代表了一个整数的区间. 区间由range来创造, 需要两个整数作为参数: 第一个数字和一个超出所需范围内的最后一个数字.\n1 2  \u0026gt;\u0026gt;\u0026gt; range(1, 10) # 包含1, 但不包含10 range(1, 10)   调用list构造器计算出在一个在范围内的与范围相符的列表, 因此可以很容易地检查里面的元素.\n1 2  \u0026gt;\u0026gt;\u0026gt; list(range(5, 8)) [5, 6, 7]   如果只给定一个参数, 这被解析为构建一个从零开始到超出所需范围内的最后一个数字的区间.\n1 2  \u0026gt;\u0026gt;\u0026gt; list(range(4)) [0, 1, 2, 3]   区间通常出现在for表达式的头部来指定\u0026lt;suite\u0026gt;部位应该执行的次数: 有一个共同的约定是如果在for的头部写入的名称在\u0026lt;suite\u0026gt;中没有用到的话就用单个下划线作为名称:\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; for _ in range(3): print(\u0026#39;Go Bears!\u0026#39;) Go Bears! Go Bears! Go Bears!   下划线对于解释器环境而言只是另外的一个名称, 但是它在程序员之间却是具有常规的意义, 那就是表明这个名称不会现在在之后的任何表达式中.\n2.3.3 序列处理 序列是一种如此常见的用于组成复合数据的形式以至于整个程序通常都围绕这个单一抽象来进行组织. 模块化组件同时以序列作为输入和输出能够对数据处理过程进行混合以及匹配. 复杂组件能够通过将序列处理操作连接在一起形成管道来进行定义, 而每个处理都是简单和集中的.\n列表推导. 很多的序列处理操作能够通过为序列中的每个元素计算一个固定的表达式然后收集结果的值到一个结果序列中来表示. 在Python中, 一个列表推导式是一个执行这样的计算的表达式:\n1 2 3  \u0026gt;\u0026gt;\u0026gt; odds = [1,3,5,7,9] \u0026gt;\u0026gt;\u0026gt; [x + 1 for x in odds] [2,4,6,8,10]   上面的for关键词不是for语句的一部分, 而是列表表达式的一部分因为它包含在方括号里面. 而子表达式 x+1 是将x顺序绑定到每一个odds中的元素来进行运算, 然后收集每次运算的结果到列表中.\n另一个常见的列表推导操作是去选择一个满足某些结果的子集. 列表推导能够表达这种模式, 例如选择所有odds中的能够整除25的元素:\n1 2  \u0026gt;\u0026gt;\u0026gt; [x for x in odds if 25 % x == 0] [1, 5]   列表推导的一般形式是:\n[\u0026lt;map expression\u0026gt; for \u0026lt;name\u0026gt; in \u0026lt;sequence expression\u0026gt; if \u0026lt;filter expression\u0026gt;]\n为了运算一个列表推导, Python会计算\u0026lt;sequence expression\u0026gt;, 这个表达式必须要返回一个可迭代值. 然后, 对每个元素按照顺序, 将元素的值与\u0026lt;name\u0026gt;进行绑定, 接着运算过滤表达式, 然后如果过滤结果返回真值, map expression(映射表达式)将会执行, 最后结果会被收集到一个列表中.\n聚合. 第三个序列处理的一般模式是将一个序列中所有的值聚合到单一的一个值中. 內建函数sum, min, 以及max所有都是聚合函数的例子.\n通过结合这些对每个元素进行运算, 选择元素的子集, 以及聚集元素的模式, 我们可以使用序列处理方法来解决问题.\n一个完备正整数指的就是一个等于它的除数的总和. n的除数是小于n且能均分n的正整数. 可以通过列表推导来运算从而列出这些n的除数\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; def divisors(n): return [1] + [x for x in range(2, n) if n % x == 0] \u0026gt;\u0026gt;\u0026gt; divisors(4) [1, 2] \u0026gt;\u0026gt;\u0026gt; divisors(12) [1, 2, 3, 4, 6]   使用divisors函数, 我们可以用其他的列表推导来计算出从1到1000的所有的完备数. (1通常也被认为是完备数, 但是它不符合我们对divisors的定义)\n1 2  \u0026gt;\u0026gt;\u0026gt; [n for n in range(1, 1000) if sum(divisors(n)) == n] [6, 28, 496]   我们可以复用我们定义的divisors来解决另外的问题, 找出一个具有固定面积以及整数长度边长的长方形的最小周长. 长方形的面积等于它的高乘以宽. 而且, 给定面积以及高, 我们可以计算出宽. 我们可以肯定地说, 长和宽都能均分面积的话, 就可以保证边长都是整数.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; def width(area, height): assert area % height == 0 return area // height   长方形的周长等于它边长的总和\n1 2  \u0026gt;\u0026gt;\u0026gt; def perimeter(width, height): return 2 * width + 2 * height   具有整数边长的长方形的高必须是它面积的除数. 我们可以通过考虑它所有的高来计算最小周长.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; def minimum_perimeter(area): heights = divisors(area) perimeters = [perimeter(width(area, h), h) for h in heights] return min(perimeters) \u0026gt;\u0026gt;\u0026gt; area = 80 \u0026gt;\u0026gt;\u0026gt; width(area, 5) 16 \u0026gt;\u0026gt;\u0026gt; perimeter(16, 5) 42 \u0026gt;\u0026gt;\u0026gt; perimeter(10, 8) 36 \u0026gt;\u0026gt;\u0026gt; minimum_perimeter(area) 36 \u0026gt;\u0026gt;\u0026gt; [minimum_perimeter(n) for n in range(1, 10)] [4, 6, 8, 8, 12, 10, 16, 12, 12]   高阶函数\n我们在序列处理中观察到的一般模式可以用高阶函数来进行表示. 首先, 为序列中的每个元素运行一个表达式可以通过对每一个元素应用函数来来表示.\n1 2  \u0026gt;\u0026gt;\u0026gt; def apply_to_all(map_fn, s): return [map_fn(x) for x in s]   通过对每一个元素应用的函数表达式然后仅选择能使表达式结果为真的元素.\n1 2  \u0026gt;\u0026gt;\u0026gt; def keep_if(filter_fn, s): return [x for x in s if filter_fn(x)]   最后, 许多形式的聚合可以表示为反复应用一个带有两个参数的函数, 分别是进行reduced后的值, 以及顺序应用的每一个元素.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; def reduce(reduce_fn, s, initial): reduced = initial for x in s: reduced = reduce_fn(reduced, x) return reduced   例如, reduce可以用来将序列中的所有元素乘到一起. 使用mul替代reduce_fn, 1替代initial, reduce可以用来将序列中的数都乘到一起.\n1 2  \u0026gt;\u0026gt;\u0026gt; reduce(mul, [2, 4, 6, 8], 1) 64   我们也可以用这些高阶函数来找寻完备数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026gt;\u0026gt;\u0026gt; def divisors_of(n): divides_n = lambda x: n % x == 0 return [1] + keep_if(divides_n, range(2, n)) \u0026gt;\u0026gt;\u0026gt; divisors_of(12) [1, 2, 3, 4, 6] \u0026gt;\u0026gt;\u0026gt; from operator import add \u0026gt;\u0026gt;\u0026gt; def sum_of_divisors(n): return reduce(add, divisors_of(n), 0) \u0026gt;\u0026gt;\u0026gt; def perfect(n): return sum_of_divisors(n) == n \u0026gt;\u0026gt;\u0026gt; keep_if(perfect, range(1, 1000)) [1, 6, 28, 496]   常规名称\n在计算机科学的社群中, apply_to_all一般叫做map, keep_if一般叫做filter. 在Python中, 內建的map以及filter是这些方法的泛化, 且并不返回列表对象. 这些方法会在第四章来进行讨论. 上面的定义相当于用列表构造器到处理內建的map以及filter调用后所返回结果.\n1 2  apply_to_all = lambda map_fn, s: list(map(map_fn, s)) keep_if = lambda filter_fn, s: list(filter(filter_fn, s))   reduce函数构建在Python的标准库的functools模块中. 在这个版本中, initial参数是可选的.\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; from functools import reduce \u0026gt;\u0026gt;\u0026gt; from operator import mul \u0026gt;\u0026gt;\u0026gt; def product(s): return reduce(mul, s) \u0026gt;\u0026gt;\u0026gt; product([1, 2, 3, 4, 5]) 120   在Python程序中, 直接使用列表推导是比使用高阶函数更一般的模式, 但两者在列表处理中都是广泛使用的方法.\n2.3.4 序列抽象 我们已经介绍了两种满足序列抽象的本地数据类型: 列表和区间(lists and ranges). 两者都满足这部分开始所设的条件: 长度以及元素选择. Python包含了额外的两个序列类型的行为用来进行序列抽象的拓展.\n成员. 一个值能够就是否是一个序列的成员来进行测试. Python有两个操作符in以及not in其计算的结果是True或者False取决于元素是否出现在序列中.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; digits [1, 8, 2, 8] \u0026gt;\u0026gt;\u0026gt; 2 in digits True \u0026gt;\u0026gt;\u0026gt; 1828 not in digits True   切片. 序列都包含更小的序列. 一个序列的切片是原有序列的任何一个连续片段, 由一对整数来指定. 就像range构造函数一样, 第一个整数指定了切片的起始下标, 然后第二个整数指定了超过结束下标的数.\n在Python中, 序列切片的表达式跟元素选择类似, 用方括号包裹. 一个冒号分割起始以及结束索引. 任何省略的边界都被认定为一个极值: 0是开始下标的极值, 而序列的长度则是结束下标的极值.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; digits[0:2] [1, 8] \u0026gt;\u0026gt;\u0026gt; digits[1:] [8, 2, 8]   切片也可以用于树的分支上. 例如, 我们可能想要对一些树的分支数进行限制. 一个共同的树转型通过将原始树进行分组组合并调整分支得出的一个二叉树叫做二值化计算.\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; def right_binarize(tree): \u0026#34;\u0026#34;\u0026#34;Construct a right-branching binary tree.\u0026#34;\u0026#34;\u0026#34; if is_leaf(tree): return tree if len(tree) \u0026gt; 2: tree = [tree[0], tree[1:]] return [right_binarize(b) for b in tree] \u0026gt;\u0026gt;\u0026gt; right_binarize([1, 2, 3, 4, 5, 6, 7]) [1, [2, [3, [4, [5, [6, 7]]]]]]   对Python序列抽象中的这些额外行为进行枚举给我们一个机会来反映一个一般有用的数据抽象的组成. 抽象的丰富性(也就是说它包含的行为有多少)是有意义的. 对用户来说, 一个抽象的, 额外的行为可能很有帮助. 另一方面, 用一个新类型来满足对丰富抽象性的要求可能很具挑战性. 另一个丰富抽象性的负面后果是它们可能需要用户用更长的时间来学习.\n序列具有丰富的抽象性因为因为它们在计算机中是如此的无所不在, 以至于需要学习一些复杂的行为是合理的, 一般来说, 大多数用户定义的抽象应该尽可能保持简单.\n深入阅读. 切片符号收录了各种各样的特殊例子, 例如负的起始值, 结束值以及步进大小. 一个完整的描述出现在Dive Into Python 3的子节中叫做切片列表. 在这节章中, 我们只会使用到上面提及的基础特性.\n2.3.5 字符串 文本值在计算机科学中可能是比数字要更一般的存在. 作为例子, Python程序的都是以文本进行编写以及存储. Python中作为文本的本地数据类型被叫做字符串, 而对应的构造器就是str.\n在Python中关于字符串的表现, 表达以及操作有很多的细节. 字符串是另一个丰富抽象的例子, 一个需要程序员承诺牢固地掌握的部分. 此部分会用作对基本字符串行为的简明介绍.\n字符串字面表达式通过用单引号或者双引号作为记号来包围可以表达任意的文本.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; \u0026#39;I am string!\u0026#39; \u0026#39;I am string!\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#34;I\u0026#39;ve got an apostrophe\u0026#34; \u0026#34;I\u0026#39;ve got an apostrophe\u0026#34; \u0026gt;\u0026gt;\u0026gt; \u0026#39;您好\u0026#39; \u0026#39;您好\u0026#39;   我们已经在代码中见识过字符串了, 如docstring, print函数的调用中, 以及在assert语句中的错误消息.\n字符串满足我们在本节最开始介绍的序列的两个基本条件: 它们具有长度以及支持元素选择.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; city = \u0026#39;Berkeley\u0026#39; \u0026gt;\u0026gt;\u0026gt; len(city) 8 \u0026gt;\u0026gt;\u0026gt; city[3] \u0026#39;k\u0026#39;   属于字符串本身也是字符串, 只不过它们只有一个字符. 字符是字母表的任意单个字符, 标点符号, 或者其他符号. 不像许多其他的编程语言, Python没有分开字符类型; 任何文本都是字符串, 单一一个字符代表一个长度为一的字符串.\n就像列表, 字符串也可以用加法或者乘法来进行结合.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; \u0026#39;Berkeley\u0026#39; + \u0026#39;, CA\u0026#39; \u0026#39;Berkeley, CA\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;Shabu \u0026#39; * 2 \u0026#39;Shabu Shabu \u0026#39;   成员. 字符串的行为发散自Python中的其他序列类型. 字符串抽象不符合我们描述的列表以及区间那样的全序列抽象, 尤其是, 当成员运算符in应用到字符串时, 却会有跟应用到序列上完全不同的行为表现. 它匹配的是子字符串而不是元素.\n1 2  \u0026gt;\u0026gt;\u0026gt; \u0026#39;here\u0026#39; in \u0026#34;Where\u0026#39;s Waldo?\u0026#34; True   多行文本. 字符串并不限制只有一行. 三重引号划定了字符串文本可以跨越多行的范围. 我们已经对docstring广泛使用这个三重引号了.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; \u0026#34;\u0026#34;\u0026#34;The Zen of Python claims, Readability counts. Read more: import this.\u0026#34;\u0026#34;\u0026#34; \u0026#39;The Zen of Python\\nclaims, \u0026#34;Readability counts.\u0026#34;\\nRead more: import this.\u0026#39;   在上面打印出来的结果中, 那个\\n(发音是\u0026quot;backlash en\u0026rdquo;)是一个单元素, 用来代表一个新行. 即使它是用两个字符来表示的(backslash 以及 n), 它在长度以及元素选择上依然被认为是单个字符.\n字符串强制转换. 一个字符串能够从Python的任何对象中通过调用str构造器函数以一个对象作为它的参数来构建. 这个字符串的特性对于从各种类型的对象中构造描述性的字符串是十分有用的.\n1 2  \u0026gt;\u0026gt;\u0026gt; str(2) + \u0026#39; is an element of \u0026#39; + str(digits) \u0026#39;2 is an element of [1, 8, 2, 8]\u0026#39;   深入阅读. 编码文本在计算机中是一个复杂的主题. 在这一章中, 我们会抽象出字符串是如何表示的细节. 然而, 对许多应用来说, 字符串是如何被计算机编码的特定细节是是必要的知识. 在The strings chapter of Dive Into Python3中提供了字符编码以及Unicode的描述\n2.3.6 树 我们有将一个列表作为另一个列表内的元素来使用的能力, 在我们的编程语言中提供了一种新的组合手段. 这种能力叫做数据类型的闭包属性. 一般来说, 如果组合数据的方法组合出来的结果本身可以用于这个组合方法就说这个组合方法具有闭包属性. 闭包是任何组合手段的关键源泉, 因为它允许我们去创建分层的结构\u0026ndash;由部件组成的结构, 而这个部件本身又是由其他部件构成的等等.\n我们可以在环境图中通过块以及指针符号对列表进行可视化, 一个列表描述为一系列包含列表中元素的相邻块. 原始值如数字, 字符串, 布尔值, 以及None值会出现在元素块中, 合成的数据, 如函数值, 以及其他列表, 会用一个箭头来表示.\n 将一个列表嵌套到另一个列表中会引入复杂性. 树是基本的数据抽象, 用于加强如何对分层数据进行结构化以及操作的规律性.\n一棵树有一个根值以及一系列的分支. 树的每一个分支都是一棵树. 一棵没有分支的树叫做叶子. 任何被包含在另一个树中的树都叫做棵树树的子树(就像一个分支的分支). 而一棵树的一棵子树的根值又被称作这棵树的一个节点(或者节点值).\n树的数据抽象由一个构造器tree以及选择器root和branches组合而成. 我们由最简单的版本开始.\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; def tree(root, branches = []): for branch in branches: assert is_tree(branch), \u0026#39;branches must be trees\u0026#39; return [root] + list[branches] \u0026gt;\u0026gt;\u0026gt; def root(tree): return tree[0] \u0026gt;\u0026gt;\u0026gt; def branches(tree): return tree[1:]   只有当树具有根值并且所有分支也是树时，才会形式一棵良好的树. is_tree函数是用在tree构造器中用来校验是否所有的分支都形成良好.\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; def is_tree(tree): if type(tree) != list or len(tree) \u0026lt; 1: return False for branch in branches(tree): if not is_tree(branch): return False return True   is_leaf函数用来检查一棵树是否有分支.\n1 2  \u0026gt;\u0026gt;\u0026gt; def is_leaf(tree): return not branches(tree)   树能够用嵌套表达式来构建, 下面的树t有根值3以及两个分支.\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; t = tree(3, [tree(1), tree(2, [tree(1), tree(1)])]) \u0026gt;\u0026gt;\u0026gt; t [3, [1], [2, [1], [1]]] \u0026gt;\u0026gt;\u0026gt; root(t) 3 \u0026gt;\u0026gt;\u0026gt; branches(t) [[1], [2, [1], [1]]] \u0026gt;\u0026gt;\u0026gt; root(branches(t)[1]) 2 \u0026gt;\u0026gt;\u0026gt; is_leaf(t) False \u0026gt;\u0026gt;\u0026gt; is_leaf(branches(t)[0]) True   树递归函数可以用来构造一棵树. 例如, 一棵n阶斐波那契树以n阶斐波那契数作为根值, 对于n \u0026gt; 1时, 两个分支也是斐波那契树. 一个斐波那契树演示了斐波那契数的树递归计算.\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; def fib_tree(n): if n == 0 or n == 1: return tree(n) else: left, right = fib_tree(n - 2), fib_tree(n - 1) fib_n = root(left) + root(right) return tree(fib_n, [left, right]) \u0026gt;\u0026gt;\u0026gt; fib_tree(5) [5, [2, [1], [1, [0], [1]]], [3, [1, [0], [1]], [2, [1], [1, [0], [1]]]]]   树递归函数也用于处理树. 例如, count_leaves函数用于统计树的树叶的量.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; def count_leaves(tree); if is_leaf(tree): return 1 else: branch_counts = [count_leaves(b) for b in branches(tree)] return sum(branch_counts) \u0026gt;\u0026gt;\u0026gt; count_leaves(fib_tree(5)) 8   分区树. 树可以用来表示整数的划分形式. 一个用最大为m的数划分数n来组成的分区树是一棵二叉树(两个分支), 代表了计算时候的两个选择. 在非叶子分区树中:\n 左边的(下标为0)分支包含了至少使用一个m来划分n的所有方式 右边的(下标为1)分支包含了用m-1部分来划分的分区树, 以及 根的值是m  分区树叶子的值表示了从树的根到叶的路径是否代表一个n的成功分区.\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; def partition_tree(n, m): if n == 0: return tree(True) elif n \u0026lt; 0 or m == 0: return tree(False) else: left == partition_tree(n - m, m) right == partition_tree(n, m - 1) return tree(m, [left, right]) \u0026gt;\u0026gt;\u0026gt; partition_tree(2, 2) [2, [True], [1, [1, [True], [False]], [False]]]   从一个分区树打印出分区是另外一个遍历树的树递归过程, 将每一个分区构造成一个列表. 不管是否能够触及True叶子, 分区树都会打印出来.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026gt;\u0026gt;\u0026gt; def print_parts(tree, partition = []): if is_leaf(tree): if root(tree): print(\u0026#39; +\u0026#39;.join(partition)) else: left, right = branches(tree) m = str(root(tree)) print_parts(left, partition + [m]) print_parts(right, partition) \u0026gt;\u0026gt;\u0026gt; print_parts(partition_tree(6, 4)) 4 + 2 4 + 1 + 1 3 + 3 3 + 2 + 1 3 + 1 + 1 + 1 2 + 2 + 2 2 + 2 + 1 + 1 2 + 1 + 1 + 1 + 1 1 + 1 + 1 + 1 + 1 + 1   2.3.7 链接列表 目前为止, 我们只用了原生的数据类型来表示序列. 然而, 我们也可以开发一个不是Python原生的序列表示. 一个序列的常见表示法是由嵌套的成对数据来构成, 叫做列表. 下面的环境图例表示出一个由四个按顺序包含1, 2, 3和4的元素组成的链表.\n 一个链表是一个成对的数据, 包含了序列的第一个元素(在例子中是1)以及剩下的元素的序列(在例子中是2, 3, 4). 第二个元素也是一个链表. 剩下的最里面的链表只包含4, 其余部分是empty, 一个用于代表空链表的值.\n链表具有递归结构: 链表的其余部分是一个链表或者empty值. 我们可以定义一个抽象数据表示来进行验证, 构造以及选择链表的某部分.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026gt;\u0026gt;\u0026gt; empty = \u0026#39;empty\u0026#39; \u0026gt;\u0026gt;\u0026gt; def is_link(s): \u0026#34;\u0026#34;\u0026#34;s is a linked list if it is empty or a (first, rest) pair.\u0026#34;\u0026#34;\u0026#34; return s == empty or (len(s) == 2 and is_link(s[1])) \u0026gt;\u0026gt;\u0026gt; def link(first, rest): \u0026#34;\u0026#34;\u0026#34;Construct a linked list from its first element and the rest.\u0026#34;\u0026#34;\u0026#34; assert is_link(rest), \u0026#39;rest must be a linked list.\u0026#39; return [first, rest] \u0026gt;\u0026gt;\u0026gt; def first(s): \u0026#34;\u0026#34;\u0026#34;Return the first element of a linked list s.\u0026#34;\u0026#34;\u0026#34; assert is_link(s), \u0026#39;first only applies to linked lists.\u0026#39; assert s != empty, \u0026#39;empty linked list has no first element.\u0026#39; return s[0] \u0026gt;\u0026gt;\u0026gt; def rest(s): \u0026#34;\u0026#34;\u0026#34;Return the rest of the elements of a linked list s.\u0026#34;\u0026#34;\u0026#34; assert is_link(s), \u0026#39;rest only applies to linked lists.\u0026#39; assert s != empty. \u0026#39;empty linked list has no rest.\u0026#39; return s[1]   上面, link是一个构造器, first以及rest是用于代表已经链接的列表抽象数据的选择器. 链表的行为条件是像数据对, 它的构造器以及选择器是其反函数.\n 如果一个链表s是由第一个元素是f以及一个已经是链表的r组成, 那么first(s)返回的是f, rest(s)返回的是r.  我们可以用构造器以及选择器来操纵链表.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; four = link(1, link(2, link(3, link(4, empty)))) \u0026gt;\u0026gt;\u0026gt; first(four) 1 \u0026gt;\u0026gt;\u0026gt; rest(four) [2, [3, [4, \u0026#39;empty\u0026#39;]]]   我们实现的这种类型的抽象数据是数据对, 一个具有两个元素的列表值. 值得注意的是, 我们也可以通过函数来实现对数据, 同时我们也可以用任何对数据来实现链表, 因此我们可以只用函数来实现链表.\n链表可以按顺序存储一系列的数据值, 但是我们还没有展示它满足序列抽象的那一部分. 使用我们定义的抽象数据表示, 我们可以实现序列的两个特征行为: 长度以及元素选择.\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; def len_link(s): \u0026#34;\u0026#34;\u0026#34;Return the length of linked list s\u0026#34;\u0026#34;\u0026#34; length = 0 while s != empty s, length = rest(s), length + 1 return length \u0026gt;\u0026gt;\u0026gt; def getitem_link(s, i): \u0026#34;\u0026#34;\u0026#34;Return the element at index i of linked list s.\u0026#34;\u0026#34;\u0026#34; while i \u0026gt; 0: s, i = rest(s), i - 1 return first(s)   现在, 我们可以用这些函数来把链表当做序列来操作. (我们现在还不能用內建的len函数, 元素选择语法, 或者for语句, 但是很快就可以了)\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; len_link(four) 4 \u0026gt;\u0026gt;\u0026gt; getitem_link(four, 1) 2   下面的一系列环境图例演示了getitem_link的找寻链表中下标为1的第二个元素的迭代过程. 下面, 我们已经用Python原语来简化图表来定义链表four. 这种实现选择违反了抽象边界, 但是允许我们更容易检视这个例子的计算过程\n 首先, 函数getitem_link被调用, 创建了一个本地帧:\n while头部的表达式计算得到true, 然后while的内部等式会被执行, 函数rest返回以2开头的子列表.\n 接下来, 局部名称s会更新成以原列表第二个元素为开头的子列表的引用. 运算while头部表达式现在会返回false值, 然后Python运算在返回语句之后的getitem_link的最后一行表达式.\n 最后的环境图例显示调用first的本地帧, 也就是含有绑定到同一个子列表的名称s. first函数选择值2然后返回, 也会从getitem_link中返回.\n这个例子演示了一个列表计运算的一般模式, 迭代操作中的每一步都会不断得到原列表中较短的后缀. 这查找列表长度以及元素的增量处理过程需要一些时间来运算. Python的內建序列类型是用不同形式实现的, 这让计算序列长度或者检索它的元素都不会导致很大的计算成本. 这种表现的细节已经超出本文的范围.\n递归操作. len_link以及getitem_link函数都是迭代的. 它们不断剥离每一层的嵌套数据对直到到达到达列表的最后(在len_link函数中)或者到达期望的元素(在getitem_link中).我们也可以用递归来实现长度以及元素选择.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; def len_link_recursive(s): \u0026#34;\u0026#34;\u0026#34;Return the length of a linked list s.\u0026#34;\u0026#34;\u0026#34; if s == empty: return 0 return 1 + len_link_recursive(rest(s)) \u0026gt;\u0026gt;\u0026gt; def getitem_link_recursive(s, i): \u0026#34;\u0026#34;\u0026#34;Return the element at index i of linked list s.\u0026#34;\u0026#34;\u0026#34; if i == 0: return first(s) return getitem_link_recursive(rest(s), i - 1) \u0026gt;\u0026gt;\u0026gt; len_link_recursive(four) 4 \u0026gt;\u0026gt;\u0026gt; getitem_link_recursive(four, 1) 2   这些递归实现跟随数据对组成的链直到到达列表的最后(在len_link_recursive中)或者到达期望的元素(在getitem_link_recursive中).\n递归对于转换以及合并链表也是有用的.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  \u0026gt;\u0026gt;\u0026gt; def extend_link(s, t): \u0026#34;\u0026#34;\u0026#34;Return a list with the elements of s followed by those of t.\u0026#34;\u0026#34;\u0026#34; assert is_link(s) and is_link(t) if s == empty: return t else: return link(first(s), extend_link(rest(s), t)) \u0026gt;\u0026gt;\u0026gt; extend_link(four, four) [1, [2, [3, [4, [1, [2, [3, [4, \u0026#39;empty\u0026#39;]]]]]]]] \u0026gt;\u0026gt;\u0026gt; def apply_to_all_link(f, s): \u0026#34;\u0026#34;\u0026#34;Apply f to each element of s.\u0026#34;\u0026#34;\u0026#34; assert is_link(s) if s == empty: return s else: return link(f(first(s)), apply_to_all_link(f, rest(s))) \u0026gt;\u0026gt;\u0026gt; apply_to_all_link(lambda x: x*x, four) [1, [4, [9, [16, \u0026#39;empty\u0026#39;]]]] \u0026gt;\u0026gt;\u0026gt; def keep_if_link(f, s): \u0026#34;\u0026#34;\u0026#34;Return a list with elements of s for which f(e) is true.\u0026#34;\u0026#34;\u0026#34; assert is_link(s) if s == empty: return s else: kept = keep_if_link(f, rest(s)) if f(first(s)): return link(first(s), kept) else: return kept \u0026gt;\u0026gt;\u0026gt; keep_if_link(lambda x: x%2 == 0, four) [2, [4, \u0026#39;empty\u0026#39;]] \u0026gt;\u0026gt;\u0026gt; def join_link(s, separator): \u0026#34;\u0026#34;\u0026#34;Return a string of all elements in s separated by separator.\u0026#34;\u0026#34;\u0026#34; if s == empty: return \u0026#34;\u0026#34; elif rest(s) == empty: return str(first(s)) else: return str(first(s)) + separator + join_link(rest(s), separator) \u0026gt;\u0026gt;\u0026gt; join_link(four, \u0026#34;, \u0026#34;) \u0026#39;1, 2, 3, 4\u0026#39;   递归构建. 链表在我们增量地构造序列的时候尤其有用, 这种情况经常在递归计算中出现.\n第一章中的count_partitions函数通过树递归过程来计算整数n用最大为m的数来进行分割的总数. 通过序列我们也可以通过明确地使用相似的过程来枚举这些切分.\n跟我们计算时一样, 我们用跟随问题的相同递归分析: 用最大为m的整数来划分n涉及到\n 使用最大为m的整数来划分n-m, 或者 使用最大为m-1的整数来划分n  对于基本情况, 我们发现用一个负整数或者用小于1的部分来划分0是不可能的, 因此0的划分数为空.\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; def partitions(n, m): \u0026#34;\u0026#34;\u0026#34;Return a linked list of partitions of n using parts of up to m. Each partition is represented as a linked list. \u0026#34;\u0026#34;\u0026#34; if n == 0: return link(empty, empty) # A list containing the empty partition elif n \u0026lt; 0 or m == 0: return empty else: using_m = partitions(n - m, m) with_m = apply_to_all_link(lambda s: link(m, s), using_m) without_m = partitions(n, m - 1) return extend_link(with_m, without_m)   在递归情况下, 我们构建两个分区的子列表. 第一个用m, 因此我们在结果using_m中的每个元素前面加上m来构建with_m.\npartitions的结果是高度嵌套的: 一个链接列表的链接列表, 并且每个链接列表被表示为作为列表值的嵌套对. 在join_link函数中用恰当的分隔符, 我们可以用人类可阅读的方式来展示出分区.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026gt;\u0026gt;\u0026gt; def print_partitions(n, m): lists = partitions(n, m) strings = apply_to_all_link(lambda s: join_link(s, \u0026#34; + \u0026#34;), lists) print(join_link(strings, \u0026#39;\\n\u0026#39;)) \u0026gt;\u0026gt;\u0026gt; print_partitions(6, 4) 4 + 2 4 + 1 + 1 3 + 3 3 + 2 + 1 3 + 1 + 1 + 1 2 + 2 + 2 2 + 2 + 1 + 1 2 + 1 + 1 + 1 + 1 1 + 1 + 1 + 1 + 1 + 1   2.4 可变数据 我们已经见识过抽象对于帮助我们应对大型系统的复杂性上的重要性了. 有效的编程依赖于有组织的能够指导我们在制定程序的整体设计的规则. 尤其是, 我们需要很多策略来帮助我们构造模块化的大型系统, 这意味着它们会自然分裂成各个相关的部分且能够分头开发以及维护.\n有一个强大的创建模块化程序的技术, 那就是合并可能随时间改变状态的数据, 通过这种方式, 单个数据对象可以表示独立于程序的其余部分演进的东西. 改变对象的行为可能会受到其历史的影响, 就像一个真实世界的实体一样. 为数据添加状态是面向对象编程范式的核心要素\n2.4.1 对象隐喻 在本文开头, 我们要区分函数跟数据: 函数用于执行操作, 而数据则是在其上被操作. 当我们在我们的数据中包含函数的值的时候, 我们认识到数据也可以具有行为. 函数可以作为数据来操作, 也可以被调用来执行计算.\n对象将数据值与行为进行组合. 对象代表信息, 同时也表现得像它们所代表的事物. 一个对象跟另一个对象互动的逻辑是跟编码这个对象的值捆绑在一起的. 当一个对象需要被打印出来时, 它知道如何用文本来表示自身, 如果一个对象是由部分组合而成的, 那么它知道如何按需显示这些部分. 对象(包含的)全都是信息以及(处理)过程, (它们)捆绑在一起来表示复杂事物的性质, 相互作用和行为.\n对象的行为在Python中是通过专门的对象语法以及相关术语来实现的, 我们可以通过例子来进行介绍, 一个日期是一个对象.\n1  \u0026gt;\u0026gt;\u0026gt; from datetime import date   名称date绑定到一个类上的. 正如我们看到的, 一个类代表一种值. 个别的日期就叫做这个类的实例. 实例能够通过使用表明这个实例的特征参数来调用类来构建.\n1  \u0026gt;\u0026gt;\u0026gt; tues = date(2014, 5, 13)   当用原始数字构造tues之后, 它的行为表现得像日期一样, 例如, 将它跟其他的日期相减会返回一个时差, 我们可以打印出来.\n1 2  \u0026gt;\u0026gt;\u0026gt; print(date(2014, 5, 19) - tues) 6 days, 0:00:00   对象具有属性, 是一个命名后的对象的一部分的值. 在Python中, 像很多其他的编程语言一样, 我们用点符号来指定一个对象的属性.\n\u0026lt;expression\u0026gt; . \u0026lt;name\u0026gt;\n上面, \u0026lt;expression\u0026gt;是一个对象, 然后\u0026lt;name\u0026gt;是一个对象属性的名称. 不我们至今为止考虑过的名称, 属性名对于点符号前面的对象实例来说是独特的.\n1 2  \u0026gt;\u0026gt;\u0026gt; tues.year 2014   对象通常也有方法, 也就是属性值为函数的属性. 隐含的意思是, 我们认为这个对象\u0026quot;知道\u0026quot;如何去执行这些方法. 通过实现, (对象)方法是一个用来从它们的参数以及它们的对象中计算结果的函数. 例如, tues有一个strftime方法(一个经典函数的名称, 意思是\u0026quot;字符串格式的时间\u0026rdquo;)接受一个参数用于指定如何显示日期(例如: %A表示这周的某一天应该完整地拼写出来).\n1 2  \u0026gt;\u0026gt;\u0026gt; tues.strftime(\u0026#34;%A, %B %d\u0026#34;) \u0026#39;Tuesday, May 13\u0026#39;   计算strftime的返回值需要两个输入: 一个用于描述输出格式的字符串以及绑定在tues中的日期信息. 特定日期逻辑需要应用这个方法来返回结果. 我们从来没有说过2014年5月13号是星期二, 但是知道它对应的是工作日的一部分, 这就意味着它是一个日期. 通过将行为以及信息绑定到一起, 这个Python对象提供给我们一个可信的, 自足的日期抽象.\n日期是一个对象, 而且数字, 符串吗, 列表以及区间等也全都是对象. 它们代表一个值, 而且还以符合它们表示的值的方式表现. 它们也有属性以及方法. 比如, 字符串具有一个数组方法用于方便文本处理.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; \u0026#39;1234\u0026#39;.isnumeric() True \u0026gt;\u0026gt;\u0026gt; \u0026#39;rOBERT dE nIRO\u0026#39;.swapcase() \u0026#39;Robert De Niro\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;eyes\u0026#39;.upper().endswith(\u0026#39;YES\u0026#39;) True   实际上, 在Python中所有的值都是对象, 也就是说, 所有值都具有行为以及属性. 它们的行为就像它们所代表的值.\n2.4.2 序列对象 原始內建的值的实例如数字是不可变的. 这个值在程序的执行过程中是不可变的. 而另一方面列表则是可变的.\n可变对象用来代表随时间变化的值. 一个人是在今天到明天依然是同一个人, 尽管变得老了, 剪了头发, 或者以某种方式改变了. 同样地, 一个对象的属性可能会由于可变操作而改变了属性. 例如, 可以改变列表中的内容. 大多数改变通过调用执行列表对象内部的方法.\n我们可以通过一个说明扑克牌历史的例子(大大简化)来介绍很多列表的修改操作. 在例子的注释中, 描述了每个方法调用的结果.\n扑克牌是在中国发明的, 大约在9世纪. 较早的扑克牌只有三种花式, 分别跟钱的面额对应起来.\n1 2  \u0026gt;\u0026gt;\u0026gt; chinese = [\u0026#39;coin\u0026#39;, \u0026#39;string\u0026#39;, \u0026#39;myriad\u0026#39;] # 一个文字列表 \u0026gt;\u0026gt;\u0026gt; suits = chinese # 两个名字对应同一个列表   随着扑克牌传入欧洲(可能是通过埃及), 只有coin那那个花式还存在西班牙的牌桌上(oro).\n1 2 3  \u0026gt;\u0026gt;\u0026gt; suits.pop() # 删除最后一个元素并返回 \u0026#39;myriad\u0026#39; \u0026gt;\u0026gt;\u0026gt; suits.remove(\u0026#39;string\u0026#39;) # 删除跟参数相等的第一个元素   新增了三个花式(它们的名字还有设计进行了几次更改).\n1 2  \u0026gt;\u0026gt;\u0026gt; suits.append(\u0026#39;cup\u0026#39;) # 添加一个元素到最后 \u0026gt;\u0026gt;\u0026gt; suits.extend([\u0026#39;sword\u0026#39;, \u0026#39;club\u0026#39;]) # 将所有的元素添加到序列的最后   然后意大利人将剑叫做锹.\n1  \u0026gt;\u0026gt;\u0026gt; suits[2] = \u0026#39;spade\u0026#39; # 替代一个元素   得到一副传统的意大利扑克牌.\n1 2  \u0026gt;\u0026gt;\u0026gt; suits [\u0026#39;coin\u0026#39;, \u0026#39;cup\u0026#39;, \u0026#39;spade\u0026#39;, \u0026#39;club\u0026#39;]   今天美国用的扑克牌是法国的变种, 修改了前两个花式:\n1 2 3  \u0026gt;\u0026gt;\u0026gt; suits[0:2] = [\u0026#39;heart\u0026#39;, \u0026#39;diamond\u0026#39;] # 修改一个切片 \u0026gt;\u0026gt;\u0026gt; suits [\u0026#39;heart\u0026#39;, \u0026#39;diamond\u0026#39;, \u0026#39;spade\u0026#39;, \u0026#39;club\u0026#39;]]   还存在用于插入, 排序, 以及翻转列表的方法. 所有这些变动的操作都会修改列表的值; 它们不会创建一个新的列表对象.\n共享和标识. 由于我们已经修改单个列表, 而不是创建一个新的列表, 因此对象绑定的名称chinese的值同样也会改变, 因为它跟suits绑定的是同一个列表对象.\n1 2  \u0026gt;\u0026gt;\u0026gt; chinese # 名称跟\u0026#34;suits\u0026#34;共同指代同一个被修改的列表 [\u0026#39;heart\u0026#39;, \u0026#39;diamond\u0026#39;, \u0026#39;spade\u0026#39;, \u0026#39;club\u0026#39;]   这种行为是新的. 早先, 如果一个名称没有出现在一个语句中, 那么它的值就不会被这个语句影响到. 对于可变数据, 在一个名称上调用方法能够同时影响到其他的名称.\n对于这里例子, 下面的运行环境图展示了跟chinese名称绑定的值是如何在只涉及到suits的语句中被修改的. 观察例子中的每一个步骤来查看这些改变.\n 列表对象可以用列表构造器函数来复制. 修改一个列表不会影响到另外一个, 除非它们共享相同的数据结构.\n1 2  \u0026gt;\u0026gt;\u0026gt; nest = list(suits) # 绑定\u0026#34;nest\u0026#34;到第二个具有相同元素的列表中 \u0026gt;\u0026gt;\u0026gt; nest[0] = suits # 创建一个嵌套的列表   根据这种环境, 通过suits引用来修改列表会影响到nest的第一个元素的那个内嵌的列表, 但是不会对其他的元素有影响.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; suits.insert(2, \u0026#39;Joker\u0026#39;) # 在下标为2的地方插入一个元素, 其他的元素进行响应的移位 \u0026gt;\u0026gt;\u0026gt; nest [[\u0026#39;heart\u0026#39;, \u0026#39;diamond\u0026#39;, \u0026#39;Joker\u0026#39;, \u0026#39;spade\u0026#39;, \u0026#39;club\u0026#39;], \u0026#39;diamond\u0026#39;, \u0026#39;spade\u0026#39;, \u0026#39;club\u0026#39;]   同样地, 在nest的第一个元素中撤销这个改动同样也会影响到suit\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; nest[0].pop(2) \u0026#39;Joker\u0026#39; \u0026gt;\u0026gt;\u0026gt; suits [\u0026#39;heart\u0026#39;, \u0026#39;diamond\u0026#39;, \u0026#39;spade\u0026#39;, \u0026#39;club\u0026#39;]    因为两个列表有可能会有相同的内容, 但是实际上是两个不同的列表, 我们需要一个手段来测试两个对象是否是相同的. Python含有两个比较操作符, 叫做 is 以及 is not, 用来测试两个表达式实际上是否得到的是相同的对象. 如果两个对象它们的当前值是一样的, 然后任何一个的改动都会反映到另一个对象中, 那么两个对象是相等的. 身份标识是比相等性更强的条件.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; suits is nest[0] True \u0026gt;\u0026gt;\u0026gt; suits is [\u0026#39;heart\u0026#39;, \u0026#39;diamond\u0026#39;, \u0026#39;spade\u0026#39;, \u0026#39;club\u0026#39;] False \u0026gt;\u0026gt;\u0026gt; suits == [\u0026#39;heart\u0026#39;, \u0026#39;diamond\u0026#39;, \u0026#39;spade\u0026#39;, \u0026#39;club\u0026#39;] True   最后两个比照说明了 == 跟 is 两者的不同, 前者检查身份, 而后者则是检查内容的的相等性\n列表推导. 一个列表推导总是会创建一个新的列表. 例如, unicodedata模块跟踪Unicode字母表中每一个字符的官方名称. 我们可以查找与名称相对应的字符, 包括那些扑克牌的花式.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; from unicodedata import lookup \u0026gt;\u0026gt;\u0026gt; [lookup(\u0026#39;WHITE \u0026#39; + s.upper() + \u0026#39; SUIT\u0026#39;) for s in suits] [\u0026#39;♡\u0026#39;, \u0026#39;♢\u0026#39;, \u0026#39;♤\u0026#39;, \u0026#39;♧\u0026#39;]   这些结果列表并没有将它的内容跟suits进行共享, 执行列表表达式也不会改动到suits列表.\n你可以在Dive into Python 3中的Unicode章节中, 查看更多相关的用于表示文本的Unicode标准.\n元组\n一个元组, 是一个內建的tuple类型的实例, 是一个不可变序列. 是用元组字面量, 也就是用逗号分割元素来创建的. 括号是可选的, 但是在实践中经常使用. 任何对象都可以放在元组中.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; 1, 2 + 3 (1, 5) \u0026gt;\u0026gt;\u0026gt; (\u0026#34;the\u0026#34;, 1, (\u0026#34;and\u0026#34;, \u0026#34;only\u0026#34;)) (\u0026#39;the\u0026#39;, 1, (\u0026#39;and\u0026#39;, \u0026#39;only\u0026#39;)) \u0026gt;\u0026gt;\u0026gt; type( (10, 20) ) \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt;   空的或者拥有一个元素的元组具有特殊的字面语法.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; () # 0 elements () \u0026gt;\u0026gt;\u0026gt; (10,) # 1 element (10,)   像列表, 元组具有有限的长度, 同时也支持元素选择. 它们同样也具有一些可用于列表的方法, 例如count以及index.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; code = (\u0026#34;up\u0026#34;, \u0026#34;up\u0026#34;, \u0026#34;down\u0026#34;, \u0026#34;down\u0026#34;) + (\u0026#34;left\u0026#34;, \u0026#34;right\u0026#34;) * 2 \u0026gt;\u0026gt;\u0026gt; len(code) 8 \u0026gt;\u0026gt;\u0026gt; code[3] \u0026#39;down\u0026#39; \u0026gt;\u0026gt;\u0026gt; code.count(\u0026#34;down\u0026#34;) 2 \u0026gt;\u0026gt;\u0026gt; code.index(\u0026#34;left\u0026#34;) 4   然而, 对于那些操作列表内容的方法在元组中是不可用的, 因为元组是不可变的.\n因此无法改变元组中的元素, 但是可以修改一个包含在元组中的可变元素的值.\n 多重赋值中隐式地使用元组, 一个将两个值绑定到两个名称中的赋值语句会创建两个元素的元组然后对它进行解包.\n2.4.3 字典 字典在Python中是一个內建的数据类型, 用来存储以及操作对应关系. 一个字典包含有多个键值对, 键跟值都是对象. 字典的目的是提供一个抽象化的用于存储以及检索数据并不以连续的整数而是描述性的键值为下标的地方.\n通常用字符串来作为键值, 因为我们常用一个字符串名称来表示一样东西. 这个字典字面量给定各种罗马数字的值.\n1  \u0026gt;\u0026gt;\u0026gt; numerals = {\u0026#39;I\u0026#39;: 1.0, \u0026#39;V\u0026#39;: 5, \u0026#39;X\u0026#39;: 10}   使用元素选择操作符通过它们的键来查看我们先前应用于序列的对应的值.\n1 2  \u0026gt;\u0026gt;\u0026gt; numerals[\u0026#39;X\u0026#39;] 10   一个字典中每一个键最多只能有一个对应的值. 添加新的键值对或者通过键来修改已经存在的值都可以通过赋值语句实现.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; numerals[\u0026#39;I\u0026#39;] = 1 \u0026gt;\u0026gt;\u0026gt; numerals[\u0026#39;L\u0026#39;] = 50 \u0026gt;\u0026gt;\u0026gt; numerals {\u0026#39;I\u0026#39;: 1, \u0026#39;X\u0026#39;: 10, \u0026#39;L\u0026#39;: 50, \u0026#39;V\u0026#39;: 5}   注意到, L的值在前面的输出结果中是没有添加的. 字典是无序的键值对集合. 当我们输出一个字典, 键跟值会以某种顺序渲染, 而作为语言的用户, 我们无法预知将会按照何种顺序渲染. 当多次运行程序时这种顺序可能会改变.\n字典也可以在环境图例中出现.\n 字典类型也支持多种用于迭代它包含的作为一个整体的字典内容的方法, keys, values以及items都返回一个可迭代的值\n1 2  \u0026gt;\u0026gt;\u0026gt; sum(numerals.values()) 66   由键值对形式组成的列表可以通过调用dict构造函数来转化成一个字典.\n1 2  \u0026gt;\u0026gt;\u0026gt; dict([(3, 9), (4, 16), (5, 25)]) {3: 9, 4: 16, 5: 25}   字典也具有一些限制:\n 字典中的一个键不能对应多个值 对于一个给定的键最多只能有一个值.  第一个限制是跟Python字典底层实现相绑定的. 这个限制的细节不是本文的主题. 可以直观地认为键告诉Python在内存中哪里去找这个键值对; 如果这个key值改变了这个对的位置可能就会不见了. 元组通常也是可以在字典中作为键, 因为列表不可以用作键值.\n第二个限制是字典抽象的一个必然结果, 那就是设计用一个键来存储以及检索一个值. 如果最多只有一个这样的值存在于字典当中, 我们只能用一个键来检索这个值.\n一个由字典来执行的有用的方法是get, 这个方法要么会返回一个存在的键所对应的值, 要么返回一个默认值. 而get方法的参数就是键以及默认值.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; numerals.get(\u0026#39;A\u0026#39;, 0) 0 \u0026gt;\u0026gt;\u0026gt; numerals.get(\u0026#39;V\u0026#39;, 0) 5   字典也有一个类似于列表的解析式语法. 一个键表达式以及一个值表达式通过一个冒号隔开, 执行一个字典解析会创建一个新的字典对象.\n1 2  \u0026gt;\u0026gt;\u0026gt; {x: x*x for x in range(3,6)} {3: 9, 4: 16, 5: 25}   2.4.4 本地状态 列表跟字典都有本地状态: 它们在程序运行的任意一个点上修改具有特定内容的值. \u0026ldquo;状态\u0026quot;这个词暗示了一个演变的过程, 表示这个状态可能会改变.\n函数也可以具有本地状态. 例如, 让我们定义一个函数用于模拟从一个银行账户中提款的过程. 我们会创建一个叫做withdraw的函数, 它把一个数额作为它的参数. 如果这个账户具有足够的金额用于提款, 那么withdraw会返回提款后的剩余余额. 否则, withdraw会返回信息\u0026rsquo;资金不足\u0026rsquo;, 例如, 如果我们开始有$100在账户内, 我们会希望调用withdraw后能够得到下面的一系列的返回值\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; withdraw(25) 75 \u0026gt;\u0026gt;\u0026gt; withdraw(25) 50 \u0026gt;\u0026gt;\u0026gt; withdraw(60) \u0026#39;Insufficient funds\u0026#39; \u0026gt;\u0026gt;\u0026gt; withdraw(15) 35   上面表达式withdraw(25), 运算了两次, 返回了不同的值. 因此, 这个用户定义函数是不纯的. 调用这个函数不仅返回一个值, 同时还会带有副作用以某种方式来改变这个函数, 因此下一次用相同的参数来调用函数会返回不同的值. 这个副作用是由withdraw函数更改当前环境的一个外部名称值的绑定而造成的.\n为了让withdraw函数有意义, 它必须用一个具有余额的初始的账户来创建. 而函数make_withdraw是一个更高层次的函数, 需要一个初始余额作为参数. 而函数withdraw则是它的返回值.\n1  \u0026gt;\u0026gt;\u0026gt; withdraw = make_withdraw(100)   make_withdraw的一个实现需要一种新类型的语句: 一个非本地的声明. 当我们调用make_withdraw时, 我们绑定名称balance到一个初始账户中. 然后我们定义并返回一个本地函数withdraw, 当调用这个函数时会更新以及返回balance的值.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; def make_withdraw(balance): \u0026#34;\u0026#34;\u0026#34;Return a withdraw function that draws down balance with each call.\u0026#34;\u0026#34;\u0026#34; def withdraw(amount): nonlocal balance if amount \u0026gt; balance: return \u0026#39;Insufficient funds\u0026#39; balance = balance - amount return balance return withdraw   nonlocal语句声明了无论任何时候我们改变名称balance的绑定值, 都会反映到这个balance第一个找到的绑定值的环境帧里面. 回想一下没有nonlocal声明, 一个赋值语句总是会绑定绑定一个名称到它的当前环境的第一个帧里面. 这个nonlocal语句表示名称出现在环境中除第一(本地)帧或最后(全局)帧之外的某处.\n接下来的环境图例演示了多次调用make_withdraw创建的函数的影响.\n 第一个def语句具有通常的效果: 它创建了一个新的用户定义函数并在全局环境绑定名称make_withdraw到这个函数. 而随后调用make_withdraw创建并返回了一个本地定义的函数withdraw. 名称balance绑定在这个函数的父级帧中. 至关重要的是, 在该示例的其余部分中将仅存在用于名称balance的单个绑定.\n接下来, 我们执行一个表达式来用金额为5的参数来调用这个绑定到名称wd上的函数. withdraw的函数体执行在新的拓展自withdraw被定义的的环境中. 跟踪函数withdraw的运行, 演示了nonlocal语句在Python中的效果: 一个在第一个局部帧外面的的名称能够通过赋值语句来修改.\n nonlocal声明在withdraw的定义内修改所有剩余的赋值语句. 在执行nonlocal balance之后, 任何跟balance相关的把它放在等号左边的赋值语句都不会绑定balance到当前环境的第一帧里去. 相反, 它会找到balance已经被定义的第一个帧然后在这一帧内将把名称进行重新的绑定. 如果balance之前并没有跟一个值进行绑定, 那么nonlocal语句会抛出一个错误.\n通过修改balance的绑定, 我们也修改了withdraw函数. 下一次它被调用时, 名称balance会执行15而不是20. 因此, 当我们第二次调用withdraw时, 我们会看到它返回值12而不是17. 第一次调用对balance的修改会反映到第二次调用的结果中去.\n 通常来说, 第二次调用withdraw会创建第二个本地帧. 然而, 两个withdraw帧具有相同的父级. 也就是说, 它们都拓展自那个包含有balance的绑定的make_withdraw的环境中. 因此, 它们共享那个特定的名称绑定. 调用withdraw函数具有改变环境的局部影响, 且会把这个影响延展到withdraw未来的调用中去. nonlocal声明允许withdraw函数来改变make_withdraw帧中的名称的绑定.\n自从我们第一次遇到嵌套的def语句以来, 我们已经意识到本地定义函数可以访问它本地帧以外的名称. 访问非本地名称不需要nonlocal语句. 相比之下, 只有在nonlocal声明之后, 一个函数才能在这些帧里面修改名称的绑定.\n通过介绍nonlocal声明, 我们已经为赋值语句创建了一个双重角色. 不管它们是修改本地绑定, 还是修改nonlocal绑定. 实际上, 赋值语句已经具有了双重性, 它们不仅可以创建新的绑定也可以重新绑定已经存在的名称. 赋值也可以修改列表以及字典的内容. Python中赋值中的许多角色会掩盖执行赋值语句的影响. 这取决于你作为一个程序员是如何文档化你的代码以清晰地表明赋值的影响来让其他人可以明白.\nPython细节. 这种non-local模式的赋值是一个具有高阶函数以及词法作用域的编程语言的一般特性. 大部分其他的编程语言一点都不需要nonlocal声明. 反而, non-local赋值通常是赋值语句的默认行为.\nPython对于名称的查找也具有一个不同寻常的限制: 在函数体内, 所有的名称的实例必须要指向同一帧. 因此, Python在一个non-local帧内不能查找到名称的值, 并绑定相同的名称到本地帧内, 因为相同的名称会在两个不同的帧内被同一个程序访问到. 这个限制允许Python在函数体执行前预先计算包含每个名称的帧. 当这个限制被违反时, 会产生混乱的错误结果信息. 作为演示, 下面重复make_withdraw示例, 并去除nonlocal语句.\n 出现了这个UnboundLocalError错误是因为balance在第五行被本地分配了一个本地值, 因此Python假设所有对balance的引用也必须出现在本地帧内. 这个错误出现在第五行被执行前, 意味着Python在执行第三行之前已经以某种方式考虑了第五行. 当我们学习解析器设计时, 我们会了解到在函数体执行之前进行预编译是相当普遍的事情. 在这个例子中, Python的预编译限制帧内可能出现balance, 因此预先阻止找到该名称. 添加一个nonlocal声明可以修复这个错误. nonlocal声明在Python 2中是不存在的.\n非本地赋值的好处 非本地赋值在我们将程序看作是一个独立与自治的对象(也就是对象之间相互交互但各自管理他们自己内部的状态)的路上是重要的一步.\n尤其是非本地赋值赋予了我们能力来管理一些函数的内部状态, 但是在调用这个函数时会发展出过度的连续性. balance与特定的withdraw函数相联系并共享于这函数的所有调用中. 然而为balance绑定到相联系的withdraw实例在程序的其余地方是不可访问的. 只有wd在它定义的make_withdraw帧内是可访问的. 如果make_withdraw再次被调用那么它会创建包含一个单独的balance绑定的一个单独的帧.\n我们可以扩展我们的例子来演示这一点. 第二次调用make_withdraw返回第二个具有一个不同父级的withdraw函数.我们绑定这第二个函数到全局帧的名称wd2上.\n 现在我们可以看到那里其实有两个对balance的绑定在两个不同的帧里面，同时每一个withdraw函数都有一个不同的父级. 名称wd绑定到一个具有balance为20的函数上, 同时wd2绑定到一个具有balance为7的不同函数上.\n调用wd2会修改它的非本地绑定名称balance, 但不会影响绑定到withdraw名称的函数. wd之后的调用不会受到wd2中改变的balance的影响, 它的balance依然是20\n 通过这种方式, 每一个withdraw的实例维护着它自己的balance状态, 但是这个状态对于程序中其他任何一个函数来说都是不可访问的. 在高层级来看这种情况, 我们已经创建了一个会管理它自己的内部但是以某种方式活动的生活中的账户模型的银行账户的抽象.\n2.4.6 非本地赋值的成本 我们的计算环境模型清晰地拓展到解释非本地赋值的影响. 然而, 非本地赋值介绍了一些在我们思考名称以及值的方式上的重要的细微差别.\n之前, 我们的值是不会修改的; 只有我们的名称以及绑定会修改, 当两个名称a以及b都绑定到一个值 4 上时, 它们是否绑定到相同的或者是不同的 4 是无所谓的, 据我们所知, 只有一个 4 对象且从不改变.\n然而, 具有状态的函数不是以这种行为方式. 当两个名称 wd 以及 wd2 都绑定到一个withdraw函数上时, 对于它们是否绑定到同一个函数或者这个函数的不同实例上是有关系的. 考虑一下下面的例子, 它与我们刚刚分析的例子相对比. 在这种情况下, 调用命名为 wd2 的函数会修改命名为 wd 的函数的值, 因为这些名字都是引用同一个函数.\n 世界上用两个名称共同引用同一个值是很常见的, 所以它存在我们的程序当中. 但是, 值会随着时间而变化, 我们必须要小心理解对于修改其他名称而影响到这些名称会带来的结果.\n正确地分析带有分本地赋值的代码的关键是要记住, 只有函数调用可以引入新的帧. 赋值语句总是在已存在的帧内修改绑定. 在这种情况下, 除非调用make_withdraw两次, 否则只能绑定一次balance.\n相同和改变. 提出这些细微之处是因为随着会修改分本地环境的非纯函数的引入, 我们已经改变了表达式的性质. 一个表达式只包含纯函数调用的话是可靠透明的; 如果我们用其子表达式的值替换其子表达式之一, 它的值不会修改.\n重新绑定操作符违反了透明引用这个条件因为它们除了返回一个值还做了更多的事情; 它们修改了环境. 当我们引入任意重绑定, 我们就遇到了一个棘手的认识论问题: 它意味着两个值是相等的. 在我们的计算环境模型中, 分别定义的两个函数不是相同的, 因为修改一个应该不会关联到另外一个.\n一般来说, 只要我们从来没有修改数据对象, 我们可以认为复合数据对象恰好就是它所有部分的总和. 例如, 一个有理数取决于给定它一个分子和分母. 但是这种观点在存在变化的情况下已经不在有效, 也就是一个复合数据对象具有一个\u0026quot;身份标识\u0026rdquo;, 用来跟它组成的片段来进行区分的. 一个银行账户依然是\u0026quot;同一个\u0026quot;银行账户, 即使我们通过支取来修改了余额; 反过来, 我们可以有两个恰巧有相同余额的账户, 但是是两个不同的对象.\n尽管它引入了复杂性, 非本地赋值依然是一个创建模块化程序的强力工具. 程序的不同部分对应着不同的环境帧, 能够随着软件的执行来分别演进. 此外, 使用带有本地状态的函数, 我们能够实现可变数据类型. 实际上, 我们可以实现相当于上面提到的內建的list以及dict类型的抽象数据类型.\n2.4.7 列表以及字典的实现 Python语言并不允许我们访问列表的实现, 只是內建了序列抽象以及变动方法到语言里面去. 可以通过具有本地状态的函数来理解可变列表是如何进行表示的, 现在我们将会开发一个可变的链表实现.\n我们会通过一个具有链表作为它的本地状态的函数来表现一个可变链表, 列表需要有一个身份, 就像其他任何可变值. 尤其是, 我们不能用 None 来代表一个空的可变列表, 因为两个空的列表不是相同的值(例如: 为其中一个列表插入元素并不会插入到另一个当中), 但是 None 就是 None. 另一方面, 两个都具有empty作为它的本地状态的不同的函数将足以用来区分两个空列表.\n如果一个可变链表是一个函数, 它会需要什么传入什么参数呢? 答案展示了编程中的一般模式: 这个函数是一个调度函数同时它的参数首先是一个消息, 后面跟着参数化该方法的其他参数. 这个消息是一个字符串名称表示这个函数应该做什么. 调度函数实际上集合了许多的函数: 用消息确定函数的行为, 以及将额外的参数用在这个行为上.\n我们的可变列表会回应5种不同的消息: len, getitem, push_first, pop_first, 以及str. 前两个实现序列抽象的行为. 接下来的两个用于增加或者移除列表的第一个元素. 最后一个消息返回代表整个链表的字符串.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026gt;\u0026gt;\u0026gt; def mutable_link(): \u0026#34;\u0026#34;\u0026#34;Return a functional implementation of a mutable linked list.\u0026#34;\u0026#34;\u0026#34; contents = empty def dispatch(message, value=None): if message == \u0026#39;len\u0026#39;: return len_link(contents) elif message == \u0026#39;getitem\u0026#39;: return getitem_link(contents, value) elif message == \u0026#39;push_first\u0026#39;: contents = link(value, contents) elif message == \u0026#39;pop_first\u0026#39;: f = first(contents) contents = rest(contents) return f elif message == \u0026#39;str\u0026#39;: return join_link(contents, \u0026#39;, \u0026#39;) return dispatch   我们也可以增加一个简便函数来从任何的內建序列中构造一个实现了功能的链表, 简单地相反的顺序来添加每一个元素.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; def to_mutable_link(source): \u0026#34;\u0026#34;\u0026#34;Return a functional list with the same contents as source.\u0026#34;\u0026#34;\u0026#34; s = mutable_link() for element in reversed(source) s(\u0026#39;push_first\u0026#39;, element) return s   在上面的定义中, 函数reversed接受并返回一个可迭代的值; 这是另一个函数处理序列的例子.\n到现在, 我们可以构造一个实现了功能的可变链表. 要注意这个链表本身是一个函数.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; s = to_mutable_link(suits) \u0026gt;\u0026gt;\u0026gt; type(s) \u0026lt;class \u0026#39;function\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(s(\u0026#39;str\u0026#39;)) heart, diamond, spade, club   此外, 我们可以输入信息到列表 s 来改变它的内容, 为实例移除它的第一个元素.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; s(\u0026#39;pop_first\u0026#39;) \u0026#39;heart\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(s(\u0026#39;str\u0026#39;)) diamond, spade, club   原则上, push_first以及pop_first足以对列表进行任意更改. 我们可以总是清空整个列表然后用期望的结果来替换它的旧内容.\n消息传递. 给定一些时间, 我们可以实现很多Python列表的有用的变动操作. 例如extend以及insert. 对此我们可以进行选择: 我们可以使用已存在的消息pop_first以及push_first来进行所有的更改将它们都实现在一个函数里面. 或者, 我们可以添加额外的elif条件到dispatch函数体中, 每一个对一种消息进行检查(例如: extend)以及直接应用适当的修改到内容当中.\n第二种方法, 就是将所有操作的逻辑封装到响应不同消息的一个函数内的数据值上, 这是一种称为消息传递的规则. 一个使用消息传递来定义调度函数的程序, 每一个这种函数都可以具有局部状态, 以及通过传递\u0026quot;消息\u0026quot;作为第一个参数来组织计算. 消息是对应特殊行为的字符串.\n实现字典. 我们还可以实现一个具有跟字典类似行为的值. 在这种情况下, 我们用一个键值对的列表来保存字典的内容. 每个对是一个两个元素的列表.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026gt;\u0026gt;\u0026gt; def dictionary(): \u0026#34;\u0026#34;\u0026#34;Return a functional implementation of a dictionary.\u0026#34;\u0026#34;\u0026#34; records = [] def getitem(key): matches = [r for r in records if r[0] == key] if len(matches) == 1: key, value = matches[0] return value def setitem(key, value): nonlocal records non_matches = [r for r in records if r[0] != key] records = non_matches + [[key, value]] def dispatch(message, key=None, value=None): if message == \u0026#39;getitem\u0026#39;: return getitem(key) elif message == \u0026#39;setitem\u0026#39;: setitem(key, value) return dispatch   再一次, 我们用消息传输方法来组织我们的实现. 我们已经支持两个消息: getitem和setitem. 为一个键插入一个值, 我们过滤出任何给定键的存在记录, 然后添加一个. 通过这种方式, 我们保证每一个键值在记录中只出现一次. 要为一个键找出它的值, 我们过滤出符合给定的键的值. 我们现在可以用我们的实现来保存以及检索值.\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; d = dictionary() \u0026gt;\u0026gt;\u0026gt; d(\u0026#39;setitem\u0026#39;, 3, 9) \u0026gt;\u0026gt;\u0026gt; d(\u0026#39;setitem\u0026#39;, 4, 16) \u0026gt;\u0026gt;\u0026gt; d(\u0026#39;getitem\u0026#39;, 3) 9 \u0026gt;\u0026gt;\u0026gt; d(\u0026#39;getitem\u0026#39;, 4) 16   这种实现的字典没有为快速查找作优化, 因为每一次调用必须要过滤全部的记录. 內建的字典类型是十分高效的. 它的实现方式超出了本文的范围.\n2.4.8 调度字典 调度函数是为抽象数据实现消息传递接口的一般方法. 为了实现消息调度, 迄今为止我们使用条件语句来对比消息字符串跟已知消息的固定集.\n內建的字典数据类型提供一个一般的方法来查找一个键的值. 而不是使用条件来实现派发, 我们可以用字符串作为字典的键.\n下面的可变account数据类型实现为一个字典. 它有一个构造器account以及一个选择器check_balance, 以及用于存储(deposit)或者取出(withdraw)资金的函数. 此外, 账户的本地状态也被保存在字典周围实现它的功能的函数中.\n account构造器函数体内的dispatch到一个包含由帐户接受的消息作为键的字典进行绑定. 当存款以及取款消息绑定跟函数绑定, 余额就是一个数字. 这些函数能够访问dispatch字典, 同时, 它们也可以查看以及修改余额. 通过保存余额在dispatch字典中而不是直接保存在在account函数帧中, 我们避免了在deposit以及withdraw中需要用到nonlocal声明.\n+=以及-=操作是Python(以及其他许多语言)中用于组合查找和重新分配的简便方法. 相当于下面的最后两行.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; a = 2 \u0026gt;\u0026gt;\u0026gt; a = a + 1 \u0026gt;\u0026gt;\u0026gt; a += 1   2.4.9 传播约束 可变数据允许我们去模拟具有改变的系统, 也允许我们去构建新类型的抽象. 在这个扩展例子中, 我们组合非本地声明, 列表, 以及字典来构建一个基础约束的系统, 它支持多种说明的计算. 作为约束的表达式程序是声明性编程的一种类型, 也就是一个程序员声明要去解决的问题的结构, 但是抽象出了究竟如何计算问题的解决方案的细节。.\n计算机程序传统上是组织为单方向计算的, 也就是在预先指定的参数上执行操作来生产期望的输出. 另一方面, 我们通常想要以数量的关系来对系统建模. 例如, 我们以前思考过的理想气体定律, 它是通过玻尔兹曼常数(k)来跟压力(p), 体积(v), 数量(n), 以及温度(t)相关的.\np * v = n * k * t\n这样的一个方程不是单项的. 有任意四个给定的数量, 我们可以用这个等式来计算第五个. 然而将这个等式转换到传统的计算机语言中或迫使我们去选择一个数量并用其他四个数量来计算出它. 因此, 一个计算压力的函数无法被用来计算温度, 即使所有需要计算的数量都源自同一个等式.\n在本节中, 我们用线性关系来勾勒出一般模型的设计. 我们定义保留在数量之间的原始约束, 例如一个adder(a, b, c)约束会强制得到数学关系a + b = c.\n我们还定义了一种组合方法, 因此原始约束可以被组合来表达出更多复杂的关系. 通过这种方式, 我们的程序就类似于一个程序语言. 我们通过构建一个由连接器连接来连接约束的网络来组合约束. 一个连接器是一个持有一个值以及并且可以参与一个或多个约束的对象.\n例如, 我们知道华氏度以及摄氏度之间的关系是: 9 * c = 5 * (f - 32)\n这个方程是c和f之间的复杂约束. 这样的一个约束能够想象为一个由原始adder, multiple以及constant约束组成的网络.\n在这个图片中, 我们看到左边的乘法器有三个终端, 标记为a, b和c. 这些将乘法器连接到网络的其余部分, 如下所示: a终端是连接到一个连接器celsius, 它将会保存摄氏温度. b终端连接到一个连接器w中, 也就是一个连接到具有9的常量盒子的连接器. c终端是一个乘法器盒子约束为a和b的乘积, 连接到c终端的是另外一个乘法器, 这个乘法器的b终端连接到一个常量5而a终端连接到一个和约束的其中一项上.\n这样的网络计算过程如下: 当一个连接器给定了一个值(通过用户或者它连接到的约束盒子), 它将会唤醒它所有关联的约束(除了那个唤醒它的约束)来通知它们它所具有的值. 每一次唤醒约束盒子然后轮询它的连接器来查看这里是否有足够的信息来确定一个连接器的值. 如果有, 这个盒子就设置这个连接器, 这个连接器随后会唤醒所有自己的关联约束等. 例如, 在摄氏度和华氏度之间的转换, w, x以及y都会立即被分别设置为常量盒子9, 5以及32. 连接器唤醒乘法器以及加法器, 它判断得出现在还没有足够的信息来继续执行. 如果用户(或者网络的其他部分)给celsius连接器设定一个值(比如说25), 那么最左边的乘法器会被唤醒, 然后它会设定u为25 * 9 = 225. 然后u会唤醒第二个乘法器, 它会设定v为45, 然后v唤醒加法器, 它会设置fahrenheit连接器为77.\n使用约束系统. 要使用约束系统来执行上面描绘的温度计算, 我们首先通过调用connector构造器来创建两个已命名的连接器, celsius以及fahrenheit.\n1 2  \u0026gt;\u0026gt;\u0026gt; celsius = connector(\u0026#39;Celsius\u0026#39;) \u0026gt;\u0026gt;\u0026gt; fahrenheit = connector(\u0026#39;Fahrenheit\u0026#39;)   然后, 我们连接这些连接器到网络中来做一个上图的镜像实现. 函数convert用来装配网络中的各种连接器以及约束.\n1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; def converter(c, f): \u0026#34;\u0026#34;\u0026#34;Connect c to f with constraints to convert from Celsius to Fahrenheit.\u0026#34;\u0026#34;\u0026#34; u, v, w, x, y = [connector() for _ in range(5)] multiple(c, w, u) multiple(v, x, u) adder(v, y, f) constant(w, 9) constant(x, 5) constant(y, 32) \u0026gt;\u0026gt;\u0026gt; converter(celsius, fahrenheit)   我们会用一个消息输入到系统中来协调约束以及连接器. 约束是不具有本地状态的一个字典. 约束不会直接修改连接器的值, 而是会通过发送信息来修改, 因此连接器可以通知其他的约束来响应修改. 通过这种方式, 一个连接器代表一个数字, 同时也封装连接器的行为.\n一个我们可以发送到连接器的信息是设置它的值. 这里, 我们(也就是\u0026quot;用户\u0026rdquo;)设置celsius的值为25.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; celsius[\u0026#39;set_val\u0026#39;](\u0026#39;user\u0026#39;, 25) Celsius = 25 Fahrenheit = 77.0   不仅仅celsius的值修改为25, 而且它的值通过网络传播, 因此fahrenheit的值也会修改. 这些值会被打印出来因为在构建它们的时候我们命名了这两个连接器.\n现在我们可以尝试设定fahrenheit到一个新值, 比如说212.\n1 2  \u0026gt;\u0026gt;\u0026gt; fahrenheit[\u0026#39;set_val\u0026#39;](\u0026#39;user\u0026#39;, 212) Contradiction detected: 77.0 vs 212   这个连接器会抱怨说它探测到一个矛盾: 它的值是77.0, 然后某个人尝试将它设为212. 如果我们真的想要用新的值重用这个网络, 我们可以告诉celsius去忘记它的旧值:\n1 2 3  \u0026gt;\u0026gt;\u0026gt; celsius[\u0026#39;forget\u0026#39;](\u0026#39;user\u0026#39;) Celsius is forgotten Fahrenheit is forgotten   连接器celsius发现那个本来要设定它值的用户现在正在撤回这个值, 因此celsius同意去丢掉自己的值, 然后它通知网络的剩余部分目前的情况. 这个信息最终传播到fahrenheit中, 它现在发现它没有理由去继续相信它拥有的值是77. 因此, 它也放弃了它自己的值.\n现在, fahrenheit已经没有了值, 我们可以自由地设定它为212:\n1 2 3  \u0026gt;\u0026gt;\u0026gt; fahrenheit[\u0026#39;set_val\u0026#39;](\u0026#39;user\u0026#39;, 212) Fahrenheit = 212 Celsius = 100.0   这个新值, 当其通过网络传播时, 迫使celsius得到一个值100. 我们已经使用这个非常相像的网络来通过给定fahrenheit计算celsius, 通过给定fahrenheit计算celsius. 这种计算的非方向性是基于约束的系统的区别特征。\n实现约束系统. 就像我们看到的, 连接器是一个映射消息名称到函数以及数据值的字典. 我们会实现连接器来响应下面的消息:\n connector['set_val'](source, value)表明source需要连接器来设置它的当前值为value. connector['has_val']()返回是否这个连接器已经具有一个值. connector['val']是connector的当前值. connector['forget'](source)告诉连接器需要它去忘记设定的source的值 connector['connect'](source)告诉连接器去加入到一个新的约束中, 也就是source;  约束也是字典, 它会从连接器通过两个消息来接收信息:\n constraints['new_val']()表明已经连接到约束并具有一个新的值的一些连接器. constraints['forget']()表明已经连接到约束并具有并忘记它的值的一些连接器.  当约束接收到这些信息, 它们恰当地将这些信息传播到其他的连接器.\nadder函数通过三个连接器来构造了一个加法约束, 就是前两个必须要相加得到第三个: a + b = c. 要支持多向约束传播, 加法器也必须要能够指定从c减去a得到b以及同样的从c减去b得到a.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; from operator import add, sub \u0026gt;\u0026gt;\u0026gt; def adder(a, b, c): \u0026#34;\u0026#34;\u0026#34;The constraints that a + b = c.\u0026#34;\u0026#34;\u0026#34; return make_ternary_constraint(a, b, c, add, sub, sub)   我们也愿意去实现一个通用的三元(三个方向)约束, 也就是用三个连接器以及三个函数从adder来创建一个约束来接受new_val以及forget信息. 响应消息的是被放置在一个字典中称为constraint的本地函数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026gt;\u0026gt;\u0026gt; def make_ternary_constraint(a, b, c, ab, ca, cb): \u0026#34;\u0026#34;\u0026#34;The constraint that ab(a, b)=c and ca(c, a)=b and cb(c, b)=a.\u0026#34;\u0026#34;\u0026#34; def new_value(): av, bv, cv = [connector[\u0026#39;has_val\u0026#39;]() for connector in (a, b, c)] if av and bv: c[\u0026#39;set_val\u0026#39;](constraint, ab(a[\u0026#39;val\u0026#39;], b[\u0026#39;val\u0026#39;])) elif av and cv: b[\u0026#39;set_val\u0026#39;](constraint, ca(c[\u0026#39;val\u0026#39;], a[\u0026#39;val\u0026#39;])) elif bv and cv: a[\u0026#39;set_val\u0026#39;](constraint, cb(c[\u0026#39;val\u0026#39;], b[\u0026#39;val\u0026#39;])) def forget_value(): for connector in (a, b, c): connector[\u0026#39;forget\u0026#39;](constraint) constraint = {\u0026#39;new_val\u0026#39;: new_value, \u0026#39;forget\u0026#39;: forget_value} for connector in (a, b, c): connector[\u0026#39;connect\u0026#39;](constraint) return constraint   称为constraint的字典是一个调度字典, 但它本身也是一个约束对象. 它响应约束接收的两个信息, 但它在调用它的连接器时也作为source参数来传输.\n无论任何时候约束被通知有一个它的连接器得到了一个值时, 约束的本地函数new_value就会被调用. 这个函数首先检查看是否a和b都有值. 如果有, 它会告诉c去设定值自己为函数ab的返回值, 在adder的情况下就是相加的结果. 约束将它自己(constraint)作为source参数来传输到connector中, 也就是adder对象. 如果a和b不是全都有值, 那么constraint会检查a以及c, 等等.\n如果约束被通知到它的其中一个连接器已经忘记它的值, 它会要求它所有的连接器马上遗忘自己的值. (只有这些值是由约束设置的会真的丢失掉.)\n一个乘法器跟一个加法器十分的相似.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; from operator import mul, truediv \u0026gt;\u0026gt;\u0026gt; def multiple(a, b, c): \u0026#34;\u0026#34;\u0026#34;The constraint that a * b = c.\u0026#34;\u0026#34;\u0026#34; return make_ternary_constraint(a, b, c, mul, truediv, truediv)   一个常量也是一个约束, 但是一个永远不会发送任何信息的约束, 因为在它设置构建的时候只涉及到单一的一个连接器.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; def constant(connector, value): \u0026#34;\u0026#34;\u0026#34;The constraint that connector = value.\u0026#34;\u0026#34;\u0026#34; constraint = {} connector[\u0026#39;set_val\u0026#39;](constraint, value) return constraint   这三个约束足以实现我们的温度转换网络.\n表示连接器. 一个连接器是作为一个包含一个值的字典来表示的, 但也有本地状态的响应函数. 这连接器必须跟踪给予其当前值的信息提供者以及它参与的约束的列表.\n这个connector构造器有本地的函数来设置以及遗忘值, 它们是来自约束的消息的响应.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  \u0026gt;\u0026gt;\u0026gt; def connector(name=None): \u0026#34;\u0026#34;\u0026#34;A connector between constraints.\u0026#34;\u0026#34;\u0026#34; informant = None constraints = [] def set_value(source, value): nonlocal informant val = connector[\u0026#39;val\u0026#39;] if val is None: informant, connector[\u0026#39;val\u0026#39;] = source, value if name is not None: print(name, \u0026#39;=\u0026#39;, value) inform_all_except(source, \u0026#39;new_val\u0026#39;, constraints) else: if val != value: print(\u0026#39;Contradiction detected:\u0026#39;, val, \u0026#39;vs\u0026#39;, value) def forget_value(source): nonlocal informant if informant == source: informant, connector[\u0026#39;val\u0026#39;] = None, None if name is not None: print(name, \u0026#39;is forgotten\u0026#39;) inform_all_except(source, \u0026#39;forget\u0026#39;, constraints) connector = { \u0026#39;val\u0026#39;: None, \u0026#39;set_val\u0026#39;: set_value, \u0026#39;forget\u0026#39;: forget_value, \u0026#39;has_val\u0026#39;: lambda: connector[\u0026#39;val\u0026#39;] is not None, \u0026#39;connect\u0026#39;: lambda source: constraints.append(source) } return connector   连接器再一次作为五个消息的调度字典用来通过约束去与连接器通信. 有四个是响应函数, 最后的一个是响应的值本身.\n当有请求来设置连接器的值时本地函数set_value会被调用. 如果连接器当前不具有值, 它将设置其值并记住请求要设置的值的源约束为informant. 接着连接器会通知所有它参与的约束除了请求要设置值的约束. 这是使用以下的迭代函数完成的.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; def inform_all_except(source, message, constraints): \u0026#34;\u0026#34;\u0026#34;Inform all constraints of the message, except source.\u0026#34;\u0026#34;\u0026#34; for c in constraints: if c != source: c[message]()   如果一个连接器被要求遗忘它的值, 它会调用本地的forget_value函数, 这函数首先检查确认请求最初设置的值是从相同的约束中来的. 如果是连接器通知它的关联约束关于值的丢失.\n响应has_val消息指示出连接器是否有一个值. 响应connect消息会添加约束源到约束列表中.\n我们已经设计好的约束程序介绍了许多思想将会在面向对象编程里面再次出现. 约束以及连接器都是通过消息操纵的抽象. 当连接器的值被修改, 它是通过消息改变的而且不仅仅改变值, 还验证它(检查源)以及传播它的影响(通知其他的约束). 实际上, 在这章之后, 我们会用一个相似的字典架构, 它包含字符串值作为键以及函数值来实现一个面向对象系统.\n2.5 面向对象编程 面向对象编程(OOP)是一种组织程序的方法, 在这一章中它汇集并带来了许多思想. 比如在数据抽象中的函数, 类在数据使用和实现之间创建的抽象屏障. 比如调度字典, 对象回应行为请求, 比如可变数据结构, 具有本地状态的对象并不可以直接在全局环境访问. Python的对象系统提供了便利的语法来促进使用这些技术来组织程序. 许多这些语法都在其他的面向对象编程语言中共享.\n对象系统提供的不仅仅是便利. 它为设计程序启用了新的隐喻, 也就是其中几个独立的代理在计算机中的交互. 每一个对象以提取两者复杂性的方式将局部状态以及行为捆绑在一起. 对象之间相互通信, 并且有用的结果从它们之间交互的成果中得出. 对象不仅仅传递消息, 它们也在相同类型的其他对象间共享行为以及在相关类型中继承特性\n面向对象编程范例有它自己的词汇用来支持对象隐喻. 我们已经见识过一个对象就是一个具有方法以及属性通过点语法访问的数据值. 每一个对象都有一个类型, 叫做它的类. 要创建一个新的数据类型, 我们需要实现一个新的类.\n2.5.1 对象以及类 一个类就是所有类型是这个类的对象的一个模板. 每个对象都是某种特定类型的类的一个实例. 到目前为止我们用过的所有对象都具有內建的类, 但是新的用户定义的类型也可以被创建. 一个类的定义指定了属性以及方法在这种类的对象之间共享. 我们会通过重看银行账户的例子来介绍类声明.\n当介绍局部状态, 我们看到银行账户被自然地以具有balance的可变数据值来建模. 一个银行账户对象应该有一个withdraw方法来更新账户的余额以及在更新后的余额有效的情况下返回请求的金额. 要完成抽象, 一个银行账户应该可以返回它当前的余额(balance), 返回账户持有者(holder)的名称, 以及存款金额(deposit).\n一个账户类允许我们去创建多个银行账户的实例. 创建一个新对象实例的动作被称为类的实例化. 在Python中实例化一个类的语法跟调用一个函数的语法是一样的. 在这种情况下, 我们用参数\u0026rsquo;Kirk\u0026rsquo;即账户持有者的名称来调用Account类.\n1  \u0026gt;\u0026gt;\u0026gt; a = Account(\u0026#39;Kirk\u0026#39;)   一个对象的一个属性就是一个跟对象关联的名值对, 并且它能够通过点语法来访问. 特定对象的特定属性(与类的所有对象相对而言)称为实例属性. 每一个Account都有它的自己的余额以及账户持有者名称, 也就是例子的实例属性. 在更加广泛的编程社区, 实例属性也会叫做字段, 特性, 或者实例变量\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; a.holder \u0026#39;Kirk\u0026#39; \u0026gt;\u0026gt;\u0026gt; a.balance 0   在对象或者执行特定对象计算的函数被称为方法. 方法的返回值以及副作用可以取决于对象的其他属性且改变它. 例如, deposit(存款)是Account类对象a的一个方法. 它接收一个参数, 就是存款的金额, 修改对象的balance(余额)属性, 然后返回余额的结果.\n1 2  \u0026gt;\u0026gt;\u0026gt; a.deposit(15) 15   我们称方法在特定的对象上被调用. 作为调用withdraw(取出)方法调用的结果, 要么取款会被批准并扣除总额, 要么请求被拒绝然后方法返回一个错误信息.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a.withdraw(10) 5 \u0026gt;\u0026gt;\u0026gt; a.balance 5 \u0026gt;\u0026gt;\u0026gt; a.withdraw(10) \u0026#39;Insufficient funds\u0026#39;   如上所述, 方法的行为可以取决于对象属性的修改. 对withdraw(取款)的两次相同的调用返回了不同的结果.\n2.5.2 定义类 用户定义类型是通过包含一个单一条款的class声明来创建的, 一个class声明定义一个类的名称, 然后包含一系列语句来定义类的属性:\nclass \u0026lt;name\u0026gt;: \u0026lt;suite\u0026gt; 当一个类声明被执行, 一个新的类就会创建并在当前环境的第一帧内绑定到\u0026lt;name\u0026gt;. 内部的一系列语句会执行. 任何在class声明的\u0026lt;suite\u0026gt;范围内的通过def或者赋值语句定义的名称会创建或修改类的属性.\n类通常围绕操纵类的属性, 也就是跟这个类的每个实例相关联的名值对. 这个类通过定义用于初始化新对象的方法来指定其对象的实例属性. 例如, 初始化Account类的对象的其中一个部分是分配给它一个初始的余额值0.\n类声明中的\u0026lt;suite\u0026gt;包含有def声明, 它会定义为这种类的对象定义新的方法. 在Python中初始化对象的方法具有一个特别的名字, __init__(在单词init的两边都有两个下划线), 这方法称为这个类的构造器.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; class Account: def __init__(self, account_holder): self.balance = 0 self.holder = account_holder   Account类的__init__方法有两个形式参数. 第一个是self, 它绑定到的是最新创建的Account对象. 第二个参数是account_holder, 它在调用类来实例化对象的时候绑定为的传输给类的参数.\n构造器将实例名为balance的属性绑定为值0. 它同时也将名为holder的属性绑定到名为account_holder具有的值. 形式参数account_holder在__init__方法中是本地名称. 另一方面, 最终通过赋值语句进行绑定的名称holder依然存在, 因为它通过点语法存储为self的属性.\n在定义了Account类之后, 我们可以实例化它\n1  \u0026gt;\u0026gt;\u0026gt; a = Account(\u0026#39;Kirk\u0026#39;)   这种\u0026quot;调用\u0026quot;Account类创建出来的新对象是Account的一个实例, 然后用两个参数: 最新创建的对象以及字符串Kirk来调用构造器函数__init__. 按照惯例, 我们用参数名self代表构造器的第一个参数, 因为它是绑定到已被实例化的对象上的. 这个惯例实际上在所有Python代码中被采用.\n现在我们可以用点语法访问对象的balance以及holder.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; a.balance 0 \u0026gt;\u0026gt;\u0026gt; a.holder \u0026#39;Kirk\u0026#39;   身份. 每一个新的账户实例都有它自己的balance属性, 这个值独立于其他相同类型的对象.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; b = Account(\u0026#39;Spock\u0026#39;) \u0026gt;\u0026gt;\u0026gt; b.balance = 200 \u0026gt;\u0026gt;\u0026gt; [acc.balance for acc in (a, b)] [0, 200]   为了强制这种分离, 每一个用户定义类的实例对象都有一个唯一的标识, 对象标识可以用is或者is not操作符来进行比较.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; a is a True \u0026gt;\u0026gt;\u0026gt; a is not b True   尽管都是从相同的调用中构造, 绑定到a的对象跟绑定到b的对象是不相同的. 而同样地, 用赋值语句绑定一个对象到新的名字不会创建新的对象.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; c = a \u0026gt;\u0026gt;\u0026gt; c is a True   新的用户定义类的对象只当一个类(例如Account)通过表达式语法调用进行实例化的时候才会被创建.\n方法. 对象方法通常也通过类语句的套件内的def语句来定义. 下面, deposit以及withdraw都是作为Account类的方法来定义的.\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; class Account: def __init__(self, account_holder): self.balance = 0 self.holder = account_holder def deposit(self, amount): self.balance = self.balance + amount return self.balance def withdraw(self, amount): if amount \u0026gt; self.balance: return \u0026#39;Insufficient funds\u0026#39; self.balance = self.balance - amount return self.balance   虽然一个方法的定义跟一个函数的定义在如何声明上并没有什么不同, 但方法定义在它们执行的时候会带来不同的效果. 通过在class语句内部def语句创建的函数值会绑定到声明的名称上, 同时也会局部绑定作为类的属性. 这个值会从一个类的实例中通过点语法作为方法被调用.\n每一个方法的定义再一次包含有特殊的第一参数self, 它是绑定到调用方法的对象上的. 例如, 我们会说deposit是在特定的Account对象上被调用的, 同时需要传单个参数值: 存款的金额. 对象本身被绑定到self上, 而参数绑定到amount上. 所有调用的方法都可以通过self参数访问对象, 同时, 它们全部都可以访问以及操纵对象的状态.\n要调用这些方法, 我们再一次要用到点语法, 如下所示:\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; spock_account = Account(\u0026#39;Spock\u0026#39;) \u0026gt;\u0026gt;\u0026gt; spock_account.deposit(100) 100 \u0026gt;\u0026gt;\u0026gt; spock_account.withdraw(90) 10 \u0026gt;\u0026gt;\u0026gt; spock_account.withdraw(90) \u0026#39;Insufficient funds\u0026#39; \u0026gt;\u0026gt;\u0026gt; spock_account.holder \u0026#39;Spock\u0026#39;   当一个方法通过点语法被调用, 对象本身(在这个例子中是绑定到spock_account上的对象)扮演一个双重角色. 第一, 它确定名称withdraw的含义; withdraw不是当前环境下的名称, 而是Account类的本地名称. 第二, 当withdraw方法被调用时它会绑定到第一个参数self.\n2.5.3 消息传递与点表达式 那些定义在类里面的方法以及通常在构造器里面分配的实例属性, 都是面向对象编程的基本要素. 这两个概念在消息传递数据值的实现中复制了调度字典的大多数行为. 对象用点语法携带消息, 但那些消息不是任意字符串值作为键, 它们是作为类的局部名称而存在的. 对象也有命名的本地状态(实例属性), 但是这个状态可以使用点语法进行访问以及操纵, 而不用在实现中使用nonlocal语句.\n消息传递的中心思想是数据值应该通过响应它们所代表的抽象类型的相关消息具有行为. 点符号是Python的一个句法特征, 用来形式化消息传递的隐喻. 使用具有內建对象系统的语言的好处是消息传递可以与语言的其他特性无缝互动, 例如赋值语句, 我们无需请求不同的消息来\u0026quot;获取(get)\u0026ldquo;或者\u0026quot;设置(set)\u0026ldquo;跟本地属性名称相关联的值; 语言的语法允许我们直接使用消息名称.\n点表达式. 代码片段spock_account.deposit被称为点表达式. 一个点表达式由一个表达式, 一个点, 以及一个名称组成.\n\u0026lt;expression\u0026gt;.\u0026lt;name\u0026gt;\n\u0026lt;expression\u0026gt;可以是任意有效的Python表达式, 但是\u0026lt;name\u0026gt;必须是一个简单名称(不是一个运行后得到一个名称的表达式). 点表达式对\u0026lt;expression\u0026gt;的值代表的对象运算出给定的\u0026lt;name\u0026gt;属性的值.\n內建函数getattr也通过一个名称返回一个对象的属性. 这是一个相当于点符号的函数. 使用getattr函数, 我们可以用字符串查看一个属性, 就像在调度字典中那样做.\n1 2  \u0026gt;\u0026gt;\u0026gt; getattr(spock_account, \u0026#39;balance\u0026#39;) 10   我们也可以用hasattr测试一个对象是否具有某个属性.\n1 2  \u0026gt;\u0026gt;\u0026gt; hasattr(spock_account, \u0026#39;deposit\u0026#39;) True   对象的是属性包括所有的实例属性, 以及在其类中定义的所有属性(包括方法). 方法是类中需要特殊处理的属性\n方法和函数. 当一个方法在一个对象上被调用, 对象会隐含地作为方法的第一个参数进行传输. 也就是说, 对象是点号左边的\u0026lt;expression\u0026gt;的值自动地作为第一个参数传输给点号表达式右边的方法名代表的函数. 结果就是对象绑定到参数self上.\n要实现自动绑定self, Python将我们自本文开始以来一直创建的函数和绑定方法区分开来了, 这些方法将函数和要调用该方法的对象耦合在了一起. 绑定方法的值已经和它的第一个参数(也就是调用它的实例, 那个将在方法被调用时会命名为self的对象)关联在一起.\n我们可以通过在交互式解析器上调用type来处理点语法的返回值来看出差异. 作为一个类的属性, 一个方法只是一个函数, 但是作为一个实例的属性, 它就是一个绑定了的方法:\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; type(Account.deposit) \u0026lt;class \u0026#39;function\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(spock_account.deposit) \u0026lt;class \u0026#39;method\u0026#39;\u0026gt;   这两个结果的不同事实上在于第一个是标准的带有两个形参self以及account的函数. 而第二个是具有单个形参的方法, 在方法被调用时名称self会被自动地绑定到名为spock_account的对象上, 而形参amount会被绑定到传入方法的参数上. 所有这些值, 无论是函数值或者绑定方法值, 都跟相同的deposit函数体相关联.\n我们可以用两种方式调用deposit: 作为函数以及作为绑定方法. 在前一种情况下, 我们必须明确地提供一个参数给self形参, 在后一种情况下, self形参会自动绑定.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; Account.deposit(spock_account, 1001) # The deposit function takes 2 arguments 1011 \u0026gt;\u0026gt;\u0026gt; spock_account.deposit(1000) # The deposit method takes 1 argument 2011   函数getattr的行为跟点符号完全类似: 如果它的第一个参数是一个对象, 但是名称是一个已经在类中定义的方法. 那么getattr返回一个绑定的方法值. 另一方面, 如果第一个参数是一个类, 那么getattr直接返回属性值, 也就是一个纯函数.\n命名约定. 传统上命名类是使用CapWords惯例(也就是称为驼峰式, 因为在名称中间的单词首部看起来像是一个驼峰). 方法名跟随命名函数所使用的标准惯例也就是使用小写单词并用下划线作分割.\n在某些情况下, 对象上跟维护性与一致性相关的一些实例变量以及方法我们是不希望对象的用户看到或者使用的. 它们不是类的抽象定义的一部分, 而是实现的一部分. Python的惯例规定如果一个属性名以下划线开始, 它就应该只能被类自身内部的方法访问到, 而不是使用这个类的用户.\n2.5.4 类属性 一些属性值是共享给指定类的所有对象访问的. 这样的属性是跟类本身而不是任何个别类的实例相关联的. 例如, 让我们假设一个银行以固定利率支付账户余额的利息. 利率可能会变动, 但是这是一个在所有账户中共享的单一值.\n类属性通过赋值语句在类的套件语句中且在所有方法定义的外面创建. 在更广泛的开发者社区中, 类属性可能也会叫做类变量或静态变量. 接下来的类语句中为Account类创建一个名为interest的属性.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; class Account: interest = 0.02 # 一个类属性 def __init__(self, account_holder): self.balance = 0 self.holder = account_holder # 额外的方法会在这里定义   这个属性依然可以从类的任何实例中访问到.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; spock_account = Account(\u0026#39;Spock\u0026#39;) \u0026gt;\u0026gt;\u0026gt; kirk_account = Account(\u0026#39;Kirk\u0026#39;) \u0026gt;\u0026gt;\u0026gt; spock_account.interest 0.02 \u0026gt;\u0026gt;\u0026gt; kirk_account.interest 0.02   但是, 对类属性的单个赋值语句会更改该类的所有实例的属性值.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; Account.interest = 0.04 \u0026gt;\u0026gt;\u0026gt; spock_account.interest 0.04 \u0026gt;\u0026gt;\u0026gt; kirk_account.interest 0.04   属性名. 我们已经在对象系统中引入了足够的复杂度, 以至于我们必须要指定如何将名称解析为特殊的属性. 毕竟, 我们可以轻易地拥有一个相同名称的类属性以及实例属性.\n就像我们已经见识过的, 一个点表达式包含一个表达式, 一个点, 以及一个名称:\n\u0026lt;expression\u0026gt;.\u0026lt;name\u0026gt;\n去执行一个点表达式:\n 执行在点符号左边的\u0026lt;expression\u0026gt;语句, 它返回的一个对象给点表达式. \u0026lt;name\u0026gt;跟对象的实例属性相匹配; 如果有一个这样名称的属性, 就会返回它的值. 如果\u0026lt;name\u0026gt;没有出现在实例属性之中, 那么会去类中查找\u0026lt;name\u0026gt;, (如果找到)并返回类属性的值. 除非这个值是一个函数, 那么将会返回一个绑定了的方法. 否则属性值将被返回.  在执行过程当中, 实例属性的查找会在类属性之前, 就像本地名称对于全局环境名称所具有的优先权. 在类中定义的方法会跟点表达式中的对象结合通过执行第四步的过程形成一个绑定方法. 这个查找类中的名称的过程会有附加的细微差别, 一旦我们介绍类继承之后将会很快出现.\n属性赋值. 在其左侧包含点表达式的所有赋值语句都会影响该点表达式对象的属性. 如果对象是一个实例, 那么赋值会设定一个实例属性. 如果对象是一个类, 那么赋值会设定一个类属性. 这个规则带来的后果是, 为一个对象赋值一个属性不能影响到它的类的属性. 下面的例子演示了这个区别.\n如果我们为一个账户实例赋值一个名为interest的属性, 我们就创建了一个新的跟已经存在的类属性名称一样的实例属性.\n\u0026gt;\u0026gt;\u0026gt; kirk_account.interest = 0.08\n然后这个属性值会在点表达式中被返回\n1 2  \u0026gt;\u0026gt;\u0026gt; kirk_account.interest 0.08   然而, 类属性interest仍然保留它的原始值, 提供给所有其他的账户返回.\n1 2  \u0026gt;\u0026gt;\u0026gt; spock_account.interest 0.04   更改类属性interest会影响到spock_account, 但是对kirk_account的实例属性不会有影响.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; Account.interest = 0.05 # changing the class attribute \u0026gt;\u0026gt;\u0026gt; spock_account.interest # changes instances without like-named instance attributes 0.05 \u0026gt;\u0026gt;\u0026gt; kirk_account.interest # but the existing instance attribute is unaffected 0.08   2.5.5 继承 当在面向对象模式下工作时，我们常常发现不同的类型是有关系的。尤其是，我们会发现相似类的在专有化程度上有所不同。两个类可能会有相同的属性，但是其中一个代表的是另一个的特殊例子。\n例如，我们可能会想要实现一个支票账户，它跟标准账户有所不同。一个支票账户每次取钱都需要额外的$1手续费且具有更低的利率。这里，我们演示期望的行为。\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; ch = CheckingAccount(\u0026#39;Spock\u0026#39;) \u0026gt;\u0026gt;\u0026gt; ch.interest # 支票账户具有更低的利率 0.01 \u0026gt;\u0026gt;\u0026gt; ch.deposit(20) # 存款是一样的 20 \u0026gt;\u0026gt;\u0026gt; ch.withdraw(5) # 取款需要减去额外的费用 14   一个CheckingAccount是一个专有化的Account。在OOP术语中，一般的账户会作为CheckingAccount的基类，而CheckingAccount会成为Account的子类（术语父类以及超类通常也用来表示基类，而子类通常也用来表示子集。）\n一个子类继承它的基类的属性，但可能会重载某些属性，包括某些方法。有了继承，我们只需要指出子类与基类之间的不同。任何我们在子类中没有特别指明的都会自动假定它的行为跟基类一样。\n继承除了是一个有用的组织性特性，在对象隐喻中也具有作用。继承代表的意思是类中\u0026quot;是一个\u0026quot;的关系，可与\u0026quot;有一个\u0026quot;的关系相类比。一个支票账户\u0026quot;是一个\u0026quot;特殊类型的账户，因此继承自Account的CheckingAccount账户就是继承的恰当使用。另一方面，一个银行\u0026quot;有一个\u0026quot;列的银行账户给它管理着，因此，都不应该继承其他，而是，账户对象列表会自然地表示为一个银行账户对象的实例属性。\n2.5.6 使用继承 首先，我们给出Account的完整实现，包括类的文档字符串以及它的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; class Account: \u0026#34;\u0026#34;\u0026#34;A bank account that has a non-negative balance.\u0026#34;\u0026#34;\u0026#34; interest = 0.02 def __init__(self, account_holder): self.balance = 0 self.holder = account_holder def deposit(self, amount): \u0026#34;\u0026#34;\u0026#34;Increase the account balance by amount and return the new balance.\u0026#34;\u0026#34;\u0026#34; self.balance = self.balance + amount return self.balance def withdraw(self, amount): \u0026#34;\u0026#34;\u0026#34;Decrease the account balance by amount and return the new balance\u0026#34;\u0026#34;\u0026#34; if amount \u0026gt; self.balance: return \u0026#39;Insufficient funds\u0026#39; self.balance = self.balance - amount return self.balance   下面显示的是CheckingAccount的完整实现。我们通过在类名后的括号中放置一个运算后为基类的表达式来指定继承。\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; class CheckingAccount(Account): \u0026#34;\u0026#34;\u0026#34;A bank account that charges for withdrawals.\u0026#34;\u0026#34;\u0026#34; withdraw_charge = 1 interest = 0.01 def withdraw(self, amount): return Account.withdraw(self, amount + self.withdraw_charge)   这里，我们引入一个在类CheckingAccount中指定的属性withdraw_charge。我们分配一个较低的值给interest属性。我们同样也定义一个新的withdraw方法来重新定义在Account类中的行为。在类中没有进一步的声明，所有其他的行为都是继承自基类Account。\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; checking = CheckingAccount(\u0026#39;Sam\u0026#39;) \u0026gt;\u0026gt;\u0026gt; checking.deposit(10) 10 \u0026gt;\u0026gt;\u0026gt; checking.withdraw(5) 4 \u0026gt;\u0026gt;\u0026gt; checking.interest 0.01   表达式checking.deposit运算绑定的取款方法, 也就是定义在Account类内的方法. 当Python解析点表达式内不是实例属性的名称的时候, 它会在类内部查找名称. 实际上, 在类内\u0026quot;查找\u0026quot;的行为尝试去查找原始类继承链中的每个基类中的名称. 我们可以递归地定义这个过程. 来查找类中的名称.\n 如果它在一个类中命名了一个属性, 返回属性的值. 否则, 在基类中查找名称, 如果里面有一个的话.  在deposit的例子中, Python首先必定会在实例中查找名称, 然后在CheckingAccount类中查找. 最后会在Account类中查找, 也就是deposit定义的地方. 根据我们的点表达式运算规则, 由于deposit是在checking实例中查找类得到的函数, 即运算点表达式绑定方法的值. 此方法用参数10来调用, 会用绑定了checking对象的self以及绑定了10的amount调用deposit方法.\n对象的类会一直保持不变. 即使deposit方法是在Account类中找到的, deposit调用时self绑定的实例还是属于CheckingAccount而不是Account.\n调用祖先. 已经被重载的属性依然能够通过类对象来访问. 例如, 我们通过一个含有withdraw_charge的参数来调用Account的withdraw方法从而实现CheckingAccount类的withdraw方法.\n注意到我们调用self.withdraw_charge而不是等价的CheckingAccount.withdraw_charge. 前者相对于后者的好处是一个继承自CheckingAccount的类可能会重写体现的手续费. 如果是这样的情况, 我们会想要让我们实现的withdraw找到的是新的值, 而不是旧的值.\n接口. 在面向对象编程当中, 不同的类型的对象相互之间共享相同的属性名称是十分常见的. 一个对象接口是一个由属性以及建立在这些属性之上的条件的集合. 例如, 所有账户必须要有接受数值的deposit以及withdraw方法, 也有一个balance属性. 而类Account以及CheckingAccount都实现了这些接口. 在这种方式下继承尤其会促进命名共享. 在一些编程语言比如Java, 接口实现必须明确地被声明. 在其他如Python, Ruby以及Go中, 任何具有恰当名称的对象就是一个接口.\n在你的程序中使用对象(而不是实现它们)的部分如果对于对象的类型没有作出任何假设, 而是只定义了它们的属性名称那么对于未来的修改这是最健壮的. 换句话说, 它们使用对象抽象而不是假设任何关于它的实现.\n例如, 假如说我们运行一个彩票, 同时我们希望存入$5到账户列表的每一个账户中. 接下来的实现没有假设任何关于这些账户的类型, 因此, 能够在任何类型的具有deposit方法的对象下同等运行.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; def deposit_all(winners, amount=5): for account in winners: account.deposit(amount)   函数deposit_all只假设每一个account满足账户对象的抽象, 因此它会与任何其他也实现了这个接口的账户类工作. 假设一个特定的账户类会违反这个账户对象抽象的抽象屏障. 例如, 接下来的实现不一定能跟新类型的账户一起工作.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; def deposit_all(winners, amount=5): for account in winners: Account.deposit(account, amount)   稍后, 我们将会在这一章详细讲述关于这个主题的更多细节.\n2.5.7 多重继承 Python支持子类从多个基类中继承属性的概念, 这一语言特性被称为_多重继承_.\n假设我们有一个继承自Account的SavingsAccount, 这个账户每次存款都会收取客户一点小费用.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; class SavingsAccount(Account): deposit_charge = 2 def deposit(self, amount): return Account.deposit(self, amount - self.deposit_charge)   然后, 一个聪明的执行官构思了一个AsSeenOnTVAccount账户, 它具有CheckingAccount以及SavingsAccount账户的最好的特性: 取款费用, 存款费用, 以及低利率. 这是集存款以及取款账户于一身的账户! 执行官的理由是: \u0026ldquo;如果我们构建它的话, 有人愿意建立账户并支付这些费用, 我们甚至会给他们一美元\u0026rdquo;.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; class AsSeenOnTVAccount(CheckingAccount, SavingsAccount): def __init__(self, account_holder): self.holder = account_holder self.balance = 1 # 免费的1美元   实际上, 这个实现是复杂的. 分别使用定义在CheckingAccount以及SavingsAccount中的函数来取款以及存款都会产生费用.\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; such_a_deal = AsSeenOnTVAccount(\u0026#34;John\u0026#34;) \u0026gt;\u0026gt;\u0026gt; such_a_deal.balance 1 \u0026gt;\u0026gt;\u0026gt; such_a_deal.deposit(20) # 来自SavingsAccount.deposit的费用 $2 19 \u0026gt;\u0026gt;\u0026gt; such_a_deal.withdraw(5) # 来自CheckingAccount.withdraw的费用 $1 13   无二义性引用能够按期望被处理:\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; such_a_deal.deposit_charge 2 \u0026gt;\u0026gt;\u0026gt; such_a_deal.withdraw_charge 1   但是当引用有歧义时会怎样呢, 例如在Account以及CheckingAccount都定义了的withdraw方法的引用? 下面的图例描绘了AsSeenOnTVAccount类的继承图. 每一个箭头都是从子类指向父类.\n像这样一个的简单的菱形形状, Python是从左到右, 然后向上处理名称. 在这个例子中, Python按照以下类的排序来检查一个属性名称, 直到找到具有这样名称的属性:\nAsSeenOnTVAccount, CheckingAccount, SavingsAccount, Account, object\n这不是一个正确处理继承顺序问题的办法, 有一些例子中我们可能更倾向于给更高的优先级给某些继承的类而不是其他的. 然而, 任何支持多重继承的编程语言都必须要选择某些一致的顺序方式, 来让使用这个语言的用户可以预知他们的程序的行为.\n进一步阅读. Python使用称作C3排序解决方法的递归算法来处理这个名称. 任何类方法的解决顺序可以在所有类中使用mro方法查询.\n1 2  \u0026gt;\u0026gt;\u0026gt; [c.__name__ for c in AsSeenOnTVAccount.mro()] [\u0026#39;AsSeenOnTVAccount\u0026#39;, \u0026#39;CheckingAccount\u0026#39;, \u0026#39;SavingsAccount\u0026#39;, \u0026#39;Account\u0026#39;, \u0026#39;object\u0026#39;]   解决顺序的查找方法的精确算法不是本文的主题, 但是它被描述在Python的第一作者的原著论文的引用中.\n2.5.8 对象的作用 Python对象系统是为了使数据抽象以及消息传递方便和灵活而设计的. 类, 方法, 继承, 以及点表达式的专有语法都是允许我们在程序中形象化对象的比喻, 也就是提升我们组织大型程序的能力.\n特别地, 我们会希望我们的对象系统促进程序不同关注点的分离. 程序中的每个对象都封装并管理某部分的程序的状态, 同时每个类声明内定义的函数都实现了程序总体逻辑的一部分. 抽象屏障在大型程序的不同方面形成界限.\n面向对象编程尤其适合去编写分离但是也有交互部分的模型系统. 例如, 不同用户在社交网络中交互, 不同的角色在游戏中交互, 以及不同的形状在物理仿真系统中交互. 当要表现这样的一个系统时, 在程序中的对象常常自然地映射到系统中已经建模的对象上, 同时类描绘它们的类型以及关系.\n另一方面, 类可能不会提供最好的机制来实现某些抽象. 功能抽象为输入输出之间的关系表现提供更自然的隐喻. 不应该迫使在类中程序的每一点都符合逻辑, 尤其是当为了更自然地操作数据时定义的独立函数. 函数也可以实习分离关注点.\n多范例语言如Python允许程序员对适当的问题来使用恰当的模式. 学习识别什么时候应该引入一个新的类, 或者与之对照的新函数为了简化或者模块化一个程序, 在软件工程中是一个重要的设计技能值得认真关注.\n2.6 实现类以及对象 当在面向对象编程范式下工作时, 我们使用对象隐喻去指导我们程序的组织. 在类声明当中表达的大多数逻辑是关于如何表示以及操作数据的. 在这一节当中, 我们会看到类以及对象本身可以仅仅使用函数以及字典来表示. 用这种方法实现一个对象系统的目的是阐明用对象隐喻不需要特别的编程语言. Python可以是面向对象的, 甚至一个没有内建对象系统的编程语言也可以.\n为了实现对象, 我们会抛弃点符号(需要内建的语言支持), 但是会创建一个调度字典, 它的行为跟内建的对象系统元素的大致一样. 我们已经见识过如何通过调度字典实现消息传递行为. 为了完全实现一个对象系统, 我们在实例, 类以及基类以及所有含有属性的字典当中发送消息.\n我们不会实现整个Python对象系统, 其中包括在本文中没有覆盖到的特性(例如, 元类以及静态方法). 相反, 我们会专注于没有多继承也没有自省行为(例如返回一个类的实例)的用户定义类. 我们的实现并不意味着按照Python类型系统的精确规范. 相反, 这么做的目的是实现对象隐喻的核心功能.\n2.6.1 实例 我们从实例开始. 一个实例具有命名的属性, 例如一个账户内的余额, 可以被设置以及恢复. 我们用一个调度字典实现一个可以响应\u0026quot;get\u0026quot;以及\u0026quot;set\u0026quot;属性值的实例. 属性本身被保存在一个叫做attributes的本地字典当中.\n就像我们在之前的章节中看到的, 字典本身是抽象数据类型. 我们用列表实现一个字典, 我们用数据对来实现列表, 同时我们用函数来实现数据对. 当我们依据字典来实现一个对象系统时, 要记住的是我们也可以只用函数来实现对象.\n要开始我们的实现, 我们假设我们有一个类的实现可以查找任何不是实例的一部分的名称. 我们进入一个传入参数cls的类make_instance当中.\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; def make_instance(cls): \u0026#34;\u0026#34;\u0026#34;Return a new object instance, which is a dispatch dictionary.\u0026#34;\u0026#34;\u0026#34; def get_value(name): if name in attributes: return attributes[name] else: value = cls[\u0026#39;get\u0026#39;](name) return bind_method(value, instance) def set_value(name, value): attributes[name] = value attributes = {} instance = {\u0026#39;get\u0026#39;: get_value, \u0026#39;set\u0026#39;: set_value} return instance   instance是一个调度字典用来响应get以及set消息. set消息相当于Python的对象系统的属性赋值: 所有分配了的属性都直接保存在对象的本地属性字典当中. 在get方法中, 如果name不出现在本地的attributes字典中, 那么它会在类当中查找. 如果通过cls返回的value是一个函数, 它必须跟一个实例绑定.\n绑定值方法. 在make_instance中的get_value函数通过类的get(方法)来找到一个命名属性, 然后调用bind_method方法. 绑定方法只用于函数值, 同时它通过插入实例作为第一个参数从一个函数值中创建一个绑定方法值.\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; def bind_method(value, instance): \u0026#34;\u0026#34;\u0026#34;Return a bound method if value is callable, or value otherwise.\u0026#34;\u0026#34;\u0026#34; if callable(value): def method(*args): return value(instance, *args) return method else: return value   当一个方法是可调用时, 通过这个定义第一个参数self会被绑定为值instance.\n2.6.2 类 一个类也是一个对象, 都存在于Python的对象系统以及现在我们这里实现的系统. 为了简单起见, 我们的类并没有它们自己的类型. (在Python中, 类都是有它们自己的类型的; 几乎所有的类都共享相同的类型, 叫做type.) 一个类可以响应get以及set消息, 也可以响应new消息:\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; def make_class(attributes, base_class=None): \u0026#34;\u0026#34;\u0026#34;Return a new class, which is a dispatch dictionary.\u0026#34;\u0026#34;\u0026#34; def get_value(name): if name in attributes: return attributes[name] elif base_class is not None: return base_class[\u0026#39;get\u0026#39;](name) def set_value(name, value): attributes[name] = value def new(*args): return init_instance(cls, *args) cls = {\u0026#39;get\u0026#39;: get_value, \u0026#39;set\u0026#39;: set_value, \u0026#39;new\u0026#39;: new} return cls   不像一个实例, 当找不到一个属性的时候类型的get函数不会查询它的类, 取而代之的是查询它的基类. 类不需要进行方法绑定.\n初始化. 在make_class的new函数调用init_instance, 首先会创建一个新的实例, 然后调用叫做__init__的方法.\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; def init_instance(cls, *args): \u0026#34;\u0026#34;\u0026#34;Return a new object with type cls, initialized with args.\u0026#34;\u0026#34;\u0026#34; instance = make_instance(cls) init = cls[\u0026#39;get\u0026#39;](\u0026#39;__init__\u0026#39;) if init: init(instance, *args) return instance   这最后的函数完成了我们的对象系统. 我们现在有会在局部set但是get时可回退到它们的类的实例. 一个实例在它的类中查找名称之后, 它绑定它自己本身到一个函数值来创建一个方法. 最后, 类可以创建新(new)实例, 然后它们在实例创建之后立即应用它们的__init__构造器函数.\n在这个对象系统, 唯一应该通过用户调用的函数是make_class. 所有其他的功能通过消息传递来激活. 同样地, Python的对象系统是通过class声明来调用, 以及所有它的其他功能通过点语法以及调用类来激活.\n2.6.3 使用已经实现的对象 我们现在回到之前章节的使用银行账户的例子. 使用我们实现了的对象系统, 我们会创建一个Account类, 一个CheckingAccount子类, 以及一个各自的实例.\nAccount类是通过make_account_class函数创建的, 也就是跟在Python中的class声明有相似结构的函数, 但是以调用make_class结束.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026gt;\u0026gt;\u0026gt; def make_account_class(): \u0026#34;\u0026#34;\u0026#34;Return the Account class, which has deposit and withdraw methods.\u0026#34;\u0026#34;\u0026#34; interest = 0.02 def __init__(self, account_holder): self[\u0026#39;set\u0026#39;](\u0026#39;holder\u0026#39;, account_holder) self[\u0026#39;set\u0026#39;](\u0026#39;balance\u0026#39;, 0) def deposit(self, amount): \u0026#34;\u0026#34;\u0026#34;Increase the account balance by amount and return the new balance.\u0026#34;\u0026#34;\u0026#34; new_balance = self[\u0026#39;get\u0026#39;](\u0026#39;balance\u0026#39;) + amount self[\u0026#39;set\u0026#39;](\u0026#39;balance\u0026#39;, new_balance) return self[\u0026#39;get\u0026#39;](\u0026#39;balance\u0026#39;) def withdraw(self, amount): \u0026#34;\u0026#34;\u0026#34;Decrease the account balance by amount and return the new balance.\u0026#34;\u0026#34;\u0026#34; balance = self[\u0026#39;get\u0026#39;](\u0026#39;balance\u0026#39;) if amount \u0026gt; balance: return \u0026#39;Insufficient funds\u0026#39; self[\u0026#39;set\u0026#39;](\u0026#39;balance\u0026#39;, balance - amount) return self[\u0026#39;get\u0026#39;](\u0026#39;balance\u0026#39;) return make_class(locals())   最后调用locals返回一个有字符串为键的字典, 它在局部帧中包含新的名值绑定.\nAccount类最后是通过赋值来实例化的.\n1  \u0026gt;\u0026gt;\u0026gt; Account = make_account_class()   然后, 一个账户实例通过new消息来创建, 也就是需要一个名称来给新创建的账户.\n1  \u0026gt;\u0026gt;\u0026gt; kirk_account = Account[\u0026#39;new\u0026#39;](\u0026#39;Kirk\u0026#39;)   然后, get消息传递给kirk_account来检索属性以及方法. 方法可以被调用来更新账户的余额.\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; kirk_account[\u0026#39;get\u0026#39;](\u0026#39;holder\u0026#39;) \u0026#39;Kirk\u0026#39; \u0026gt;\u0026gt;\u0026gt; kirk_account[\u0026#39;get\u0026#39;](\u0026#39;interest\u0026#39;) 0.02 \u0026gt;\u0026gt;\u0026gt; kirk_account[\u0026#39;get\u0026#39;](\u0026#39;deposit\u0026#39;)(20) 20 \u0026gt;\u0026gt;\u0026gt; kirk_account[\u0026#39;get\u0026#39;](\u0026#39;withdraw\u0026#39;)(5) 15   就像Python的对象系统, 设置一个实例的属性不会修改它对应的类的属性.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; kirk_account[\u0026#39;set\u0026#39;](\u0026#39;interest\u0026#39;, 0.04) \u0026gt;\u0026gt;\u0026gt; Account[\u0026#39;get\u0026#39;](\u0026#39;interest\u0026#39;) 0.02   继承. 我们可以通过重载一个类的属性的子集来创建一个子类CheckingAccount. 在这个例子中, 我们修改withdraw方法去征收费用, 同时我们降低利率.\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; def make_checking_account_class(): \u0026#34;\u0026#34;\u0026#34;Return the CheckingAccount class, which imposes a $1 withdrawal fee.\u0026#34;\u0026#34;\u0026#34; interest = 0.01 withdraw_fee = 1 def withdraw(self, amount): fee = self[\u0026#39;get\u0026#39;](\u0026#39;withdraw_fee\u0026#39;) return Account[\u0026#39;get\u0026#39;](\u0026#39;withdraw\u0026#39;)(self, amount + fee) return make_class(locals(), Account)   在这个实现中, 我们从子类的withdraw函数调用基类Account的withdraw函数, 就像在Python的内建对象系统中一样. 我们可以像之前一样创建子类本身以及一个实例.\n1 2  \u0026gt;\u0026gt;\u0026gt; CheckingAccount = make_checking_account_class() \u0026gt;\u0026gt;\u0026gt; jack_acct = CheckingAccount[\u0026#39;new\u0026#39;](\u0026#39;Spock\u0026#39;)   存款的行为完全相同, 跟构造函数一样. 取款从特殊的withdraw方法征收$1的费用, 同时interest有来自于CheckingAccount的新的更低的值.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; jack_acct[\u0026#39;get\u0026#39;](\u0026#39;interest\u0026#39;) 0.01 \u0026gt;\u0026gt;\u0026gt; jack_acct[\u0026#39;get\u0026#39;](\u0026#39;deposit\u0026#39;)(20) 20 \u0026gt;\u0026gt;\u0026gt; jack_acct[\u0026#39;get\u0026#39;](\u0026#39;withdraw\u0026#39;)(5) 14   我们的建立在字典之上的对象系统跟Python内建的对象系统的实现是十分类似的. 在Python中, 任何一个用户定义类的实例都具有一个特别的属性__dict__用于在字典中为这个对象存储本地实例属性. 就像我们的字典attributes. Python的不同在于它区分某些跟内建函数交互的特别方法以确保这些函数行为对很多不同类型的参数是正确的. 在不同类型上操作的函数是下一节的主题.\n2.7 对象抽象 对象系统允许程序员去高效地建立以及使用抽象数据表示. 它同样也设计为允许在同一程序内共存多重数据抽象表示.\n对象抽象的一个中心概念是泛型函数, 也就是一个可以接受多种不同类型值的函数, 在实现泛型函数中我们会考虑三种不同的技术: 共享实例, 类型派发, 以及强制类型. 在建立这些概念的过程中, 我们也会发现Python的对象系统中的特性也就是支持泛型的创建.\n2.7.1 字符串转换 为了有效地表示数据, 一个对象值应该表现得像它所代表的类型的数据, 包括产出它自身所代表的字符串. 数据值的字符串表示在交互式语言中是十分重要的, 例如Python会自动地展示交互式会话中的表达式的值的字符串表示.\n字符串值提供了在人之间进行传达信息的基本介质. 字符序列可以被渲染到屏幕上, 打印到纸上, 大声读, 转换成盲文, 或者以摩尔斯密码广播. 字符串同样也是编程的根本因为它们可以表示Python的表达式.\nPython规定所有的对象应该产出两种不同的字符串表示: 一种是可以被人类解释的文本以及一种是可以被Python解释的表达式. 字符串的构造函数str, 返回一个可以被人类阅读的字符串. 在可能的情况下, repr函数返回一个Python表达式, 其运算结果为相等的对象. repr的文档字符串解释了这个属性:\nrepr(object) -\u0026gt; string 返回对象表示的标准字符串.\n对大多数对象类型来说, eval(repr(object)) == object.\n对一个表达式的值调用repr的结果就是Python打印在交互式回话中所打印的.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; 12e12 12000000000000.0 \u0026gt;\u0026gt;\u0026gt; print(repr(12e12)) 12000000000000.0   在原始值没有表达存在的情况下, Python通常会产出一个被角括号包围的描述.\n1 2  \u0026gt;\u0026gt;\u0026gt; repr(min) \u0026#39;\u0026lt;built-in function min\u0026gt;\u0026#39;   str构造器通常跟repr重合, 但是在某些情况下会提供更多的可解释文本的表示. 例如, 我们会看到在dates对象上str与repr之间的不同.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; from datetime import date \u0026gt;\u0026gt;\u0026gt; tues = date(2011, 9, 12) \u0026gt;\u0026gt;\u0026gt; repr(tues) \u0026#39;datetime.date(2011, 9, 12)\u0026#39; \u0026gt;\u0026gt;\u0026gt; str(tues) \u0026#39;2011-09-12\u0026#39;   定义repr函数提出了一个新的挑战: 我们想要它在所有类型的日期下都能够正确应用, 即使这些类型在repr实现的时候还不存在. 我们会想要让它成为一个通用或者多态性函数, 一个可以被应用在很多(聚合/poly)不同类型(变形/morph)的数据.\n在这种情况下, 对象系统提供一个优雅的解决办法: repr函数总是调用它参数上的一个叫做__repr__的方法.\n1 2  \u0026gt;\u0026gt;\u0026gt; tues.__repr__() \u0026#39;datetime.date(2011, 9, 12)\u0026#39;   通过在用户定义类上实现这一相同的方法, 我们可以拓展repr的适用性到未来我们创建的任何类上. 总的来说, 这一例子强调了点表达式的其他好处, 就是它们提供了将现有函数的域扩展为新对象类型的机制.\nstr构造器也是以相似的方式实现: 它调用参数上的一个叫做__str__的方法.\n1 2  \u0026gt;\u0026gt;\u0026gt; tues.__str__() \u0026#39;2011-09-12\u0026#39;   这些多态函数用于演示更一般的原理: 某些函数应该应用到多种数据类型上. 此外, 创建此类函数的一种方式是在每个类上使用不同定义的共享属性名称.\n2.7.2 特殊方法 在Python中, 某些特殊方法是通过Python解析器在特殊情况下调用的. 例如, 无论什么时候一个对象被创建时类的__init__方法会自动被调用. 当进行打印时__str__会自动被调用, 以及__repr__在互动式回话中被调用来显示值.\nPython中有许多其他行为的特殊名称. 其中一些最常使用的已经描述在下面.\n真假值. 前面我们看到在Python中数字具有真实值; 更进一步来说, 0代表假值而其他所有数字代表真值. 实际上, 在Python中的所有对象具有真值. 默认地, 用户定义的类的对象都认为是真值, 但是特殊方法__bool__可以用来重载这个行为. 如果一个对象定义了__bool__方法, 那么Python将调用这个方法来判断它的真实值.\n举个例子, 假设我们想要让一个余额为0的银行账户是假值. 我们可以添加一个__bool__方法到Account类来创造这个行为.\n1  \u0026gt;\u0026gt;\u0026gt; Account.__bool__ = lambda self: self.balance != 0   我们可以调用布尔构造器来查看一个对象的真实值, 然后我们可以使用布尔上下文中的任何对象.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; bool(Account(\u0026#39;jack\u0026#39;)) False \u0026gt;\u0026gt;\u0026gt; if not Account(\u0026#39;jack\u0026#39;): print(\u0026#39;jack has nothing\u0026#39;) jack has nothing   序列操作. 我们已经知道可以使用len函数来确定序列的长度.\n1 2  \u0026gt;\u0026gt;\u0026gt; len(\u0026#39;Go Bears!\u0026#39;) 9   len函数调用它的参数的__len__方法来判断参数的长度. 所有內建序列类型都实现这一方法.\n1 2  \u0026gt;\u0026gt;\u0026gt; \u0026#39;Go Bears!\u0026#39;.__len__() 9   如果一个序列没有提供__bool__方法, Python会使用一个序列的长度来判断它的真实值. 空序列为假值, 而非空序列则为真值.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; bool(\u0026#39;\u0026#39;) False \u0026gt;\u0026gt;\u0026gt; bool([]) False \u0026gt;\u0026gt;\u0026gt; bool(\u0026#39;Go Bears!\u0026#39;) True   __getitem__方法通过元素选择操作符来调用, 但它也可以被直接调用.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; \u0026#39;Go Bears!\u0026#39;[3] \u0026#39;B\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;Go Bears!\u0026#39;.__getitem__(3) \u0026#39;B\u0026#39;   可调用对象. 在Python, 函数是一等对象, 因此它们可以作为数据进行传递以及可以像其他对象一样具有属性值. Python也允许我们通过引入一个__call__方法来定义一个像函数一样可以\u0026quot;调用\u0026quot;的对象. 使用这种方法, 我们可以定义一个行为像高阶函数的类.\n举个例子, 考虑下接下来的高阶函数, 它会返回一个函数这个函数会添加一个常量值到它的参数上.\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; def make_adder(n): def adder(k): return n + k return adder \u0026gt;\u0026gt;\u0026gt; add_three = make_adder(3) \u0026gt;\u0026gt;\u0026gt; add_three(4) 7   我们可以创建一个定义了__call__方法并提供相同功能的Adder类.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; class Adder(object): def __init__(self, n): self.n = n def __call__(self, k): return self.n + k \u0026gt;\u0026gt;\u0026gt; add_three_obj = Adder(3) \u0026gt;\u0026gt;\u0026gt; add_three_obj(4) 7   这里, Adder类的行为跟高阶函数make_adder相似, add_three_obj对象的行为跟add_three函数的行为相似. 我们进一步地模糊了数据与函数之间的界限.\n算术. 特殊方法还可以定义应用于用户定义对象的内置运算符的行为. 为了提供这种一般性, Python遵循特殊协议来应用每一个操作符. 例如, 要运行含有+操作符的表达式, Python检查特殊方法表达式左右两边的操作数. 首先, Python检查左操作数的__add__方法的值, 然后检查右操作数的__radd__方法的值. 如果任意一个能找到, 这个方法会以其他操作数的值作为参数被调用. 一些例子将在下面的章节中给出. 对于想要进一步了解细节的读者, Python文档描述了完整的操作符名称集. Dive into Python 3 也有一个特殊方法名称集章节, 它描述了有多少这些特殊方法名称被使用.\n2.7.3 多重表示 抽象屏障允许我们分离数据的使用以及表示. 然而, 在大型程序中, 对程序中的数据类型表示为\u0026quot;底层表示\u0026quot;并不总是有意义的. 一方面, 对数据对象可能有多个有用的表示, 同时我们可能喜欢去设计可以处理多重表示的系统\n举个简单的例子, 复数可能会用两种相等的方式来表示: 以直角坐标形式(实部和虚部)以及以极坐标形式(幅度和角度). 有时候直角坐标形式更加适合, 而有时候极坐标形式更加适合. 实际上, 考虑这样的一个需要表示两种形式的复数系统以及能在其中一种表示下操纵复数来工作的函数是十分合理的. 我们会在下面实现这样的一个系统. 作为附注, 我们正在开发一个系统, 它会对复数执行算术运算来作为使用通用操作的程序的简单但不现实的例子. 复数类型在Python中是內建类型, 但对于这个例子我们会实现自己的复数类型.\n允许数据进行多重表示的想法常常会出现. 大型软件系统通常由许多长期工作的人设计, 且受制于随时间变化的要求. 在这样的环境下, 允许为每个人提前选择好数据的表示是根本不可能的. 此外, 数据抽象屏障从使用中隔离了表示, 我们需要隔离彼此不同的设计选择的抽象屏障并允许不同设计选择在单个程序中共存.\n我们会在高层次的抽象以及朝实现具体表示上来设计自己的实现. 一个Complex是一个Number, 而数字可以加或者乘在一起. 抽象了的数字如何能够通过名为add以及mul的方法被加或者乘在一起.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; class Number: def __add__(self, other): return self.add(other) def __mul__(self, other): return self.mul(other)   这个类要求数字对象具有add以及mul方法, 但是没有定义它们. 它甚至没有提供一个__init__方法. Number的目的不是用来直接实例化, 而是作为超类为各种指定数字类型提供服务. 我们的下一个任务是定义适合于复数的add以及mul方法.\n一个复数可以想象成是由两个正交轴形成的二维空间中的一个点, 实轴以及虚轴. 从这个角度看, 复数c = real + imag * i(这里的i * i = -1)可以认为是一个平面上的点, 它的水平坐标是real, 垂直坐标是imag. 复数加法涉及到增加它们各自的real轴以及imag轴的坐标.\n当乘以复数时, 将其想象成一个极坐标上以幅度和角度表示的复数会更加自然. 两个复数的乘积的结果就是的到一个向量值, 由其中一个复数的向量值跟另一个复数的向量值长度因子的乘积的得到, 然后加上一个角度值, 由其中一个复数的角度, 旋转值为另一个向量的角度得到.\nComplex类继承自Number类, 并描述了复数的算术.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; class Complex(Number): def add(self, other): return ComplexRI(self.real + other.real, self.imag + other.imag) def mul(self, other): magnitude = self.magnitude * other.magnitude return ComplexMA(magnitude, self.angle + self.angle)   这个实现假设对于复数存在两个类, 跟复数的两个自然表示相对应:\n ComplexRI从实部和虚部来构造一个复数 ComplexMA从向量和角度来构造一个复数  接口. 对象属性是消息传递的一种形式, 允许不同数据类型以不同的方式来响应相同的消息. 从不同类中引出相同行为的一组共享消息是一种强大的抽象方法. 一个_接口_就是一个共享属性名以及它们的行为规范的集合. 在复数的例子中, 接口需要实现由四个属性组成的算法: real, imag, magnitude和angle.\n想要在复杂的算术上是正确的, 这些属性必须要一致. 也就是说, 直角坐标系(real, imag)以及极坐标系(magnitude, angle)必须在复平面上是描述相同的点. Complex类通过决定这些属性如何用于跟一个复数来进行add以及mul从而隐式定义这个接口.\n属性. 要求两个或多个属性值保持彼此之间的固定关系是一个新的问题. 一个解决办法是只为其中一个表示保存属性值然后其他表示则在它们需要的时候计算出来.\nPython具有一个简单功能用于从零参数函数即时计算属性. @property装饰器允许调用函数而不调用表达式语法(跟随表达式后的括号). ComplexRI类保存real以及imag属性, 同时一经请求则计算magnitude和angle.\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; from math import atan2 \u0026gt;\u0026gt;\u0026gt; class ComplexRI(Complex): def __init__(self, real, imag): self.real = real self.imag = imag @property def magnitude(self): return (self.real ** 2 + self.imag ** 2) ** 0.5 @property def angle(self): return atan2(self.imag, self.real) def __repr__(self): return \u0026#39;ComplexRI({0:g}, {1:g})\u0026#39;.format(self.real, self.imag)   这个实现的结果是, 全部的四个复数算法需要的属性都可以不用任何调用表达式就访问到, 同时修改real以及imag都会反映到magnitude以及angle中.\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; ri = ComplexRI(5, 12) \u0026gt;\u0026gt;\u0026gt; ri.real 5 \u0026gt;\u0026gt;\u0026gt; ri.magnitude 13.0 \u0026gt;\u0026gt;\u0026gt; ri.real = 9 \u0026gt;\u0026gt;\u0026gt; ri.real 9 \u0026gt;\u0026gt;\u0026gt; ri.magnitude 15.0   同样地, ComplexMA类保存magnitude以及angle, 但当real以及imag被查找时会立马计算得出.\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; from math import sin, cos, pi \u0026gt;\u0026gt;\u0026gt; class ComplexMA(Complex): def __init__(self, magnitude, angle): self.magnitude = magnitude self.angle = angle @property def real(self): return self.magnitude * cos(self.angle) @property def imag(self): return self.magnitude * sin(self.angle) def __repr__(self): return \u0026#39;ComplexMA({0:g}, {1:g} * pi)\u0026#39;.format(self.magnitude, self.angle/pi)   修改magnitude或者angle都会立马反映到real以及imag属性上.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; ma = ComplexMA(2, pi/2) \u0026gt;\u0026gt;\u0026gt; ma.imag 2.0 \u0026gt;\u0026gt;\u0026gt; ma.angle = pi \u0026gt;\u0026gt;\u0026gt; ma.real -2.0   我们现在已经完成了复数的实现. 实现了复数的任意类可以在任意Complex的算法上使用任意的参数.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; from math import pi \u0026gt;\u0026gt;\u0026gt; ComplexRI(1, 2) + ComplexMA(2, pi/2) ComplexRI(1, 4) \u0026gt;\u0026gt;\u0026gt; ComplexRI(0, 1) * ComplexRI(0, 1) ComplexMA(1, 1 * pi)   编码多个表示的借口方法具有吸引人的属性. 类可以为每个表示单独开发; 它们必须也只需商定共享的属性的名称, 以及这些属性的任何行为条件. 接口是额外附加的. 如果其他程序员想要添加第三个复数的表示到相同的程序中, 它们只需要创建另外一个具有相同属性的类.\n数据的多重表示跟我们这章的一开始的数据抽象的思想密切相关. 使用数据抽象, 我们能够去修改数据类型的实现而不修改程序的含义. 通过接口以及消息传递, 我们可以在相同的程序内有多种不同的表示. 这两种情况下, 名称集合以及对应的行为条件定义了实现这种灵活性的抽象.\n2.7.4 通用函数 通用函数是一个可应用在不同类型参数上的方法或者函数. 我们已经见识过很多的例子. Complex.add方法是通用的, 因为它采用ComplexRI或者ComplexMA作为other的值. 这个灵活性是通过确保ComplexRI以及ComplexMA的共享同一个接口来获得的. 使用接口以及消息传递只是一些用来实现通用函数的方法其中的一种. 在这一节中, 我们会考虑其他两个: 类型调度以及类型强制.\n假设, 除了我们的复数类型, 我们实现了一个Rational类来代表准确的分数. add以及mul方法跟本章之前的add_rational以及mul_rational表示相同的计算.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; from fractions import gcd \u0026gt;\u0026gt;\u0026gt; class Rational(Number): def __init__(self, numer, denom): g = gcd(numer, denom) self.numer = numer // g self.denom = denom // g def __repr__(self): return \u0026#39;Rational({0}, {1})\u0026#39;.format(self.numer, self.denom) def add(self, other): nx, dx = self.numer, self.denom ny, dy = other.numer, other.denom return Rational(nx * dy + ny * dx, dx * dy) def mul(self, other): numer = self.numer * other.numer denom = self.denom * other.denom return Rational(numer, denom)   我们通过给超类包含add记忆mul方法已经实现了接口. 结果是, 我们可以用熟悉的操作来加上以及相乘有理数.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; Rational(2, 5) + Rational(1, 10) Rational(1, 2) \u0026gt;\u0026gt;\u0026gt; Rational(1, 4) * Rational(2, 3) Rational(1, 6)   然而, 我们还是不能将一个有理数加到一个复数上, 即使在数学上已经明确定义了这样的组合. 我们想要以一些小心控制的方式来介绍这种跨类型操作, 因此我们可以假设它没有严重违反我们的抽象屏障. 这跟我们所期望的结果之前存在紧密的关系: 我们想要能够将一个复数添加到一个有理数上, 以及我们想要一般方法__add__能够对所有的数字类型都做正确的事情. 同时, 为了维护程序的模块化, 我们想要尽可能分离复数与有理数的关注.\n类型调度. 一种实现跨类型操作的方式是基于函数或方法的参数的类型来选择行为. 类型调度的思想是去写一个函数来检查它们接收的参数的类型, 然后为这些类型执行合适的代码.\n內建函数isinstance接受一个对象以及一个类. 如果对象所具有的类是这个类或者是继承自这个类的话就返回真值.\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; c = ComplexRI(1, 1) \u0026gt;\u0026gt;\u0026gt; isinstance(c, ComplexRI) True \u0026gt;\u0026gt;\u0026gt; isinstance(c, Complex) True \u0026gt;\u0026gt;\u0026gt; isinstance(c, ComplexMA) False   类型派发的一个简单的例子是一个为不同类型的复数使用不同的实现的is_real函数.\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; def is_real(c): \u0026#34;\u0026#34;\u0026#34;Return whether c is a real number with no imaginary part.\u0026#34;\u0026#34;\u0026#34; if isinstance(c, ComplexRI): return c.imag == 0 elif isinstance(c, ComplexMA): return c.angle % pi == 0 \u0026gt;\u0026gt;\u0026gt; is_real(ComplexRI(1, 1)) False \u0026gt;\u0026gt;\u0026gt; is_real(ComplexMA(2, pi)) True   类型派发并不总是使用isinstance来执行的. 对于算术, 我们会为字符类型的Rational以及Complex的实例提供一个type_tag属性, 这个属性是一个字符串值. 当两个值x以及y都具有type_tag, 那么我们就可以用x.add(y)直接合并它们. 如果没有, 我们需要一个跨类型操作.\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; Rational.type_tag = \u0026#39;rat\u0026#39; \u0026gt;\u0026gt;\u0026gt; Complex.type_tag = \u0026#39;com\u0026#39; \u0026gt;\u0026gt;\u0026gt; Rational(2, 5).type_tag == Rational(1, 2).type_tag True \u0026gt;\u0026gt;\u0026gt; ComplexRI(1, 1).type_tag == ComplexMA(2, pi / 2).type_tag True \u0026gt;\u0026gt;\u0026gt; Rational(2, 5).type_tag == ComplexRI(1, 1).type_tag False   要将复数跟有理数结合, 我们需要编写同时依赖它们表现类型的函数. 接下来, 我们依赖一个事实, 那就是一个Rational可以近似转换为一个实数的float类型值. 这个结果可以用复数来进行组合.\n1 2  \u0026gt;\u0026gt;\u0026gt; def add_complex_and_rational(c, r): return ComplexRI(c.real + r.number/r.denom, c.imag)   乘法涉及到相似的转换, 在极坐标下, 在复平面上的实数总是具有一个正的向量. 角度0表示一个正数, 角度pi表示一个负数.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; def mul_complex_and_rational(c, r): r_magnitude, r_angle = r.numer/r.denom, 0 if r_magnitude \u0026lt; 0: r_magnitude, r_angle = -r_magnitude, pi return ComplexMA(c.magnitude * r_magnitude, c.angle + r_angle)   乘法跟加法都是可交换的, 因此交换参数顺序可以用这些跨类型操作的相同实现.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; def add_rational_and_complex(r, c): return add_complex_and_rational(c, r) \u0026gt;\u0026gt;\u0026gt; def mul_rational_and_complex(r, c): return mul_complex_and_rational(c, r)   类型调度扮演的角色是去确保这些跨类型操作在适当的时候使用. 下面, 我们重写Number超类为其__add__以及__mul__来使用类型调度.\n我们使用type_tag属性来区分参数的类型. 也可以直接使用內建的isinstance方法, 但是tags简化了实现. 使用类型标签也表明了类型调度不需要跟Python的类型系统相链接, 而是用于在异构域上创建通用函数的一般技术.\n__add__方法考虑两种情况. 首先, 如果两个参数具有相同的类型的标签, 那么它假设第一个参数的add方法可以以第二个参数作为它的参数. 否则, 它检查是否一个跨类型的字典实现, 叫做adders, 包含一个可以对具有这些类型标签的参数进行相加的函数. 如果有这样的一个函数, cross_apply方法并应用它. __mul__方法具有相似的结构.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026gt;\u0026gt;\u0026gt; class Number: def __add__(self, other): if self.type_tag == other.type_tag: return self.add(other) elif (self.type_tag, other.type_tag) in self.adders: return self.cross_apply(other, self.adders) def __mul__(self, other): if self.type_tag == other.type_tag: return self.mul(other) elif (self.type_tag, other.type_tag) in self.multipliers: return self.cross_apply(other, self.multipliers) def cross_apply(self, other, cross_fns): cross_fn = cross_fns[(self.type_tag, other.type_tag)] return cross_fn(self, other) adders = {(\u0026#34;com\u0026#34;, \u0026#34;rat\u0026#34;): add_complex_and_rational, (\u0026#34;rat\u0026#34;, \u0026#34;com\u0026#34;): add_rational_and_complex} multipliers = {(\u0026#34;com\u0026#34;, \u0026#34;rat\u0026#34;): mul_complex_and_rational, (\u0026#34;rat\u0026#34;, \u0026#34;com\u0026#34;): mul_rational_and_complex}   在新的Number类中, 所有跨类型实现都通过一对类型标签标记在adders以及multipliers字典中.\n这种基于字典的类型调度方法是可拓展的. 新的Number子类型可以通过声明一个类型标签以及添加跨类型操作到Number.adders以及Number.multipliers从而安装到系统中. 它们也可以定义在子类中定义自己的adders以及multipliers.\n虽然我们引入了一些复杂性到系统中, 但我们现在可以混合类型在加法以及乘法表达式中.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; ComplexRI(1.5, 0) + Rational(3, 2) ComplexRI(3, 0) \u0026gt;\u0026gt;\u0026gt; Rational(-1, 2) * ComplexMA(4, pi/2) ComplexMA(2, 1.5 * pi)   强制转换. 一般情况下完全不相关的操作作用于完全无关的类型上, 实现明确的跨类型操作也许是可以期望的最好的方式, 虽然它可能会很麻烦. 幸运的是, 有时我们可以通过利用在我们的系统中潜在的附加结构来做得更好. 不同的数据类型通常是不完全独立的, 并且这里或许存在将一种类型的对象看做是另外一种类型对象的方式. 这过程叫做强制转换. 例如, 如果我们被要求以算术将有理数和复数进行结合, 我们可以将有理数看作是复数且它的虚部是0. 这样做了之后, 我们可以用Complex.add以及Complex.mul来结合它们.\n一般情况下, 我们可以通过设计强制转换函数实现这个想法, 这个函数可以转换一种类型的对象到另一种类型的等量对象. 这里是一个典型的强制转换函数, 它可以转换一个有理数为一个虚部是0的复数:\n1 2  \u0026gt;\u0026gt;\u0026gt; def rational_to_complex(r): return ComplexRI(r.numer/r.denom, 0)   Number类的替代定义通过尝试强制转换两个参数为相同的类型来执行跨类型操作. coercions字典通过类型标签元组对索引所有可能的强制类型, 指示相对应的值将所述第一种类型的值强制转换为第二种类型的值.\n通常不可能每种数据类型的任意数据对象强制转换成其他所有类型. 例如, 没有办法将强制转换一个任意复数为有理数, 因此没有这样的强制转换实现会出现在coercions字典中.\ncoerce方法返回两个具有相同类型标签的值. 它检查它的参数的类型标签的值, 将它们跟coercions字典的条目对比, 然后用coerce_to转换一个参数类型为另一个参数的类型. 在coercions中只需要一个条目来完成我们的跨类型算术系统, 并替换类型调度版本的Number中的四个跨类型函数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026gt;\u0026gt;\u0026gt; class Number: def __add__(self, other): x, y = self.coerce(other) return x.add(y) def __mul__(self, other): x, y = self.coerce(other) return x.mul(y) def coerce(self, other): if self.type_tag == other.type_tag: return self, other elif (self.type_tag, other.type_tag) in self.coercions: return (self.coerce_to(other.type_tag), other) elif (other.type_tag, self.type_tag) in self.coercions: return (self, other.coerce_to(self.type_tag)) def coerce_to(self, other_tag): coercion_fn = self.coercions[(self.type_tag, other_tag)] return coercion_fn(self) coercions = {(\u0026#39;rat\u0026#39;, \u0026#39;com\u0026#39;): rational_to_complex}   这个强制类型方案跟定义显示跨类型操作的方法相比有一些优点. 虽然我们还是需要编写强制转换函数来关联类型, 但我们只需要为每一对类型编写一个函数, 而不是为每个类型集合以及每个通用操作使用不同的函数. 我们在这里期望要指出的事实是, 类型之间的适当转换仅依赖于类型本身, 而不是以来要应用的特定操作.\n更进一步的好处来自于扩展强制转换. 一些更复杂的强制转换方案并不是仅仅是尝试去强制转换一种类型到另一种, 而是可能会尝试去强制转换每个不同的类型到第三种常见类型. 考虑一个菱形以及一个矩形: 两者都不是彼此类型的额外情况, 但是都可以被看作是四边形. 另一个强制转换的扩展是强制转换迭代, 一种数据类型通过中间类型被强制转换成另一种类型. 思考一下一个整数可以被转换成一个实数只要首先将它转换成一个有理数, 然后将这个有理数转换成实数. 以这种方式的链接强制转换可以减少程序所需的强制函数的总数.\n尽管强制转换具有好处, 但也有潜在的缺点. 一个是强制函数在应用它们时可能会丢失信息. 在我们的例子中, 有理数是精确表示, 但是当它们被转换成复数时就成了近似值.\n一些编程语言有內建自动的强制转换系统. 实际上, 早期版本的Python有一个__coerce__特殊方法在对象上. 最后, 内置强制系统的复杂性没有证明它的使用是有理的, 因此它被移除了. 而是, 特定运算根据需要对它们的参数应用强制转换.\n2.8 效率 决定如何表示以及传输数据常常收可供选择的效率影响. 效率指的是表示或处理过程使用的计算资源, 例如函数计算结果或者表示一个对象需要用到多少时间以及内存. 这些数量根据实现的细节可以有很大的差异.\n2.8.1 测量效率 精确地测量一个程序需要多长时间来运行或者消耗多少内存是一个挑战, 因为结果取决于很多电脑配置的细节. 一个更可靠的方式去描绘程序效率特征的方式是去测量某些事件发生了多少次, 例如函数的调用.\n让我们回到第一个数递归函数, fib函数用于计算斐波那契数列中的数字.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; def fib(n): if n == 0: return 0 if n == 1: return 1 return fib(n - 2) + fib(n - 1) \u0026gt;\u0026gt;\u0026gt; fib(5) 5   思考一下下面描述的来自于计算fib(6)的结果的计算模式. 去计算fib(5), 我们需要计算fib(3)以及fib(4). 要计算fib(3), 我们需要计算fib(1)以及fib(2). 一般来说, 演进的过程看起来像一棵树. 每个蓝色点表示一个完整的计算斐波那契数的这棵树的遍历.\n这棵树是典型的用于指导树递归的例子, 但是这是一个非常没有效率的计算斐波那契数的方式, 因为它做了许多冗余的计算. fib(3)的整个计算过程是多余的.\n我们可以测量这种低效率. 高等级的count函数返回一个跟它的参数(也维持一个call_count属性)的等效函数. 用这种方法, 我们可以检查fib调用了多少次.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; def count(f): def counted(*args): counted.call_count += 1 return f(*args) counted.call_count = 0 return counted   通过统计调用fib的次数, 我们可以看到需要的调用次数增长得比斐波那契数字本身要快很多. 这种快速增长的调用次数就是树递归函数的特征.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; fib = count(fib) \u0026gt;\u0026gt;\u0026gt; fib(19) 4181 \u0026gt;\u0026gt;\u0026gt; fib.call_count 13529   空间. 要明白函数对空间的要求, 我们必须要指出在我们的计算环境模型中一般会有多少空间被使用, 保存以及回收. 在计算表达式时, 解析器保存所有的活动环境以及被这些环境所引用的所有的值和帧. 一个环境如果它需要为某些需要将要运行的表达式提供执行上下文那么它就是活动的. 任何时候当创建函数调用的第一个帧最后返回的时候, 这个环境就变为非活动状态.\n例如, 当计算fib, 解析器按照前面展示的顺序对每个值进行计算, 遍历树结构. 这样做, 只需要在计算树中的任何节点时对当前节点的上一个节点保持跟踪. 用于执行剩下的分支的内存是可回收的, 因为它不能影响到未来的计算. 一般来说, 树递归函数需要的空间跟树的最大深度成正比.\n下面的图例描绘了执行fib(3)时创建的环境. 在执行最初的fib程序的返回的表达式的过程中, 表达式fib(n-2)被运行, 产生值0. 一旦这个值计算完成, 相应的环境帧(灰色淡出的那个)就不再需要了: 它不再是活动环境的一部分. 因此, 一个设计良好的解析器可以回收用于存储这个帧的内存. 另一方面, 如果这个解析器当前正在执行fib(n-1), 那么一个环境会通过fib程序(在这里的n是2)创建且是活动的. 反过来, 原来创建的应用3的fib环境依然是活动的, 因为它的返回值还没有被计算出来.\n 高阶的count_frames函数追踪open_count函数, 调用函数函数f的次数依然没有返回. max_count属性是通过open_count而获得的最大值, 而且它跟在计算过程中同时处于活动状态的帧的最大数相对应.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026gt;\u0026gt;\u0026gt; def count_frames(f): def counted(*args): counted.open_count += 1 counted.max_count = max(counted.max_count, counted.open_count) result = f(*args) counted.open_count -= 1 return result counted.open_count = 0 counted.max_count = 0 return counted \u0026gt;\u0026gt;\u0026gt; fib = count_frames(fib) \u0026gt;\u0026gt;\u0026gt; fib(19) 4181 \u0026gt;\u0026gt;\u0026gt; fib.open_count 0 \u0026gt;\u0026gt;\u0026gt; fib.max_count 19 \u0026gt;\u0026gt;\u0026gt; fib(24) 46368 \u0026gt;\u0026gt;\u0026gt; fib.max_count 24   总的来说, 在活动帧中测量的fib函数需要的空间小于输入, 其趋势是趋向更小的. 在总的递归调用中测量的时间需求是大于输出的, 其趋势是趋向更大的.\n2.8.2 记忆化 树递归计算过程通常可以通过记忆化技术来提高效率, 一个强有力的提高递归函数重复计算的效率的技术. 一个记忆化函数会对之前收到的任何参数的返回值进行存储. 第二次调用fib(25)不会再次递归计算返回值, 而是返回已经被构造而存在的那个值.\n记忆化可以很自然地以高阶函数来表示, 也可以作为一个装饰器来使用. 下面的定义为之前的计算结果创建一个cache, 并以计算它们的参数作为索引. 字典的使用需要传给记忆化函数的参数是不可变的.\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; def memo(f): cache = {} def memoized(n): if n not in cache: cache[n] = f(n) return cache[n] return memoized   如果我们应用memo到斐波那契数的递归计算当中, 就演变出一种新的计算模式, 如下所示.\n在fib(5)的计算当中, 在树右侧的分支上fib(2)以及fib(3)的计算结果在计算fib(4)时被重用. 结果就是, 树递归的许多计算结果是不必要的.\n使用count, 我们可以看到fib函数实际上只对于fib的每个唯一输入调用一次.\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; counted_fib = count(fib) \u0026gt;\u0026gt;\u0026gt; fib = memo(counted_fib) \u0026gt;\u0026gt;\u0026gt; fib(19) 4181 \u0026gt;\u0026gt;\u0026gt; counted_fib.call_count 20 \u0026gt;\u0026gt;\u0026gt; fib(34) 5702887 \u0026gt;\u0026gt;\u0026gt; counted_fib.call_count 35   2.8.3 增长的顺序 进程在消耗计算机时间以及空间资源上可以有巨大的不同, 就像先前的例子演示的那样. 然而, 当调用函数时精准地确定多少空间或时间会被使用是非常困难的任务, 这依赖于很多因素. 一个分析进程的有用的方式是将其分类为一组具有类似需求的进程组. 有效的分类是以进程的_增长顺序_来进行, 简单来说就是进程的资源需求随着函数的输入而如何增长.\n作为增长的顺序的介绍, 我们会在下面分析函数count_factors, 它会统计可以将输入均分的整数的个数. 这个函数会尝试去把n跟每个小于或者等于它的平方根的数进行相除. 这个实现利用如果k可以整除n同时k \u0026lt; 根号n, 那么就有另一个因子j = n / k, 这样的j \u0026gt; 根号n这一事实.\n 执行count_factors需要多少时间? 精确的回答会随着机器的不同而变化, 但是我们可以做一些有用的涉及到计算量的一般性观察. 这个进程执行内部的while语句主体的总次数是小于根号n的最大整数. 在while语句之前或者之后的语句都只执行一次. 因此, 总的执行语句的次数是w * 根号n + v, 这里的w是指在while体内的语句的数量, 而v是指在while语句外面的语句. 虽然这样并不精确, 这个公式通常能够表明执行以n为输入的count_factors函数需要多少时间.\n一个更加准确的描述是很难实现的. 常量w以及v并不是真正的常量, 因为赋值语句有时候会对因子执行有时候不会. 增长的顺序分析允许我们去掩饰这些细节从而分析增长的总体形态. 尤其是, count_factors增长的顺序精确地表示为一个术语, 那就是计算count_factors需要的时间量与根号n等比例缩放, 外加一些常量因数.\nTheta符号. 让n成为一个参数用来衡量输入到某些过程的大小, 同时让$R(n)$成为输入大小为n的过程所需要用到的资源的总数. 在我们之前的例子中, 我们让n作为我们的给定的函数需要去计算的数字, 但也有其他的可能性. 例如, 如果我们的目标是去计算一个数字的平方根的近似值, 我们可能会取n为所需精度的位数.\n$R(n)$可能会测量所需要使用的内存, 执行的基本机器步骤的数量等等. 在计算机中每一步只用固定的时间来执行, 运行表达式所用的时间将与在运行过程中执行的基本机器步骤的数量成比例.\n我们说$R(n)$增长的顺序为$R(n)$, 写作$R(n) = \\Theta(f(n))$ (读作\u0026quot;theta f(n)\u0026quot;), 如果有正的常数k1以及k2独立于n像下面这样:\n$$\n\\begin{equation*}\nk_1 \\cdot f(n) \\leq R(n) \\leq k_2 \\cdot f(n)\n\\end{equation*}\n$$\n对于任何大于某个最小值m的值n. 换句话说, 对于大n, 值$R(n)$总是夹在两个以$f(n)$为规模增长的区间当中:\n 一个下限$k_1 \\cdot f(n)$以及 一个上限$k_2 \\cdot f(n)$  我们可以用应用这个定义来展示运行count_factors(n)所需要的步骤数, 通过检查函数可知其增长为$\\Theta(\\sqrt{n})$.\n首先, 我们选择$k_1=1$以及$m=0$, 使得count_factors(n)的下限状态为对于给定的$n\u0026gt;0$需要执行至少$1 \\cdot\\sqrt{n}$步. 这里至少有4行是在while声明之外执行的, 每一行至少需要一个步骤来执行. 这里至少有两行是在while体内执行的, 包括while头部本身. 所有这些至少需要一个步骤. while体至少执行$\\sqrt{n}-1$次. 将这些下限进行合并, 我们可以看到, 过程至少需要$4 + 3\\cdot (\\sqrt{n}-1)$步, 也就是总是大于$k_1 \\cdot\\sqrt{n}$.\n其次, 我们可以确认上限. 我们假设在count_factors体内的任何单一的一行最多需要p个步骤. 这个假设对于Python中的每一行都不是真的, 但可以适用于这种情况. 然后, 执行count_factors(n)至多需要$p \\cdot(5 + 4 \\sqrt{n})$步, 因为这里有5行在while声明之外, 以及4行(包括头部)在while之内. 这个上限能够保证即使if头部执行为真的情况也适用. 最后, 如果我们选择$k_2=5p$, 那么需要的步骤总是小于$k_2 \\cdot \\sqrt{n}$. 我们的论点是完整的.\n2.8.4 例子: 指数 思考一下计算一个给定数字的指数的问题. 我们会想要一个函数来接受一个基础值b以及一个正整数的指数n然后计算$b^n$. 一个解决方式是通过一个递归定义来实现.\n$$\n\\begin{align*}\nb^n \u0026amp;= b \\cdot b^{n-1} \\\nb^0 \u0026amp;= 1\n\\end{align*}\n$$\n这很容易转换成为递归函数\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; def exp(b, n): if n == 0: return 1 return b * exp(b, n - 1)   这是一个线性递归过程, 需要$\\Theta(n)$部以及$\\Theta(n)$的空间. 正如阶乘一样, 我们可以容易地制定一个相等的线性迭代函数, 它需要相似数量的步数, 但只需要固定的空间.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; def exp_iter(b, n): result = 1 for _ in range(n): result = result * b return result   我们可以通过连续平方以更少的步数来计算指数. 例如, 不是这样计算$b^8$:\n$$\n\\begin{equation*}\nb \\cdot (b \\cdot (b \\cdot (b \\cdot (b \\cdot (b \\cdot (b \\cdot b))))))\n\\end{equation*}\n$$\n我们可以用三个乘法来计算它:\n$$\n\\begin{align*}\nb^2 \u0026amp;= b \\cdot b \\\nb^4 \u0026amp;= b^2 \\cdot b^2 \\\nb^8 \u0026amp;= b^4 \\cdot b^4\n\\end{align*}\n$$\n这个方法在指数是2的倍数的时候可以很好地工作. 一般来说, 如果我们使用递归规则, 我们也可以在计算指数上利用连续平方.\n$$\n\\begin{equation*}\nb^n = \\begin{cases} (b^{\\frac{1}{2} n})^2 \u0026amp; \\text{if $n$ is even} \\\nb \\cdot b^{n-1} \u0026amp; \\text{if $n$ is odd}\n\\end{cases}\n\\end{equation*}\n$$\n我们也可以以一个递归函数来表示这个方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; def square(x): return x * x \u0026gt;\u0026gt;\u0026gt; def fast_exp(b, n): if n == 0: return 1 if n % 2 == 0: return square(fast_exp(b, n // 2)) else: return b * fast_exp(b, n - 1) \u0026gt;\u0026gt;\u0026gt; fast_exp(2, 100) 1267650600228229401496703205376   演化为fast_exp的过程其空间以及步数都以n的对数的规模来增长. 为了看到这一点, 观察用fast_exp计算$b^{2n}$只需要比$b^n$多计算一个乘法. 因此, 我们可以计算的指数的大小被允许是每个新的乘法的翻倍(大约). 由此, 乘法的次数需要一个指数n, 这乘法的次数的增长跟以2为底数的n的对数增长得一样快. 这过程增长为$\\Theta(\\log n)$. $\\Theta(\\log n)$增长与$\\Theta(n)$增长的不同随着n的增大而变得明显. 例如, fast_exp对于n为1000的情况只需要14次乘法而不是1000次.\n2.8.5 增长类别 增长顺序的设计旨在计算简化计算过程的分析以及比较. 很多不同的计算过程都可以具有相同的增长顺序, 这表示它们规模增长的方式是相似的. 计算机科学家必须知道并识别常见的增长顺序以及鉴别具有相同顺序的过程.\n常量. 常量并不会影响过程的增长顺序. 因此, 例如, $\\Theta(n)$以及$\\Theta(500 \\cdot n)$具有相同的增长顺序. 这个属性遵循theta符号的定义, 也就是允许我们去为上下限选择任意常量$k_1$以及$k_2$(例如$\\frac{1}{500}$). 为了简单起见, 常量在增长序列中总是被省去的.\n对数. 对数的基数并不会影响增长顺序的过程, 例如, $\\log_2 n$以及$\\log_{10} n具有相同的增长顺序. 修改对数的基数等于乘以常数因子.\n嵌套. 当一个内部计算过程在外部计算过程的每一步中都重复(执行), 那么整个过程的增长的顺序就是内部和外部过程的中的步骤数的乘积.\n例如, 下面的函数overlap计算共同存在于列表a以及列表b中的元素的个数.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; def overlap(a, b): count = 0 for item in a: if item in b: count += 1 return count \u0026gt;\u0026gt;\u0026gt; overlap([1, 3, 2, 2, 5, 1], [5, 4, 2]) 3   in操作符对于列表而言需要$\\Theta(n)$的运行时间, 这里的n是列表b的长度. 它出现了$\\Theta(m)$次, 这里的m指的是列表a的长度. 表达式item in b是一个内部的过程, 而表达式for item in a循环是外部过程. 这个函数的总的增长顺序是$\\Theta(m \\cdot n)$.\n低阶项. 随着对过程输入的增长, 计算中增长最快的部分主宰着总的资源的消耗. Theta符号能捕捉这种直觉. 总的来说, 除了增长最快的部分, 其他部分都可以抛弃掉而不会对增长的顺序有什么影响.\n例如, 考虑一下one_more函数, 它会返回列表a中有多少个元素是比a中的其中一个元素多一的情况. 也就是说, 列表[3, 14, 15, 9], 元素15比14多一, 因此one_more会返回1.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; def one_more(a): return overlap([x - 1 for x in a], a) \u0026gt;\u0026gt;\u0026gt; one_more([3, 14, 15, 9]) 1   这个计算有两个部分: 列表解析以及调用overlap. 对于长度为n的列表a, 列表解析式需要$\\Theta(n)$个步骤, 而调用overlap需要$\\Theta(n^2)$个步骤. 总的步数是$\\Theta(n + n^2)$, 但这不是表达增长顺序的最简单的方法.\n$\\Theta(n^2 + k \\cdot n)$以及$\\Theta(n^2)$对于任意的常量k都是相等的, 因为$n^2$项对任何k最终都会支配总量. 事实上建立这种等价性边界必须要保持n大于某个最小值m. 为了简单起见, 低阶项总是在增长顺序中舍去, 因此我们永远不会在一个theta表达式中看到总和.\n常见类别. 给定这种等价性, 出现了一小组常见类别的集合用于描述大多数常见的计算过程. 最常见的已经按照最慢的增长到最快的增长顺序列举在下面, 以及随着输入的增长而增长的描述. 下面是每个类别的例子.\n   Category Theta Notation Growth Description Example     Constant $\\Theta(1)$ Growth is independent of the input abs   Logarithmic $\\Theta(\\log{n})$ Multiplying input increments resources fast_exp   Linear $\\Theta(n)$ Incrementing input increments resources exp   Quadratic $\\Theta(n^2)$ Incrementing input adds n resources one_more   Exponential $\\Theta(b^n)$ Incrementing input multiplies resources fib    也存在其他的类别, 例如count_factors的增长$\\Theta(\\sqrt{n})$. 这些类别也是特别常见的.\n指数增长描述了许多不同的增长顺序, 因为修改基数b会影响增长的顺序. 例如, 我们的树递归斐波那契计算函数fib的步数随着它的输入n以指数级增长. 特别地, 可以证明第n个斐波那契数是最接近下面等式的整数:\n$$\n\\begin{equation*}\n\\frac{\\phi^{n-2}}{\\sqrt{5}}\n\\end{equation*}\n$$\n这里的$\\phi$是黄金分割比率:\n$$\n\\begin{equation*}\n\\phi = \\frac{1 + \\sqrt{5}}{2} \\approx 1.6180\n\\end{equation*}\n$$\n我们还指出所需的步骤数与结果成比例, 因此树递归过程需要$\\Theta(\\phi^n)$个步骤, 这是随着n指增长的函数.\n2.9 递归对象 对象可以具有其他对象来作为属性值, 当某个类的对象具有一个属性值, 这个属性值也属于相同的类, 那么这就是一个递归对象.\n2.9.1 链接列表类 链接列表, 在之前的章节里面介绍过, 由一个元素以及列表其余的部分组成. 列表的其余部分本身也是一个链接列表 \u0026ndash; 一个递归定义. 空列表是链表中的一个特殊的情况, 它没有第一个元素以及其他元素. 一个链表是一个序列: 它具有有限的长度以及支持通过索引来选择元素.\n现在我们可以实现一个具有相同行为的类. 在这个版本中, 我们会使用特殊方法名来定义它的行为从而允许我们的类能跟內建的len函数以及在Python中的元素选择操作符(方括号或者operator.getitem)工作. 这些內建函数调用类中的特殊方法名: 长度是通过__len__来计算的, 同时, 元素选择是通过__getitem__来计算的. 空链表是通过一个空的元组来表示, 也就是具有的长度是0同时没有元素.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026gt;\u0026gt;\u0026gt; class Link: \u0026#34;\u0026#34;\u0026#34;A linked list with a first element and the rest.\u0026#34;\u0026#34;\u0026#34; empty = () def __init__(self, first, rest=empty): assert rest is Link.empty or isinstance(rest, Link) self.first = first self.rest = rest def __getitem__(self, i): if i == 0: return self.first else: return self.rest[i - 1] def __len__(self): return 1 + len(self.rest) \u0026gt;\u0026gt;\u0026gt; s = Link(3, Link(4, Link(5))) \u0026gt;\u0026gt;\u0026gt; len(s) 3 \u0026gt;\u0026gt;\u0026gt; s[1] 4   __len__以及__getitem__的定义事实上是递归的. 当以用户定义的对象作为参数应用到內建的Python函数len上时会调用一个叫做__len__的方法. 同样的还有元素选择操作符会调用叫做__getitem__的方法. 因此, 这两种方法的主体内会间接地调用它们自己. 对于__len__, 当self.rest等于一个空的元组时就到达基本情况了, 也就是Link.empty具有的长度为0.\n內建的isinstance函数返回第一个参数是否是第二个参数的类型或者继承自第二个参数的判断结果. 如果rest是一个Link的实例或者是一个Link子类的实例, 那么isinstance(rest, Link)的结果就是真值.\n我们的实现已经完成了, 但是目前却很难检查一个实例是不是Link类. 为了有助于调试, 我们也可以定义一个函数来将Link转换成一个字符串表达式.\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; def link_expression(s): \u0026#34;\u0026#34;\u0026#34;Return a string that would evaluate to s.\u0026#34;\u0026#34;\u0026#34; if s.rest is Link.empty: rest = \u0026#39;\u0026#39; else: rest = \u0026#39;,\u0026#39; + link_expression(s.rest) return \u0026#39;Link({0}{1})\u0026#39;.format(s.first, rest) \u0026gt;\u0026gt;\u0026gt; link_expression(s) \u0026#39;Link(3, Link(4, Link(5)))\u0026#39;   这种展现Link列表的方式是如此的方便以至于我们想要在任何时候都使用它来展现Link的实例. 我们可以通过设定link_expression函数作为特殊的类属性__repr__的的值来确保这个行为. Python通过调用实例的__repr__方法来展现用户定义类的实例.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; Link.__repr__ = link_expression \u0026gt;\u0026gt;\u0026gt; s Link(3, Link(4, Link(5)))   Link类具有闭合属性. 就像一个列表中的元素本身可以是一个列表, 一个Link可以包含一个Link作为它的第一个元素.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; s_first = Link(s, Link(6)) \u0026gt;\u0026gt;\u0026gt; s_first Link(Link(3, Link(4, Link(5))), Link(6))   s_first链接列表室友两个元素, 而它的第一个元素是一个包含三个元素的链接列表.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; len(s_first) 2 \u0026gt;\u0026gt;\u0026gt; len(s_first[0]) 3 \u0026gt;\u0026gt;\u0026gt; s_first[0][2] 5   递归函数尤其适合用来操作链表. 例如, 递归函数extend_link函数构建了一个包含一个Link类的实例s紧跟着另一个Link类的实例t的元素的链表. 将这个函数作为__add__方法安装到Link类来模拟内部列表的添加行为.\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; def extend_link(s, t): if s is Link.empty: return t else: return Link(s.first, extend_link(s.rest, t)) \u0026gt;\u0026gt;\u0026gt; extend_link(s, s) Link(3, Link(4, Link(5, Link(3, Link(4, Link(5)))))) \u0026gt;\u0026gt;\u0026gt; Link.__add__ = extend_link \u0026gt;\u0026gt;\u0026gt; s + s Link(3, Link(4, Link(5, Link(3, Link(4, Link(5))))))   除了列表表达式, 可以使用两个高阶函数来从一个链表生成另一个链表: map_link以及filter_link函数. 下面定义的map_link函数应用一个函数f到链表s的每个元素上同时构造一个链表来包含结果.\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; def map_link(f, s): if s is Link.empty: return s else: return Link(f(s.first), map_link(f, s.rest)) \u0026gt;\u0026gt;\u0026gt; map_link(square, s) Link(9, Link(16, Link(25)))   filter_link函数返回一个包含所有链表s中经f函数处理并返回真值的元素的链表. map_link以及filter_link的组合可以表达与列表表达式相同的逻辑.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026gt;\u0026gt;\u0026gt; def filter_link(f, s): if s is Link.empty: return s else: filtered = filter_link(f, s.rest) if f(s.first): return Link(s.first, filtered) else: return filtered \u0026gt;\u0026gt;\u0026gt; odd = lambda x: x % 2 == 1 \u0026gt;\u0026gt;\u0026gt; map_link(square, filter_link(odd, s)) Link(9, Link(25)) \u0026gt;\u0026gt;\u0026gt; [square(x) for x in [3, 4, 5] if odd(x)] [9, 25]   join_link函数递归构造一个字符串, 它包含链表元素并以某些separator字符串来分隔开. 结果比link_expression的输出更加紧凑.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; def join_link(s, separator): if s is Link.empty: return \u0026#34;\u0026#34; elif s.rest is Link.empty: return str(s.first) else: return str(s.first) + separator + join_link(s.rest, separator) \u0026gt;\u0026gt;\u0026gt; join_link(s, \u0026#34;, \u0026#34;) \u0026#39;3, 4, 5\u0026#39;   递归构造. 当需要递增地构造序列的时候链表尤其有用. 这在递归计算中经常会出现这种情况.\n第一章的count_partitions函数通过树递归过程统计用最大递增到m的整数来划分整数n的方法的总数. 使用序列, 我们也可以用类似的过程来显式地枚举这些区间.\n我们按照与计数时相同的逻辑来递归分析这些问题: 使用最大递增为m的整数划分整数n涉及下面两者之一:\n 区间n-m使用最大递增到m的整数, 或者 区间n使用最大递增到m-1的整数  对于最基本的情况, 我们发现0具有空的划分, 当划分一个负整数或者使用小于1的部分是不可能的.\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; def partitions(n, m): \u0026#34;\u0026#34;\u0026#34;Return a linked list of partitions of n using parts of up to m. Each partition is represented as a linked list. \u0026#34;\u0026#34;\u0026#34; if n == 0: return Link(Link.empty) # A list containing the empty partition elif n \u0026lt; 0 or m == 0: return Link.empty else: using_m = partitions(n-m, m) with_m = map_link(lambda s: Link(m, s), using_m) without_m = partitions(n, m-1) return with_m + without_m   在递归的情况下, 我们构造了两个分区子列表. 第一个使用m, 同时我们添加m到来自于with_m的结果using_m的每一个元素中.\npartitions的结果是高度嵌套的: 链表的链表. 通过用恰当的分割符来使用join_link, 我们可以以人类可读的方式来显示分区.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026gt;\u0026gt;\u0026gt; def print_partitions(n, m): lists = partitions(n, m) strings = map_link(lambda s: join_link(s, \u0026#34; + \u0026#34;), lists) print(join_link(strings, \u0026#34;\\n\u0026#34;)) \u0026gt;\u0026gt;\u0026gt; print_partitions(6, 4) 4 + 2 4 + 1 + 1 3 + 3 3 + 2 + 1 3 + 1 + 1 + 1 2 + 2 + 2 2 + 2 + 1 + 1 2 + 1 + 1 + 1 + 1 1 + 1 + 1 + 1 + 1 + 1   2.9.2 树类 树也可以用用户定义的类来表示, 而不是嵌套內建的序列类型的实例. 一棵树可以是任何的数据类型, 它具有一个同样也是树的属性来作为的分支.\n内部值. 之前, 我们以这样的方式来定义树, 那就是所有值都出现在树的叶子节点中. 这也是通常用来定义每个子树的根节点具有内部值的树的常见方法. 一个内部值在树内被称为entry. 下面的Tree类展示了这样的一棵树, 其中每棵树具有一个序列分支, 这个分支同样也是树.\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; class Tree: def __init__(self, entry, branches=()): self.entry = entry for branch in branches: assert isinstance(branch, Tree) self.branches = branches def __repr__(self): if self.branches: return \u0026#39;Tree({0}, {1})\u0026#39;.format(self.entry, repr(self.branches)) else: return \u0026#39;Tree({0})\u0026#39;.format(repr(self.entry)) def is_leaf(self): return not self.branches   树类可以进行表示, 例如, 在表达式树中表达fib这个计算斐波那契数的函数递归实现的计算值, 下面的fib_tree(n)函数返回一个Tree, 这个值具有第n个斐波那契数作为它的entry属性的值以及在其分支内保持一个对先前所有计算的斐波那契数的跟踪.\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; def fib_tree(n): if n == 1: return Tree(0) elif n == 2: return Tree(1) else: left = fib_tree(n - 2) right = fib_tree(n - 1) return Tree(left.entry + right.entry, (left, right)) \u0026gt;\u0026gt;\u0026gt; fib_tree(5) Tree(3, (Tree(1, (Tree(0), Tree(1))), Tree(2, (Tree(1), Tree(1, (Tree(0), Tree(1)))))))   以这种方式表示的树也是用递归函数来处理的. 例如, 我们可以合计树的条目. 最基本的情况, 我们会返回一个空的没有条目的分支.\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; def sum_entries(t): \u0026#34;\u0026#34;\u0026#34;Sum the entries of a Tree instance, which may be None.\u0026#34;\u0026#34;\u0026#34; return t.entry + sum([sum_entries(b) for b in t.branches]) \u0026gt;\u0026gt;\u0026gt; sum_entries(fib_tree(5)) 10   我们也可以应用memo来构造一个斐波那契树, 这个树中重复的子树只会通过记忆化版本的fib_tree创建一遍, 但是会被不同的更大的树多次使用.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; fib_tree = memo(fib_tree) \u0026gt;\u0026gt;\u0026gt; big_fib_tree = fib_tree(35) \u0026gt;\u0026gt;\u0026gt; big_fib_tree.entry 5702887 \u0026gt;\u0026gt;\u0026gt; big_fib_tree.branches[0] is big_fib_tree.branches[1].branches[1] True \u0026gt;\u0026gt;\u0026gt; sum_entries = memo(sum_entries) \u0026gt;\u0026gt;\u0026gt; sum_entries(big_fib_tree) 142587180   在这些情况下, 通过记忆保存的计算时间和存储器的量是相当大的. 不是创建18,454,929个Tree类型的实例, 我们现在只需要创建35个.\n2.9.3 集合 除了列表, 元组以及字典, Python还有第四种內建容器类型叫做set(集合). 集合字面量遵循的数学符号是用大括号包裹元素. 重复的元素将会在构造时被移除. 集合是一个无序集, 因此打印出来的顺序可能与集合字面量中设置的顺序不同.\n1 2 3  \u0026gt;\u0026gt;\u0026gt; s = {3, 2, 1, 4, 4} \u0026gt;\u0026gt;\u0026gt; s {1, 2, 3, 4}   Python集合支持各种操作, 包括成员测试, 长度计算, 以及取交集和并集这样的标准集合操作.\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; 3 in s True \u0026gt;\u0026gt;\u0026gt; len(s) 4 \u0026gt;\u0026gt;\u0026gt; s.union({1, 5}) {1, 2, 3, 4, 5} \u0026gt;\u0026gt;\u0026gt; s.intersection({6, 5, 4, 3}) {3, 4}   除了并集以及交集, Python集合还支持几个其他的方法. 断言isdisjoint, issubset以及issuperset提供集合比较(能力). 集合是可变的, 可以通过add, remove以及pop一次修改一个元素. 其余的方法提供多元素改动, 例如clear以及update. 在课程讲述的这个点上, Python的集合文档应该足够用来理解并填充细节了.\n实现集合. 抽象地, 一个集合是一个不同对象的集, 它支持成员测试, 并集, 交集, 以及附加. 附加一个元素同时集合会返回一个新的集合, 这个新集合包含所有的原来集合的元素以及新的元素, 前提是这些新的元素不同于原来集合的元素的话. 并集和交集返回一个集合包含的元素是分别出现在任一集合或者两个集合都出现的元素. 与任何数据抽象一样, 我们可以自由地在任意集合的表示之上实现任何函数来提供这个集合的行为.\n在这一节剩下的内容当中, 我们考虑三种不同的方法来实现一个集合的不同的表现形式. 我们会通过分析集合操作增长的顺序来描述这些不同表示的效率. 我们会使用到来自于本章前面部分的Link以及Tree类型, 这些类型允许实现简单而且优雅的递归解决方案用于初级的集合操作.\n集合作为无序序列. 一种表示集合的方式是作为一个没有元素出现多于一次的序列. 空集合是通过空序列表示. 成员测试则是以递归的方式遍历列表.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026gt;\u0026gt;\u0026gt; def empty(s): return s is Link.empty \u0026gt;\u0026gt;\u0026gt; def set_contains(s, v): \u0026#34;\u0026#34;\u0026#34;Return True if and only if set a constains v.\u0026#34;\u0026#34;\u0026#34; if empty(s): return False elif s.first == v: return True else: return set_contains(s.rest, v) \u0026gt;\u0026gt;\u0026gt; s = Link(4, Link(1, Link(5))) \u0026gt;\u0026gt;\u0026gt; set_contains(s, 2) False \u0026gt;\u0026gt;\u0026gt; set_contains(s, 5) True   这个set_contains的实现平均需要$\\Theta(n)$的时间来测试成员是否包含元素, 这里的n是指集合s的大小. 对包含的成员使用这个线性时间的函数, 我们可以连接一个元素到集合中, 这个操作也是线性的.\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; def adjoin_set(s, v): \u0026#34;\u0026#34;\u0026#34;Return a set containing all elements of s and element v.\u0026#34;\u0026#34;\u0026#34; if set_contains(s, v): return s else: return Link(v, s) \u0026gt;\u0026gt;\u0026gt; t = adjoin_set(s, 2) \u0026gt;\u0026gt;\u0026gt; t Link(2, Link(4, Link(1, Link(5))))   在设计表示时, 一个我们需要考虑到的问题是效率. 对两个集合set1以及set2进行取交集也需要用到成员测试, 但是这一次, 每一个在set1中的元素必须在set2中进行成员测试, 这导致指令的增长为步数的二次方, $\\Theta(n^2)$, n是两个集合的大小.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; def intersect_set(set1, set2): \u0026#34;\u0026#34;\u0026#34;Return a set containing all elements common to set1 and set2.\u0026#34;\u0026#34;\u0026#34; return keep_if_link(set1, lambda v: set_contains(set2, v)) \u0026gt;\u0026gt;\u0026gt; intersect_set(t, apply_to_all_link(s, square)) Link(4, Link(1))   当计算两个集合的并集, 我们必须要小心不要去包含任何元素两次. union_set函数也需要线性次数的隶属测试, 创建一个过程也包含$\\Theta(n^2)$个步骤.\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; def union_set(set1, set2): \u0026#34;\u0026#34;\u0026#34;Return a set containing all elements either in set1 or set2.\u0026#34;\u0026#34;\u0026#34; set1_not_set2 = keep_if_link(set1, lambda v: not set_contains(set2, v)) return extend_link(set1_not_set2, set2) \u0026gt;\u0026gt;\u0026gt; union_set(t, s) Link(2, Link(4, Link(1, Link(5))))   集合作为有序序列. 一个提高我们集合操作的方式是修改表示以便让集合元素以递增的顺序列出. 要做到这个, 我们需要一些方法来比较两个对象以便于让我们可以说出那个更大. 在Python, 很多不同类型的对象可以用\u0026lt;以及\u0026gt;来进行比较, 但是在这个例子中我们会集中在数字上. 我们会通过递增的方式来列出它的元素来通过一个数字表示一个集合.\n按顺序的一个好处出现在set_contains里面: 在检查一个对象是否出现上, 我们不用再去扫描整个集合. 如果我们拿到一个集合的元素, 它大于我们需要的元素, 那么我们就知道元素不在这个集合中:\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; def set_contains(s, v): if empty(s) or s.first \u0026gt; v: return False elif s.first == v: return True else: return set_contains(s.rest, v) \u0026gt;\u0026gt;\u0026gt; u = Link(1, Link(4, Link(5))) \u0026gt;\u0026gt;\u0026gt; set_contains(u, 0) False \u0026gt;\u0026gt;\u0026gt; set_contains(u, 4) True   这样的做法节省了多少步骤呢? 在最糟糕的情况下, 我们查找的项可能是在集合中最大的那项, 因此步骤数跟无序表示方式用的步骤数一样. 另一方面, 如果我们查找的项有很多不同的大小我们可以预期有时我们能够在列表的开始之初就停止搜索, 而其他时间我们还是需要检查列表的大部分. 平均来说, 我们可以预期需要检查结合中的半数. 因此, 平均需要的步数会近乎$\\frac{n}{2}$. 这依然是$\\Theta(n)$级增长, 但是它在实践中比以前的实现节省了我们一些时间.\n我们可以通过重新实现intersect_set来取得更好的速度上的提升. 在无序表示中, 这个操作需要$\\Theta(n^2)$个步骤, 因为我们的实现是为set1的每个元素来对set2进行完全扫描. 但是在有序表示中, 我们可以用一个更加聪明的办法. 我们同时迭代两个集合, 跟踪在set1中的元素e1以及set2中的元素e2. 当e1和e2相等时, 我们将这个元素囊括在交集中.\n然而假设, e1比e2小. 因为e2比set2中的剩下的元素都要小, 我们可以立马得出结论e1不可能出现在set2中剩余的任何元素中, 因此, 它就不会在交集中出现. 由此, 我们就不需要再考虑e1; 我们丢弃它并开始处理下一个set1的元素. 也可以用相似的逻辑来处理set2当e2 \u0026lt; e1时. 这里是函数实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; def intersect_set(set1, set2): if empty(set1) or empty(set2): return Link.empty else: e1, e2 = set1.first, set2.first if e1 == e2: return Link(e1, intersect_set(set1.rest, set2.rest)) elif e1 \u0026lt; e2: return intersect_set(set1.rest, set2) elif e2 \u0026lt; e1: return intersect_set(set1, set2.rest) \u0026gt;\u0026gt;\u0026gt; intersect_set(s, s.rest) Link(4, Link(5))   去预估这个过程所需的步骤, 可以观察到在每一步中我们至少缩小集合一个元素的大小. 因此, 需要的步数最多就是set1以及set2加起来的总和, 而不是像无序表示那样结果为两个集合大小的乘积. 这是$\\Theta(n)$的增长速度而不是$\\Theta(n^2)$的增长速度, 甚至对中等大小的集合而言, 这也是一个可观的速度提升. 例如, 取两个大小为100的集合的交集会需要200步, 而不是无序表示的10,000步.\n以有序序列表示的集合的连接和联合也可以用线性时间计算出来. 这些实现就留作练习用.\n以搜索树表示的集合. 我们比有序表示做得更好, 通过排列集合元素形成一个只具有两个分支的树中. 树的根节点entry持有一个集合的元素. 这个条目中左边的分支内包含所有小于根节点的元素. 右边的分支包含所有大于在根节点的元素. 下面的图像展示了一些树用来表示结合{1, 3, 5, 7, 9, 11}. 相同的集合可能会通过树以多种不同的方式来表示. 在所有的二叉搜索树中, 所有在左边的元素必须小于根节点的条目, 而所有在右边的子树必须比根节点条目大.\n树表示的好处有这些: 假设我们想要检查一个值v是否包含在集合中, 我们通过比较v与进入点entry开始. 如果v是比它小的话, 我们就知道我们只需要搜索左边的子树; 如果v是比它大的话, 我们只需要搜索右边的子树. 现在, 如果这个树是\u0026quot;均衡的\u0026rdquo;, 每一个这些子树会大约是原始尺寸的一半. 那么, 在一个步骤中, 我们就已经将搜索大小为n的树的问题减少为搜索大小为$\\frac{n}{2}$的问题. 因此树的大小在每一步都缩减一半, 我们应该可以遇见需要去搜索树的步骤数增长为$\\Theta(\\log n)$. 对于大型的集合, 这将会比前面的表示有更加显著的加速. 这个set_contains函数采用树结构集的排序结构.\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; def set_contains(s, v): if s is None: return False elif s.entry == v: return True elif s.entry \u0026lt; v: return set_contains(s.right, v) elif s.entry \u0026gt; v: return set_contains(s.left, v)   链接一个项到集合中的实现也是类似的, 同时它需要的步数也是$\\Theta(\\log n)$. 去链接一个值v, 我们将v与entry进行比较来判断v是否应该添加到左边或者右边的分支上, 以及链接v到恰当的分支后, 我们将这些新的构造分支跟原始的entry项以及其他分支拼凑在一起. 如果v等于入口entry项, 我们就只是返回节点就可以了. 如果我们被要求链接v到一个空的树, 我们就构造一个具有v并以其作为entry入口的左右分支为空的Tree. 这里是它的函数实现:\n1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; def adjoin_set(s, v): if s is None: return Tree(v) elif s.entry == v: return s elif s.entry \u0026lt; v: return Tree(s.entry, s.left, adjoin_set(s.right, v)) elif s.entry \u0026gt; v: return Tree(s.entry, adjoin_set(s.left, v), s.right) \u0026gt;\u0026gt;\u0026gt; adjoin_set(adjoin_set(adjoin_set(None, 2), 3), 1) Tree(2, Tree(1), Tree(3))   我们声称搜索这些树可以以对数的步骤数来执行是基于树是\u0026quot;均衡的\u0026quot;这一个假设, 即每棵树的左以及右子树具有大约相同的数量的元素, 因此每棵子树包含有它的父级的一半的元素. 但是现在我们可以确定我们构造的树会是均衡的吗? 即使我们由一个均衡的子树开始, 通过adjoin_set添加元素后也可能会产出一个不均衡的结果. 因为新链接的元素的位置取决于元素是如何与已经存在集合中的项目进行比较, 我们可以预期如果我们添加元素是\u0026quot;随机的\u0026rdquo;, 那么平均来说, 树会趋于均衡.\n但并不能够保证一定是这样的. 例如, 如果我们开始于一个空的集合, 然后按顺序链接1到7到集合中, 我们最终会得到一个高度不均衡的树, 它的所有左子树都是空的, 因此它相比于简单的顺序列表没有任何优势, 一个解决办法是去定义一个操作来转换一个任意的树为具有相同的元素的一个平衡树. 我们可以在每几个adjoin_set操作之后执行这个转换来保持集合的平衡.\n交集和并集操作可以以线性时间在树结构的集合上执行, 通过转换它们为有序列表然后转换回来. 细节实现就留作练习.\nPython集合实现. set类型是內建在Python中且没有在内部使用任何这些表示. 相反地, Python使用一个表示, 查找以及链接操作只需要恒定时间执行, 其实现基于一个被称为_哈希_的技术, 而这是另外的一个课程的主题. 內建Python集合不能包含可变数据类型, 例如, 列表, 字典, 或者其他集合. 为了允许集合嵌套, Python也包含了一个內建的不可变frozenset类, 它共享set类型的方法, 除了可变方法以及操作.\n","description":"","id":5,"section":"posts","tags":["译文","Design Programs"],"title":"程序构成-第二章","uri":"https://jmwill.github.io/blog/2017/06/11/%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"content":"第一章：用函数构筑抽象 1.1 开始 计算机科学是极为广泛的科学。涉及的领域有全球的分布式系统，人工智能，机器人，图形学，安全，科学计算，计算机体系结构以及每年发掘的大量新兴的子领域对新技术的相关拓展。计算机科学的快速发展使得人类生活中的各个方面都收到影响。商业，通讯，科学，艺术，休闲，以及政治都在计算机领域被重新发明了。\n只有计算机科学能够有这么高的生产率，因为这个学科是建立在一套优雅以及强大的基本思想上的。所有的计算都开始于表达信息，制定处理逻辑，以及设计抽象来管理复杂的逻辑。要掌握这些原理要求我们明白恰恰就是计算机是如何翻译计算机程序以及完成计算过程。\n这些基本思想长期用SICP（Structure and Interpretation of Computer Programs）这本Harold Abelson以及Gerald Jay Sussman和Julie Sussman所写的教科书来教授，本书大量借用了这本教科书，原书作者允许我们在共享创作的许可协议下进行改编以及重用。这些笔记遵循知识共享署名非商业性类似共享许可证第三版\n第一到三节讲的都是python的基本组成要素：\n 1.1 安装开发环境 1.2 编程要素，表达式、库的引入等 1.3 定义函数  因此，在1.4节，设计函数这里开始翻译，用于自己边翻译边理解\n1.4设计函数 函数是所有程序语言无论其大小的必要组成部分，并作为我们的主要媒介在程序设计语言中表达计算过程。至今为止，我们已经讨论了函数的形式属性以及它们是如何应用的。现在我们将标题转向如何写一个好的函数。基本地，一个好的程序的质量全在于加强函数是抽象这个概念。\n 每一个程序都应该只有负责一个工作，这个工作有一个可识别的短名称以及可以用单行文字来进行表征。一个按顺序执行多项工作的函数应该被拆分到多个函数里面去。 “不要重复你自己”是软件工程的中心宗旨。简称DRY原则，说的是多个代码片段不应该描述冗余的代码逻辑。相反，逻辑应该只实现一次，给出一个名称，并被多次调用。如果你发现自己复制并粘贴一个代码块，你可能找到了一个进行函数抽象的契机。 函数的定义应该具有一般性。平方这个方法恰恰不在Python函数库中，因为这是pow函数（可以将数字提升为任意次幂的函数）的特殊形式。  这些指南提升了代码的可读性，减少错误的数量，通常减少代码编写的总量。分解复杂任务到简洁的函数中是一项需要经验才能掌握的技能。幸运的是，Python提供了几样特性来支持你的努力。\n1.4.1 文档 一个函数定义通常会在函数内包含文档定义，叫做docstring，必须要有与函数体一样的缩进。Docstrings通常是用三重引号来包含内容，第一行是用于描述函数的作用。接下来的行用于描述参数以及阐明函数的行为：\n\u0026gt;\u0026gt;\u0026gt; def pressure(v, t, n): \u0026quot;\u0026quot;\u0026quot;Compute the pressure in pascals of an ideal gas. Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law v -- volume of gas, in cubic meters t -- absolute temperature in degrees kelvin n -- particles of gas \u0026quot;\u0026quot;\u0026quot; k = 1.38e-23 # Boltzmann's constant return n * k * t / v 当你用一个名字作为参数来调用help函数时，你会看到它的docstring（点击q来退出Python帮助）\nhelp(pressure)\n当编写Python程序的时候，除了最简单的函数外，都要包含有docstring。要记住，代码只是编写一次，但是常被多次阅读。Python的文档有包含docstring的指南用于在不同项目之间保持一致性。\n注释 。Python中的注释能够附加到任意行的结尾上，跟在#符号的后面。例如，上面的k的评论是用于描述玻尔兹曼常数。这些评论是不会出现在Python的help函数中的，同时也会被解释器忽略掉。它们只为了人而存在。\n1.4.2 定义一般函数的结果是会引入额外的参数。一个函数如果有很多个参数的话在调用时会很尴尬而且也很难阅读。\n在Python，我们能够为函数的参数提供默认的值。当调用函数时，具有默认值的参数是可选的。如果（调用函数时）没有被提供，参数的默认值会绑定到形式参数的名字上。例如，如果一个应用通常都是计算一摩尔的粒子的压力，这个值可以作为默认值来提供：\n\u0026gt;\u0026gt;\u0026gt; def pressure(v, t, n=6.022e23): \u0026quot;\u0026quot;\u0026quot;Compute the pressure in pascals of an ideal gas. v -- volume of gas, in cubic meters t -- absolute temperature in degrees kelvin n -- particles of gas (default: one mole) \u0026quot;\u0026quot;\u0026quot; k = 1.38e-23 # Boltzmann's constant return n * k * t / v 在这个例子中=符号意味着两种不同的东西，取决于使用它的上下文。在def声明语句头，=号并不执行分配而是表示pressure被调用时当做一个默认的值来用。相比之下，函数体中的k的分配声明将名字k与玻尔兹曼常数的近似值进行绑定。\n\u0026gt;\u0026gt;\u0026gt; pressure(1, 273.15) 2269.974834 \u0026gt;\u0026gt;\u0026gt; pressure(1, 273.15, 3 * 6.022e23) 6809.924502 pressure函数定义为需要三个参数，但在上面第一个调用等式中只提供了两个参数值。在这种情况下，值n取自def声明的默认值。如果第三个参数被提供，默认值就会被忽略。\n作为指导，大多数在函数体中用到的数据的值都应该表示为命名参数的默认值，使得它们易于被检查同时能被函数的调用者改变。一些永远不会改变的值，例如基本常数k，可以绑定到函数体或者全局内。\n1.5 控制流 第五节用于描述控制流，if-elif-else以及一些测试相关的知识，属于基础知识，不翻译。\n1.6 高阶函数 我们已经知道函数是一种抽象方法，用于描述与它们的参数的特定值无关的复合操作。也就是说，像square函数：\n1 2  \u0026gt;\u0026gt;\u0026gt; def square(x): return x * x   我们并没有讨论某个特定值的平方，而是讨论关于获得所有数字的平方的方法。当然，我们可以不去定义这样的函数，而是总写下这样的表达式：\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; 3 * 3 9 \u0026gt;\u0026gt;\u0026gt; 5 * 5 25   并且从不明确提及square。这种做法对于简单的计算如square是足够了，但是对于更加复杂的例子像abs或者fib等要继续保持这样的做法就会变得很困难。一般来说，缺乏函数定义通常会使我们处于不利的地位，迫使我们总是在特定层级即语言的原语（在这个例子中是乘法）上工作，而不是在更高的层次上进行操作。即使我们的程序能够计算平方，但是我们的语言却缺乏表达平方概念的能力。\n我们对于强大编程语言的其中一个需求是它提供的通过为常见模式分配名称构建抽象然后直接通过调用名称来执行工作的能力。就像我们接下来看到的例子，这是一个在代码中重复的常见模式，但是是与许多不同的函数一起使用。这种模式也可以通过命名来进行抽象化。\n要将某些一般模式作为命名概念，我们需要构造函数让它能够接受其他函数作为其参数或者将函数作为其返回值。能够操纵函数的函数被称为高阶函数。本节将会展示高阶函数是如何能够作为强大的抽象机器从而大大增强我们的语言的表达能力的。\n1.6.1 函数作为参数 研究一下接下来的三个都是用来计算总数的函数。第一个，sum_naturals，计算n个自然数的和\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; def sum_naturals(n): total, k = 0, 1 while k \u0026lt;= n: total, k = total + k, k + 1 return total \u0026gt;\u0026gt;\u0026gt; sum_naturals(100) 5050   第二个，sum_cubes，计算n个自然数的平方和。\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; def sum_cubes(n); total, k = 0, 1 while k \u0026lt;= n: total, k = total + k * k * k, k + 1 return total \u0026gt;\u0026gt;\u0026gt; sum_cubes(100) 25502500   第三个，pi_sum，计算一系列项的总和\n其非常缓慢地收敛到pi\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; def pi_sum(n): total, k = 0, 1 while k \u0026lt;= n: total, k = total + 8 / ((4 * k - 3) * (4 * k - 1)), k + 1 return total \u0026gt;\u0026gt;\u0026gt; pi_sum(100) 3.1365926848388144   这三个函数很显然使用了一种相同的底层模式，它们的大部分都是相同的，只有函数名以及函数中计算要累加的项的k的用法不同。我们可以通过在相同的模板中填充槽来生成每一个函数。\ndef \u0026lt;name\u0026gt;(n): total, k = 0, 1 while k \u0026lt;= n: total, k = total + \u0026lt;term\u0026gt;(k), k + 1 return total 这是这种共同模式存在的强有力的证据，等待着将有用的抽象带到表面上来。这些函数每一个都是求和术语，作为一个程序设计师，我们都希望我们的语言足够强大以至于我们能够能够编写函数来表达求和的概念，而不是对特定的值进行求和。在Python中我们可以轻易地将上面展示的模板中的槽替换成形式参数：\n在下面的例子中，summation需要两个参数，上限n以及用来计算第k次值的函数term。我们能像使用其他函数一样来使用summation函数，它简洁地表现了求和（概念）。用点时间来一步步执行这个例子，注意下cube是如何绑定到局部命名term上的并保证结果111 + 222 + 333 = 36被正确计算的。在这个例子中，不需要的帧会被移除以用于节省空间。\n 使用一个可识别的函数来返回其参数，我们也能够用完全相同的summation函数来计算自然数的和。\n1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; def summation(n, term): total, k = 0, 1 while k \u0026lt;= n: total, k = total + term(k), k + 1 return total \u0026gt;\u0026gt;\u0026gt; def identity(x): return x \u0026gt;\u0026gt;\u0026gt; def sum_naturals(n): return summation(n, identity) \u0026gt;\u0026gt;\u0026gt; sum_naturals(10) 55   这个summation函数也能够直接调用，而不用对特定序列来定义另一个函数\n1 2  \u0026gt;\u0026gt;\u0026gt; summation(10, square) 385   我们可以通过定义一个pi_term函数来计算每一次的值从而用我们的summation抽象函数来定义一个pi_sum，我们输入参数1e6，是1*10^6 = 1000000的简写，来生成pi的近似值。\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; def pi_term(x): return 8 / ((4*x-3) * (4*x-1)) \u0026gt;\u0026gt;\u0026gt; def pi_sum(n): return summation(n, pi_term) \u0026gt;\u0026gt;\u0026gt; pi_sum(1e6) 3.141592153589902   1.6.2 作为一般方法的函数 我们采用用户定义函数作为抽象机制对数值运算进行抽象以让它们独立于特定的数。使用高阶函数，我们开始见识到更多抽象的力量：一些表达一般计算方法的函数，独立于它们调用的函数。\n尽管这个概念拓展于什么是函数的定义，我们的环境模型评估一个调用表达式是如何无改变地优雅地拓展到高阶函数的。当用户定义函数应用于某些参数中时，形式参数跟这些参数（可能是函数）的值在一个新的局部帧内绑定到一起。\n思考一下接下来的例子，一个应用迭代改进实现的用于计算黄金比率的通用方法。黄金比率，通常又叫做“phi”，是一个自然界、艺术、建筑学中经常出现的接近1.6的数字。\n一个迭代优化算法开始于一个猜测的方程的解。它反复地应用一个更新函数来改进这个猜测的值，然后用一个接近的值来比较检查猜测值是否足够接近被认为是正确的值。\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; def improve(update, close, guess=1): while not close(guess): guess = update(guess) return guess   这个改进函数是一个重复细化的一般表达式，它没有指定问题应该怎么解决，这些细节都通过传入参数来留给update函数以及close函数来解决。\n而总所周知的黄金比例属性是能够通过反复叠加一个任何正数加上1后的倒数来计算，而这个黄金比例属性是一个小于它平方的数字。我们可以将这些属性表达为一个用于改进的函数。\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; def golden_update(guess): return 1 / guess + 1 \u0026gt;\u0026gt;\u0026gt; def square_close_to_successor(guess): return approx_eq(guess * guess, guess + 1)   上面，我们引进了approx_eq函数调用，这函数意味着如果它的参数相互间足够约等于彼此就要返回True值。为了实现approx_eq函数，我们比较两个数之间的最小公差的绝对值。\n1 2  \u0026gt;\u0026gt;\u0026gt; def approx_eq(x, y, tolerance=1e-15): return abs(x - y) \u0026lt; tolerance   用golden_update函数以及square_close_to_successor函数作为参数来调用improve函数将能够计算一个有限近似的黄金比率。\n1 2  \u0026gt;\u0026gt;\u0026gt; improve(golden_update, square_close_to_successor) 1.6180339887498951   通过跟踪运算的每一步，我们能够看到这些结果是如何被计算出来的。首先，一个improve函数的局部环境被构造起来，并为update，close以及guess这三个参数绑定值。在improve函数体中，名为close的对象绑定了square_close_to_successor函数，用于被初始值guess来调用。继续跟踪接下来的几步来看计算黄金比率的演化计算过程。\n 这个例子演示了两个计算机科学上的大概念。第一，命名以及函数允许我们从大量的复杂性中进行抽象。虽然每一个函数的定义是微不足道的，但是我们评估程序的运行过程却是相当复杂的。第二，这是唯一的事实，我们有用于python语言的极其一般的计算步骤，就是一个小的组件能够组合成一个复杂的过程。明白程序的这个解析过程允许我们验证以及检查我们创建的过程。\n像之前一样，我们新的一般函数improve需要一个测试来验证它的准确性。黄金比率能够提供这样的测试，因为它通常是具有一个精确的闭式解决方案的，可用于与迭代值进行比较。\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; from math import sqrt \u0026gt;\u0026gt;\u0026gt; phi = 1 / 2 + sqrt(5) / 2 \u0026gt;\u0026gt;\u0026gt; def improve_test(): approx_phi = improve(golden_update, square_close_to_successor) assert approx_eq(phi, approx_phi), \u0026#39;phi differs from its approximation\u0026#39; \u0026gt;\u0026gt;\u0026gt; improve_test()   对于这个测试，没有反馈消息就证明是好的：improve_test在它的assert声明执行之后返回一个None值。\n1.6.3 定义函数 III：嵌套定义 上面的例子演示了将函数作为参数传递而显著地增强了我们的程序语言的表达力的能力。每一个一般的概念或者方程都映射到它的一个简短的函数上。这个方法的一个负面后果是全局环境会被命名以及那些唯一的小函数弄得十分凌乱。另一个问题是我们受特定函数签名的约束：update函数作为improve函数的参数只能传入一个形式参数。嵌套函数定义解决了这些问题，但是需要我们丰富我们的环境模型。\n让我们来考虑新的问题：计算一个数的平方根。在编程语言中，“square root”通常缩写为sqrt。重复应用下面的收敛函数来更新a的平方根：\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; def average(x, y): return (x + y) / 2 \u0026gt;\u0026gt;\u0026gt; def sqrt_update(x, a): return average(x, a/x)   这个需要更新两个参数的函数跟improve函数（需要两个参数，而不是一个）是不兼容的，同时它只能对一个参数进行更新，然而我们真正在意的是通过迭代更新来获得平方根。解决所有问题的办法是将函数的定义放到另一个函数定义的函数体内。\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; def sqrt(a): def sqrt_update(x): return average(x, a/x) def sqrt_close(x): return approx_eq(x * x, a) return improve(sqrt_update, sqrt_close)   就像本地赋值，本地的def语句只对当前的本地环境有影响。这些函数只适用于sqrt函数运行的范围内。跟我们求值步骤一样，这些本地的def语句直到sqrt函数被调用前都不会运行。\n词汇范围。本地定义的函数还可以在定义它们的作用域中访问命名绑定。在这个例子中，sqrt_update函数引用名称a，而a是封闭函数sqrt的一个形参。这种在嵌套函数之间分享命名的规则叫做词汇范围。关键的是，内部函数能够访问它们定义范围（而不是调用范围）环境内的名称。\n我们需要对我们的环境模型进行两个拓展从而让它们支持词汇范围。\n 每一个用户定义的函数都有一个父级环境：就是定义它时所处的环境。 当一个用户定义函数被调用时，它的本地域拓展自它的父级环境。  上一个sqrt函数，所有的函数都定义在全局环境，所以它们都有相同的父级环境：全局环境。相比之下，当Python运行sqrt的两个子句时，它创建了与本地环境关联的函数。在调用中\n1 2  \u0026gt;\u0026gt;\u0026gt; sqrt(256) 16.0   环境首先为sqrt添加局部帧以及运行sqrt_update以及sqrt_close的def声明。\n 每一个函数值都有一个新的注解就是从现在起我们会携带父级的环境图。函数值的父级是函数定义时的第一个环境作用域。没有父级注解的函数定义在全局环境。当一个用户定义函数被调用时，创建的帧拥有与函数一样的相同父级。\n随后，名为sqrt_update的新定义的函数解决了那个只能接受一个参数的improve函数的问题。在improve函数的体内，我们必须应用x为1的初始猜测值到我们的update函数（绑定到sqrt_update函数）上。这个最后的应用为sqrt_update创建了一个一开始只有一个x以及一个绑定了a的父级环境sqrt的本地帧的环境。\n 这些求值步骤最关键部分是将sqrt_update的父代传递到通过调用sqrt_update创建的帧中，这个帧也用[parent=f1]来注释。\n扩展环境。一个环境可以认为是任意长度的帧组成的一条总是包含全局帧的长链。如前面的sqrt例子所示，环境最多只有两个帧：一个本地帧，以及一个全局帧。通过调用一个会在内部用def声明来定义其他函数的函数，我们可以创建一个长链。调用sqrt_update的环境有三个帧组成：本地的sqrt_update帧，定义sqrt_update函数的sqrt帧（标记为f1），以及全局帧。\nsqrt_update函数内部的返回表达式能够通过这条帧链解析a的值。查找名称会找到当前环境中绑定到该名称的第一个值。Python首先在sqrt_update帧中进行查找\u0026ndash;没有找到a的存在。Python接下来到父级帧中查找，即f1，然后找到绑定了256的a。\n因此，我们认识到Python中的两个词汇范围的关键优点。\n 本地函数的命名不会干扰到外部定义的相同名称的函数，因为本地函数名称会绑定到它定义的当前的本地环境中，而不是全局环境。 一个本地函数能够访问封闭函数的内部环境，因为本地函数的函数体求值环境是在它被定义的求值环境中拓展出来的。  sqrt_update函数携带了一些数据：在定义a的范围中的引用值。因为它们通过这种方式“包围”信息，本地定义函数通常叫做闭包。\n1.6.4 函数作为返回值 我们能够通过在程序中创建一个返回值是自己内部创建的函数的函数来获得更多的表现力。具有词法作用域的编程语言的一个很重要的特性是本地定义的函数当它们（作为返回值）被返回的时候能够维持它们的父级环境。接下来的例子说明了这个特性的效用。\n一旦定义了很多的简单函数，函数组成了一种自然的方法组合包含在我们的编程语言里面。也就是说，给定两个函数f(x)以及g(x)，我们可能希望定义h(x)=f(g(x))。我们能够定义函数组合来使用我们现有的工具：\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; def compose1(f, g): def h(x): return f(g(x)) return h   这个例子的环境图示显示了名称f以及g是如何正确解析的，即使存在名称冲突。\n 在compose1中的1表示的意味是组合的函数全都只接受一个参数。这个命名约定并不是解析器强制要求的，这个1只是函数名的一部分而已。\n到现在，我们开始注意到我们努力定义精确环境模型的计算的效益。这种方式无需修改我们的环境模型来解释我们返回函数的能力。\n1.6.5 例子：牛顿法 这个拓展的例子展示了函数返回值以及本地定义如何能够一起工作来简洁地表达一般思路的。我们会实现一个广泛用于机器学习，科学计算，硬件设计以及优化的算法。\n牛顿法是一个经典的用于找寻返回值为0的数学函数的参数的迭代方法。这些值被称为函数的零点。找寻函数零点相当于解决一些其他有趣的问题，比如计算平方根。\n在我们继续之前先来激励一下自己：我们很容易认同这样的一个事实就是我们知道如何计算平方根。不仅仅是Python、甚至是你的电话，浏览器，或者袖珍计算器也能够为你做到这一点。然而，学习计算机科学的其中一部分就是要明白像这样的数量是如何计算出来的，以及这里所呈现超越那些Python内置方法能够计算一大类方程的一般方法。\n牛顿法是一个迭代改进算法：它对任何可区分的函数的零点的猜测值进行改进，也就意味着它能够通过利用直线来趋近任何点。牛顿法遵循这些趋近直线来找到函数的零点。\n想象一条直线穿过一个点(x, f(x))，且跟在这点上的曲线函数f(x)具有相同的坡度。这样的先叫做切线，它的坡度就叫做函数f在x上的导数。\n这条直线的坡度就是函数值跟随函数输入参数变化的比率。因此，将x转换为f(x)除以坡度会得到该切线触及0的参数值。\nnewton_update表示对于函数f以及它的导数df，该切线为0的计算过程。\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; def newton_update(f, df): def update(x): return x - f(x) / df(x) return update   最终，我们能够用我们的newton_update函数、改进算法improve以及比较看f(x)是否接近0来定义find_root函数。\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; def find_zero(f, df): def near_zero(x): return approx_eq(f(x), 0) return improve(newton_update(f, df), near_zero)   计算根。用牛顿法我们能够计算任意度n的根。a的n度根是指像x * x * x \u0026hellip; x = a中x的重复次数n。例如\n 64的平方（二次）根是8，因为8 * 8 = 64。 64的立方（三次）跟是4，因为 4 * 4 * 4 = 64。 64的六次方根是2，因为2 * 2 * 2 * 2 * 2 * 2 = 64。  通过接下来的观察我们可以用牛顿法来计算根：\n 64的平方根（√64）就是x的值为x * x - 64 = 0 更普遍地，a的n度根就是x的值为 x * x * x \u0026hellip; n个x - a = 0  如果我们能够找到最后一个问题的零点，我们就可以计算n度根。通过绘出n等于2、3以及6，a等于64的曲线，我们能够将关系可视化。\n我们通过定义f以及它的导数df首次实现square_root函数。我们用微积分中的定理：f(x) = x * x - a的导数就是线性函数df(x) = 2x。\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; def square_root_newton(a): def f(x): return x * x - a def df(x): return 2 * x return find_zero(f, df) \u0026gt;\u0026gt;\u0026gt; square_root_newton(64) 8.0   归纳来说，任意度n的根我们通过计算以及它的导数可得\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026gt;\u0026gt;\u0026gt; def power(x, n): product, k = 1, 0 while k \u0026lt; n: product, k = product * x, k + 1 return product \u0026gt;\u0026gt;\u0026gt; def nth_root_of_a(n, a): def f(x): return power(x, n) - a def df(x): return n * power(x, n - 1) return find_zero(f, df) \u0026gt;\u0026gt;\u0026gt; nth_root_of_a(2, 64) 8.0 \u0026gt;\u0026gt;\u0026gt; nth_root_of_a(3, 64) 4.0 \u0026gt;\u0026gt;\u0026gt; nth_root_of_a(6, 64) 2.0   所有的这些计算中的近似误差可以通过修改approx_eq函数中的tolerance（公差）来减少到一个更小的值。\n当你练习牛顿法的时候，需要留心它并不总是收敛。improve函数的初始猜测需要充分地接近到零点，且必须满足函数的各种条件。尽管有这些缺点，牛顿法还是一个很强大的求解可微分方程的一般计算方法。对数和大整数除法在现代计算机中采用该技术的变体是一种非常快的算法\n1.6.6 柯里化\n我们可以使用高阶函数来改造一个携带多个参数的函数为一个函数链，且函数链中的每一个函数都接受一个参数。更特别地，给定一个函数f(x, y)，我们可以定义一个函数g让g(x)(y)等于f(x, y)。这里，g是一个更高阶的函数接受一个x参数然后返回另一个函数来接受参数y。这种转型称为柯里化。\n举个例子，我们可以定义一个柯里化版本的pow函数：\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; def curried_pow(x): def h(y): return pow(x, y) return h \u0026gt;\u0026gt;\u0026gt; curried_pow(2)(3) 8   一些编程语言，如Haskell，只允许函数有一个参数，因此程序员必须要柯里化所有的多参数程序。在更一般的语言中，如Python，当我们需要一个只接受一个参数的函数时柯里化就十分有用了。例如，映射模式可以将一系列的值应用到接受单个参数的函数中。在随后的章节中我们会看到更多映射模式的一般例子，但是现在，我们可以在函数中实现这种模式;\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; def map_to_range(start, end, f): while start \u0026lt; end: print(f(start)) start = start + 1   我们可以使用map_to_range以及curried_pow来计算前十个数的平方，而不是特地写一个函数来做这些操作：\n1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; map_to_range(0, 10, curried_pow(2)) 1 2 4 8 16 32 64 128 256 512   我们可以类似地使用相同的两个函数来计算其他数字的幂。柯里化允许我们这样做而不需要为每个数编写特定的函数来计算我们想要的幂。\n在上面的例子中，我们手动执行柯里化来将pow函数转化为curried_pow函数。作为替代，我们可以定义函数来自动实现柯里化，以及逆柯里化的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026gt;\u0026gt;\u0026gt; def curry2(f): def g(x): def h(y): return f(x, y) return h return g \u0026gt;\u0026gt;\u0026gt; def uncurry2(g): def f(x, y) return g(x)(y) return f \u0026gt;\u0026gt;\u0026gt; pow_curried = curry2(pow) \u0026gt;\u0026gt;\u0026gt; pow_curried(2)(5) 32 \u0026gt;\u0026gt;\u0026gt; map_to_range(0, 10, pow_curried(2)) 1 2 4 8 16 32 64 128 256 512   curry2函数接受一个需要两个参数的函数f然后返回一个需要一个参数函数g。当用一个参数x调用g时，它返回一个需要单个参数的函数h。当用一个y调用h时，它调用f(x, y)。因此，curry2(f)(x)(y)就相当与f(x, y)。uncurry2函数逆转柯里化变换，因此uncurry2(curry2(f))就等于f。\n1 2  \u0026gt;\u0026gt;\u0026gt; uncurry2(pow_curried)(2, 5) 32   1.6.7 Lambda表达式 至今为止，每一次我们想要定义一个新的函数，我们都需要给它一个名字。但是对其他类型的表达式，我们无需给中间结果给关联一个名称。也就是说，我们能够计算a*b+c*d而不需要命名子表达式a*b或者c*d，或者整个表达式。在Python里面，我们可以用lambda表达式来计算未命名的函数从而动态地得到一个函数值。一个lambda表达式计算的函数在函数体内有单独的一个返回表达式。赋值语句以及控制语句是不被允许使用的。\n1 2  \u0026gt;\u0026gt;\u0026gt; def compose1(f, g): return lambda x: f(g(x))   我们能够通过构造一个相应的英文句子来明白lambda表达式的构造：\nlambda x : f(g(x)) \u0026quot;A function that takes x and returns f(g(x)) lambda表达式的结果叫做lambda函数。它没有固有的名称（因此Python打印\u0026lt;lambda\u0026gt;作为它的名称），但是除此之外它的行为就像其他函数一样。\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; s = lambda x: x * x \u0026gt;\u0026gt;\u0026gt; s \u0026lt;function \u0026lt;lambda\u0026gt; at 0xf3f490\u0026gt; \u0026gt;\u0026gt;\u0026gt; s(12) 144   在一个环境关系图里面，lambda表达式的结果就是一个函数，名为希腊文的 λ （lambda）。我们撰写的例子能够相当紧凑地表达lambda表达式。\n 一些程序员发现，使用来自于lambda表达式的无命名的函数会更加的短也更加直接。然而，尽管它们很简洁，复合的lambda表达式却是臭名昭著且难以辨认的。下面的定义是正确的，但是很多程序员在快速明白它的意图上会遇到困难。\n1  \u0026gt;\u0026gt;\u0026gt; compose1 = lambda f, g: lambda x: f(g(x))   一般来说，Python风格更偏向于显式的def声明而不是lambda表达式，但是允许它们存在是为了防止需要一些简单的函数作为参数或者返回值。\n这些风格规则仅仅只是指导性的，你可以以任何你想要的方式来编程。然而，当你编程的时候，想一下那些将来有一天会读你的程序的读者。当你可以让你的程序更容易明白，你就是在帮这些人一个忙。\nlambda术语是一个历史事故，来源于书面数学符号以及早期类型系统的约束的不兼容而导致的。\n It may seem perverse to use lambda to introduce a procedure/function. The notation goes back to Alonzo Church, who in the 1930\u0026rsquo;s started with a \u0026ldquo;hat\u0026rdquo; symbol; he wrote the square function as \u0026ldquo;ŷ . y × y\u0026rdquo;. But frustrated typographers moved the hat to the left of the parameter and changed it to a capital lambda: \u0026ldquo;Λy . y × y\u0026rdquo;; from there the capital lambda was changed to lowercase, and now we see \u0026ldquo;λy . y × y\u0026rdquo; in math books and (lambda (y) (* y y)) in Lisp.\n—Peter Norvig (norvig.com/lispy2.html)\n 尽管有这个不同寻常的词源，lambda表达式以及相应的函数应用的形式语言，lambda演算，是基本的计算机科学概念并广泛在Python编程社区中共享。当我们在第三章学习设计一个编译器时，我们会再次回顾这一个主题。\n1.6.8 抽象以及第一类函数 我们这一节开始观察用户定义函数这个关键的抽象机制，因为它们允许我们在我们的编程语言中用显式的元素来表达一般的计算方法。现在，我们已经见识过高阶函数是如何允许我们来操作这些一般方法以创建进一步的抽象的。\n作为一个程序员，我们应该警惕并识别定义我们程序的底层抽象的机会，建立在它们之上，然后归纳它们来构建更加强大的抽象。这并不是说应该总是以最抽象的方式来编写程序；高级的程序员知道如何选择适合他们当前任务的抽象等级。但能够从抽象的角度来想这些问题是很重要的，以便我们可以准备将它们应用到新的上下文当中去。高级函数的意义在于它们允许我们来表示这些抽象概念，特别是作为我们编程语言里的一个元素来使用，以便它们能够处理像出来其他计算元素一样来进行处理。\n一般来说，编程语言会对可以操纵的计算元素的方式施加限制。进行最小的限制的元素被称为第一类元素。第一类元素的“权利与特权”如下：\n 它们可能会绑定到一个名称上 它们可能会作为函数的参数来传递 它们可能作为函数的结果来返回 它们可能包括在数据结构当中  Python授予函数充分的第一类元素的所有状态，得到的结果就是巨大的表现力。\n1.6.9 函数装饰器 Python提供特殊的语法来以应用高阶函数作为def声明的一部分来使用，这叫做装饰器。可能最常见的例子就是追踪函数了：\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; def trace(fn): def wrapped(x): print(\u0026#39;-\u0026gt;\u0026#39;, fn, \u0026#39;(\u0026#39;, x, \u0026#39;)\u0026#39;) return fn(x) return wrapped \u0026gt;\u0026gt;\u0026gt; @trace def triple(x): return 3 * x \u0026gt;\u0026gt;\u0026gt; triple(12) -\u0026gt; \u0026lt;function triple at 0x102a39848\u0026gt; ( 12 ) 36   在这个例子中，已经定义了一个高阶函数trace，它返回一个函数，这个函数在对其参数进行调用之前会先执行print语句来输出参数值。triple的def声明有一个备注：@trace，这个备注会影响def的执行规则。一般来说，函数triple已经创建好了，然而，名称triple并不是绑定到这个函数上，而是triple这个名称被绑定到trace调用时返回的新定义的triple函数上。在代码中，这个装饰器相当于：\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; def triple(x): return 3 * x \u0026gt;\u0026gt;\u0026gt; triple = trace(triple)   在与本文相关的项目中，装饰器用于跟踪，以及从命令行运行程序时选择要调用的函数。\n给专家的额外资料。这个装饰器的符号@通常通常在后面会跟一个表达式。这个跟在后面的表达式已经先被运行了，（就像上面运行的名为trace的表达式），第二个def表达式以及最终运行装饰器表达式的结果会应用到最新定义的函数上，而最终结果会绑定到def声明的名称上。一个Ariel Ortiz写的剪短的装饰器教程给有兴趣的同学。\n1.7 递归函数 一个函数如果它自己的函数体调用函数本身就称作递归函数，不管是直接的或者间接的。也就是说递归函数函数体的执行过程中可能会反过来需要再次调用这个函数。在Python中的递归函数并不需要用到特殊的语法，但它们确实需要做出一些努力才能明白并创建。\n我们从一个示例问题来开始：编写一个函数用来计算一个自然数的所有位数的数字之和。当设计递归函数时，我们需要寻找将遇到的问题分解成更简单的问题的方法。在这个例子中，操作符号$以及//可以用来将数字分成两部分：它最后的一个数以及除了最后一个数的所有数字。\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; 18117 % 7 7 \u0026gt;\u0026gt;\u0026gt; 18117 // 10 1811   数字18117的各位数之和是1+8+1+1+7 = 18。正如我们可以将数字分解，我们可以将数字分解成最后的一个数字7，以及除最后的一个数字以外的所有数字，1+8+1+1 = 11。这种拆分提供了一种算法来一个数n的所有位数数字之和，将它的最后一位数n % 10加上剩余的数字n // 10。这是一个特殊的例子，如果一个数字只有一个数，那么这个数各位数字的和就是它自己。这个算法可以实现为一个递归函数。\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; def sum_digits(n): if n \u0026lt; 10: return n else: all_but_last, last = n // 10, n % 10 return sum_digits(all_but_last) + last   sum_digits的定义是完备且正确的，即使这个sum_digits函数在它自己的函数体内被调用。计算位数之和的问题被分解成两步：计算除了最后一个数字以外的各位数字之和，然后加上最后一位数字。这些步骤都比原问题更加简单。这是一个递归函数，因为第一步跟原问题的第一步一样。也就是说，sum_digits就是我们要实现sum_digits所需要的函数:\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; sum_digits(9) 9 \u0026gt;\u0026gt;\u0026gt; sum_digits(18117) 18 \u0026gt;\u0026gt;\u0026gt; sum_digits(9437184) 36 \u0026gt;\u0026gt;\u0026gt; sum_digits(11408855402054064613470328848384) 126   我们可以通过环境计算模型来恰当地理解递归函数是怎么成功运行的。无需任何新的规则。\n 当执行def声明，名称sum_digits绑定到了新的函数当中，但是函数体还没有执行。因此，sum_digits的循环特性还不是一个问题。然后，用738sum_digits来调用sum_digits：\n 一个n被绑定为738的sum_digits函数的本地帧被创建了，然后sum_digits的函数体开始在这个本地帧的环境中进行调用。 由于738不小于10，因此第四行的赋值语句被执行，将738分解成73和8。 在接下来的返回语句中，sum_digits被当前环境中的all_but_last值73调用 另一个sum_digits的本地帧被创建，这一次n绑定的是73，sum_digits的函数体再一次执行在这个帧中的新环境中。 由于73并不小于10，73分解成7和3，然后sum_digits用这个帧中的all_bug_last的值7来进行调用。 第三个n绑定为7的sum_digits的本地帧被创建 开始于这个环境的帧，n \u0026lt; 10的是正确的，因此，7被返回。 在第二个本地帧里面，这个返回值7与3这个last值进行相加，然后返回10。 在第一个本地帧里面，返回值10与8这个last值相加，然后返回18  这个递归函数的应用是正确的，尽管它具有环形调用的特征，因为它的两次调用中每一次都用不同的参数值来进行调用。此外，第二次调用是比第一次更简单的数字求和问题。从生成的调用sum_digits(18117)的环境图例来看，每一个连续的调用sum_digits都会得到比前一个更小的参数值，直到达到最终的单位数的输入。\n这个例子也说明了一个具有简单函数体的函数是如何通过递归来解决复杂问题的。\n1.7.1 剖析递归函数 在许多递归函数的函数体内都能够找到一种常见的模式。函数体开始于一个基础情况，一个条件语句定义了函数对于输入的最简单的处理行为。如果是sum_digits，基础情况就是任何单个的数字参数，我们简单地返回这个参数，一些递归函数会有多个基本情况\n基础情况之后会跟随一个或者多个递归调用。递归调用总是会具有某些特性：它们会简化原问题。递归函数通过逐步简化问题来表达计算行为。例如，求数字7的和比求数字73的和要简单，而后者又比求数字738的和要简单，随后的每一次调用都比前前一次需要做更少的工作，递归函数通常用不同的方式来解决我们之前用迭代方式来解决的问题。考虑下用函数fact来计算n的阶乘，如例子fact(4)的计算为4! = 4 * 3 * 2 * 1 = 24。\n一个正常的实现是用while语句累计直到n的每一个正整数的总的乘积。\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; def fact_iter(n): total, k = 1, 1 while k \u0026lt;= n: total, k = total * k, k + 1 return total \u0026gt;\u0026gt;\u0026gt; fact_iter(4) 24   另一方面，递归实现阶乘可以表达fact(n)为fact(n-1)，一个更简单的问题。递归的基础情况是问题的最简单形式：fact(1)是1。\n 这两个递归函数在概念上是不同的。迭代函数从最简单的基础情况1开始依次乘上每一个数来构造结果。另一方面，递归函数直接从最后一个数n以及更简单的问题fact(n-1)的结果来构造结果。\n随着递归函数连续应用fact函数来逐步展开问题为越来越简单的实例，结果最终从最简单的情况开始构建。递归结束于传入参数1到fact函数中，每一次调用的结果都依赖于下一次调用，直到达到基础情况。\n这个递归函数的正确性很容易从阶乘的数学函数的标准定义上来进行验证的：\n当我们能够用我们的计算模型进行递归展开的时候，这通常就能够很清晰地将递归调用作为函数抽象来思考了。也就是说，我们不应该关心fact(n-1)是如何在fact的函数体内实现的；我们应该相信它能够计算n-1的阶乘，将递归调用当做函数抽象来对待已经可以认为是一种_递归信念的飞跃_。我们用一个函数本身来定义了一个函数，但在验证它的正确性时，仅仅需要相信最简单的情况下会正确工作。在这个例子中，我们相信fact(n-1)会正确计算(n-1)!；如果这个假设是正确的我们只需检查n!的计算是正确的。通过这种方式，检查递归函数的正确性就是证明一种形式的归纳。\n函数_fact_iter_以及_fact_函数也是不同的，因为前者必须添加两个名字，total以及k，这在递归函数的实现中是不必要的。一般来说，迭代函数，在计算的过程中必须维持一些计算过程中的本地变量。在迭代的任何一个点上，这些状态表示已完成工作的结果和剩余工作量。例如，当k是3以及总数是2时，这时还剩余两项需要处理，就是3和4。另一方面，_fact_的特征在于它的单个参数n。整个计算的状态包含在环境的结构中，也就是起到作用的total值，以及在不同的帧内绑定n到不同的值而不是明确的k的踪迹。\n回调函数利用调用表达式来求值的规则为名称绑定一个值，通常避免在迭代期间正确地分配本地名称的烦扰。出于这个原因，递归函数能够更容易正确地定义。然而，学习识别递归函数演化的计算过程当然少不了实践。\n1.7.2 相互递归 当一个递归过程分为两个相互调用彼此的函数时，这个函数就被叫做相互递归。举个例子，想象一下下面的非负整数的奇数和偶数的定义：\n 一个数是偶数如果它比一个奇数多一 一个数是奇数如果它比一个偶数多一 0是偶数  用这个定义，我们可以实现相互递归函数来确定一个数是奇数还是偶数：\n 相互递归函数能够通过打破两个函数之间的抽象边界来变成单递归函数。在这个例子中，is_odd的函数体能够合并到is_even中，确保将is_odd中的n改成n-1，来体现传入参数这个动作。\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; def is_even(n): if n == 0: return True else: if (n - 1) == 0: return False else: return is_even((n - 1) - 1)   因此，相互递归并没有比简单递归有更多的神秘与强大，只不过它提供了一种在复杂的递归程序中维护抽象的机制而已。\n1.7.3 在递归函数中打印 由递归函数演化的计算过程通常可以通过调用print来进行可视化。举个例子，我们会执行一个函数cascade来打印一个数的前面几个数，从最大到最小再到最大。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; def cascade(n): if n \u0026lt; 10: print(n) else: print(n) cascade(n // 10) print(n) \u0026gt;\u0026gt;\u0026gt; cascade(2013) 2013 201 20 2 20 201 2013   在这个递归函数中，最基础的情况是单一一个数字，直接打印。否则，递归函数在两个打印之间被调用。\n基础情况在递归函数之前进行调用并不是硬性规定的。实际上，通过观察可知print(n)这个表达式在判断语句前后重复出现了，因此通过将打印语句提前可以让这个函数表达得更紧致。\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; def cascade(n): print(n) if n \u0026gt;= 10: cascade(n // 10) print(n)   举另外一个相互递归调用的例子，想象一下一个双人游戏，最开始在桌面上有n个鹅卵石。玩家轮流从桌面上拿走一个或者两个鹅卵石，最后一个移动鹅卵石的人就算作胜利。假设Alice和Bob玩这个游戏，每个人都用最简单的策略：\n Alice总是拿走一个鹅卵石 如果桌面上剩下双数个鹅卵石，Bob就拿走两个鹅卵石，否则就拿走一个  给定n个鹅卵石然后从Alice开始，那么谁会赢得游戏？\n一个自然的分解这个问题的办法是将每一个策略封装到各自的函数中去。这允许我们改动一个策略而不影响另一个策略，在两者之间维护一个抽象屏障。为了实现这个游戏一轮又一轮的性质，这两个函数在每一轮最后的位置相互调用彼此。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; def play_alice(n): if n == 0: print(\u0026#34;Bob wins!\u0026#34;) else: play_bob(n - 1) \u0026gt;\u0026gt;\u0026gt; def play_bob(n): if n == 0: print(\u0026#34;Alice wins!\u0026#34;) elif is_even(n): play_alice(n - 2) else: play_alice(n - 1) \u0026gt;\u0026gt;\u0026gt; play_alice(20) Bob wins!   在play_bob中，我们看到在一个函数体内可能会出现多个递归的调用。然而，在这个例子中，每一次调用play_bob最多只调用play_alice一次。在下一节中，我们会考虑一下当一个函数调用时直接调用多个递归会发生什么事。\n1.7.4 树递归 另一个计算的一般模式称作树递归，也就是一个函数调用自己超过一次以上。举个例子，想象一下，计算一个斐波那契序列，每个数都是前两个数的和。\n 相对于我们之前的尝试，这个递归定义是十分吸引人的：它准确地反映了斐波那契数的定义。一个函数有多个递归调用被称为树递归，因为每一个调用都会分支出更多小的分支调用，而这些小分支又分支出更小的调用，就像是一棵树的分支一样从树干延伸，越来越小，却越来越多。\n我们之前就已经能够定义不需要树递归的计算斐波那契数的方式。实际上，我们之前的尝试会更加的高效率，这是本文后面讨论的主题。接下来，我们考虑一个问题为什么树递归会比任何一个迭代替代方案都要简单得多。\n1.7.5 例子：分割 正整数n的分割数，使用最大的尺寸的m，是一个数n可以表现最大为m以递增顺序表现的正整数部分的和。例如，使用4作为6的分割数的话，可以有9种情况。\n 6 = 2 + 4 6 = 1 + 1 + 4 6 = 3 + 3 6 = 1 + 2 + 3 6 = 1 + 1 + 1 + 3 6 = 2 + 2 + 2 6 = 1 + 1 + 2 + 2 6 = 1 + 1 + 1 + 1 + 2 6 = 1 + 1 + 1 + 1 + 1 + 1  我们会定义一个函数count_partitions(n, m)，它会返回使用最大分割数m的n的分割数量，这个函数有个一个简单的树递归的实现形式，以下面的观察作为依据：\n用m作为最大分割数的n的分割种类有：\n 使用最大为m的整数来划分n-m的方式的种类，加上 使用最大为m-1的整数来划分n的方式的种类  来看下为什么这是对的，观察可知所有的分割n的方式的数量能够分成两组：那些至少包括一个m的跟所有不包括m的。此外，第一组中的每个分割类型是n-m的分割，随后在末尾加上m。在上面的例子中，最先的两个分割包含4，其他的则不包含。\n因此，我们可以通过使用两个更简单的问题递归地减少最大直到m的整数来分割n：(1) 分割更小的数n-m，以及 (2) 分割具有更小分量的整数直到m-1。\n要完成函数实现，我们需要指定以下的基础情况：\n 分割0的方式只有一种：不包括任何部分 分割负数n的方式有0种。 分割任何大于0的n但是用小于等于0作为组成部分的分割方式只有0种。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026gt;\u0026gt;\u0026gt; def count_partitions(n, m): if n == 0: return 1 elif n \u0026lt; 0: return 0 elif m == 0: return 0 else: return count_partitions(n-m, m) + count_partitions(n, m-1) \u0026gt;\u0026gt;\u0026gt; count_partitions(6, 4) 9 \u0026gt;\u0026gt;\u0026gt; count_partitions(5, 5) 7 \u0026gt;\u0026gt;\u0026gt; count_partitions(10, 10) 42 \u0026gt;\u0026gt;\u0026gt; count_partitions(15, 15) 176 \u0026gt;\u0026gt;\u0026gt; count_partitions(20, 20) 627   我们可以认为树递归函数是在进行不同可能性的探索。在这个例子中，我们探索可以用作分割的m的大小的可能性以及不可用作分割的可能性。第一以及第二个递归调用对应这些可能性。\n用非递归方式实现这个函数需要更多的投入，鼓励感兴趣的读者进行尝试。\n","description":"","id":6,"section":"posts","tags":["译文","Design Programs"],"title":"程序构成-第一章","uri":"https://jmwill.github.io/blog/2017/03/09/%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90-%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"content":"前言： 我的深入ES6系列由24篇覆盖了未来ES6中大多数语法以及特性的改变的文章组成。这篇文章的目的是总结所有的要点，提供给你ES6中最切实可行的建议，从而让你可以快速开始。我已经在深入ES6系列文章中提供链接，因此你可以轻易地深入到你感兴趣的主题。\n听说你们喜欢要点，所以我写了这篇包含数百要点的文章。在开篇这里有覆盖所有主题的目录。显然，里面有你要的要点。需要注意的是，如果你想要让这些概念深入脑海的话，你将需要很多的时间去通过深入系列学习相关概念同时还需要练习，试验这写ES6的代码。\n目录  介绍 工具 解构赋值 展开运算符以及不定参数 箭头函数 模板字符串 对象字面值 类 Let以及Const Symbols 迭代器 生成器 Promises 映射 弱映射 集合 弱集合 代理 反射 Number对象 Math对象 Array对象 Object对象 字符串跟Unicode 模块组件  十分抱歉目录这么长，下面我们开始ES6旅程。\n介绍  ES6 - 也叫被称作“和谐”，“es-next”，“ES2015” - 是这门语言最新且已敲定的版本。 ES6规范最终敲定于2015年的7月（又称：ES2015） 未来敲定的版本将会使用ES[YYYY]的命名模式，例如：ES2016对应于ES7  每年发布一个新版本，新特性将会一波接着一波 从ES6最先讨论中，我们大多数还是叫它ES6 从ES2016开始（ES7）我们应该使用ES[YYYY]的模式来称呼新版本 命名方案的最主要原因是想要迫使浏览器厂商尽快更新新的特性到现代浏览器中    工具  要想让ES6运行，你需要一个JavaScript到JavaScript的转译器 转译器具有下列功能  它们允许你将相应语言的最新版本的代码翻译成旧版本的可运行代码 随着浏览器的支持越来越好，我们会将ES2016和ES2017翻译成ES6以及以外版本的代码 我们将会需要更好的来源映射功能 它们是在产品上运行ES6版本语言的最可信任的方式（即使浏览器只支持ES5版本的语言）   Babel（一个转译器）有一个杀手级特性：阅读友好型输出 用Babel去将ES6静态转译为ES5 用babelify将babel合并到你的[Gulp, Grunt, or npm run][4ef399d4]构建流程当中去 Node.jsv4.x.x或者更高版本已经对ES6特性有了像样的支持，感谢V8 在任何node的版本中使用babel-node，因为它可以将模块转译成ES5 Babel有蓬勃发展的生态系统，已经支持一些ES2016的特性，同时出了插件进行支持 阅读ES6工具简史  解构赋值  var {foo} = pony等于var foo = pony.foo var {foo: baz} = pony等于var baz = pony.foo 你可以提供默认值，var {foo='bar'} = baz相当于foo: 'bar'如果baz.foo是undefined 只要你喜欢，你可以拿到尽可能多的属性，可以起别名或者不起  var { foo， bar:baz } = { foo: 0, bar: 1}将会得到foo:0 跟baz:1   你可以用多层结构。var {foo: {bar}} = {foo: {bar: 'baz'}}会得到deep: 'baz' 你也可以重命名。var {foo: {bar: deep}} = {foo: {bar: 'baz'}}，会得到deep: 'baz' 如果属性没有找到会像平时一样得到undefined，例如：var {foo} = {} 多层结构中没有找到属性的话会抛出一个错误，例如：var {foo: {bar}} = {} 对于数组一样适用，[a, b] = [0, 1]得到a: 0和b: 1 你可以跳过数组中的元素，[a, , b] = [0, 1, 2]，会得到a: 0和b: 2 你可以交换两个数而不需要额外的交换参数，[a, b] = [b, a] 你可以在函数的参数中使用解构赋值的特性  分配默认参数如：function foo (bar=2) {} 默认参数也可以是对象如：function foo (bar={a: 1, b: 2}) {} 完全解构对象如：function foo({a = 1, b = 2}) {} 如果额外的参数没有赋予任何值则提供一个空对象如：function foo ({a = 1, b = 2} = {}) {}   看深入了解JavaScript ES6解构  展开运算符以及不定参数  不定参数是更好的arguments  你应在方法签名中定义它如：function foo (...everything) {} everything是一个传输所有参数到foo函数的数组 你可以在...everything前定义一些参数如：function foo(bar, ...rest) {} 已命名的参数将被排除在...rest之外 ...rest一定要是列表中的最后一个参数   展开运算符比魔法更好用，也是一样使用...标记语法  避免在.apply调用方法时使用，如：fn(...[1, 2, 3])跟fn(1, 2, 3)一样 更容易的级联[1, 2, ...[3, 4, 5], 6, 7] 将类数组对象或可迭代对象投射到数组中，如：[...document.querySelectorAll('img')] 解构 中也十分好用，[a, , ...rest] = [1, 2, 3, 4, 5]会得到a: 1跟rest: [3, 4, 5] 让new + .apply毫不费力，new Date(...[2015, 31, 8])   看深入ES6展开运算符  箭头函数  能够用简易的方法来声明一个函数像param =\u0026gt; returnValue 在进行这些操作如：[1, 2].mpa(x =\u0026gt; x * 2)将变得十分方便 有几种方式可供选择，可能需要改掉以前的一些习惯  p1 =\u0026gt; expr对于只有一个参数的函数是可行的 p1 =\u0026gt; expr会隐含地返回所提供的expr表达式 要隐式地返回一个对象可以将其包裹在一个括号() =\u0026gt; ({foo: 'bar'})里面否则会抛出错误 当你有零个，两个或多个参数的时候是需要括号包裹的() =\u0026gt; expr或者(p1, p2) =\u0026gt; expr 在右边通过使用大括号可以声明一个代码块() =\u0026gt; {}，可以在里面写多句代码 当使用代码块的方式的时候是没有隐式的返回操作的，需要自己主动提供() =\u0026gt; {return 'foo'}   你不可以静态地声明一个箭头函数，但是运行时对大多数方法都能够很好地推断出其名称 箭头函数内的词法域绑定在其父级  this跟父级的this是一样的 this无法通过.call，.apply或者是类似于反射类型的方法修改   看深入ES6箭头函数  模板字符串  你可以通过\u0026rdquo; ` \u0026ldquo;反引号来定义字符串，而不是\u0026quot;或者' 被反引号包裹的字符串称为模板字符串 模板字符串可以是多行的 模板字符串在里面进行插值操作如：poofoo.com is ${rating}，里面的rating是一个变量 你可以在插值的地方使用任何有意义的JavaScript表达式如：${ 2 * 3 }或者${foo()} 你可以通过标签模板来修改模板字符串的插值方式  在模板字符串前添加一个fn前缀fn`foo, ${bar} and ${baz}` fn函数会被立马调用，传进去的参数是template, ...expressions template实际上是['foo', ' and ', '']而expressions则是[bar, baz] fn返回的结果将会是模板函数的值 有可能用于输入清理或者参数结构等地方   将字符串包裹在模板字符串中比用单引号或双引号来包裹字符要好 看深入ES6模板字符串  对象字面值  不用像之前那样{ foo: foo }，现在可以直接{ foo }，这被称作属性值速记 属性名可以通过计算得到{[prefix + 'Foo']: 'bar'}，如果prefix: 'moz'，则会得到{ mozFoo: 'bar'} 不可以同时使用属性值速记法与属性名计算，{[foo]}是无效的 对象内的方法是常量，可以用选择更加简约的方式来定义，{ foo () {} } 看对象章节 看深入ES6对象字面值特性  类  不是传统意义上的类，只是原型继承的语法糖 语法跟一般的类定义相似，class Foo {} 实例方法-new Foo().bar通过短对象字面值语法来定义，class Foo { bar() {}} 静态方法-Foo.isPonyFoo()需要使用static前缀关键字，class Foo { static isPonyFoo() {} } 构造函数方法class Foo{ constructor () { /* initialize instance */ } } 通过简单的语法进行原型继承class PonyFoo extends Foo {} 看深入ES6类  Let以及Const  在定义变量的时候可以选用let或者const来代替传统的var let定义的变量是以块作用域的为范围的，而不是以function作为词法范围的 let的变量提升是在块内的，而var定义的变量提升是在函数内的提升 \u0026ldquo;暂时性死区\u0026rdquo; - 简称TDZ  在块区中let foo被定义了之后开始产生 结束于let foo声明被放置的用户代码区域（在里面跟变量提升没有关系） 在TDZ中对foo（可以进行访问前）进行访问或分配值将会得到一个错误如：let foo = (() =\u0026gt; foo = \u0026lsquo;test\u0026rsquo;)(); 有助于避免在一个变量被声明期间就进行操作而出现的神奇的bug   const也是块级作用域，有变量提升，也具有TDZ限制 const变量一定要在声明之初就初始化，const foo = 'bar' 在const初始化之后再次定义的话会默默地失败而没有任何提示，（或者在严格模式下会抛出错误） const一个变量不意味着分配的值不可变  const foo = { bar: 'baz' }意味着foo会总是引用右边的对象 const foo = { bar: 'bar' }; foo.bar = 'boo'不会抛出错误   声明一个同样名字的变量会抛出错误 为了修正在传输到某处时重新分配变量而丢失引用带来的错误 在ES6，函数是块级作用域的  防止通过变量提升来泄露块级作用域的内容{let _foo = 'secret', bar = () =\u0026gt; _foo;} 不会破坏通常情况下的用户的代码逻辑，以及常用的用法   看深入ES6的Let，Const和”暂时性死区”（TDZ）  Symbols  ES6中新的原始类型 你可以这样var symbol = Symbol()创建你自己的Symbols 你可以添加一个描述用于调试目的像：Symbol('ponyfoo') Symbols是不可修改而且唯一的，Symbol(), Symbol(), Symbol('foo') Symbol('foo')彼此之间都是不一样的 Symbols是symbol类型，因此typeof Symbol() === 'symbol' 你也可以通过Symbol.for(key)创建一个全局的Symbols  如果一个具有key的symbol已经存在，就会直接返回这个Symbol 否则，就会创建一个用key描述的新的Symbol Symbol.keyFor(symbol)是一个反向操作的函数，通过传进去一个symbol得到一个返回值key 全局symbols是全局可获得的，或者说是跨域的。单一的注册表用于在运行时访问这些symbols  window上下文 eval上下文 \u0026lt;iframe\u0026gt;上下文，Symbol.for('foo') === iframe.contentWindow.Symbol.for('foo')     下面的也是知名的符号对象  不在全局的注册表，通过Symbol[name]访问如：Symbol.iterator 跨域，意味着Symbol.iterator === iframe.contentWindow.Symbol.iterator 通过规范来定义协议如：iterable protocol对于Symbol.iterator 它们实际上在口头术语上不是总所周知的   对symbol对象的属性进行迭代是困难的，但并非是不可能的也绝不是私有的  Symbols对于所有的预ES6“反射”方法都是隐藏的 Symbols能够通过Object.getOwnPropertySymbols来访问 你不会偶然找到它们，但是如果你积极寻找，就能找到它们   看深入ES6 Symbols 对象  迭代器  迭代器和迭代规则定义了如何去遍历一个对象，不仅仅局限于数组或者类数组对象 一个总所周知的是Symbol对象用于将迭代器分配到任何对象当中 var foo = { [Symbol.iterator]: iterable }或者foo[Symbol.iterator] = iterable iterable是指具有返回一个具有next方法的iterator对象的方法 next方法返回一个具有两个属性的对象，分别是value和done  value属性指示序列中遍历到的当前值 done方法指示是否还有更多的遍历对象要遍历   一个具有[Symbol.iterator]值的对象是可遍历的，因为它们遵从迭代协议 一些内建的对象如：Array，String或者arguments以及在浏览器中的NodeList在ES6中也是默认可迭代的 可迭代对象能够通过for...of方法遍历，如：for (let el of document.querySelectorAll('a')) 可迭代对象可以融合使用展开运算符像：[...document.querySelectorAll('a')] 你也可以用Array.from(document.querySelectorAll('a'))去将一个可迭代序列融合进数组中 迭代器是懒惰的，因此创建一个无限序列在程序中也是有效的 需要注意的是不要对无限序列进行展开操作...或者用Array.from，因为这样会导致无限循环 看深入ES6迭代器  生成器  生成器函数是一个特殊的迭代器，能够用这样的语法来声明function* generator () {} 生成器函数用yield来返回一个元素序列 生成器函数也能够用yield*去委托其他的生成器函数或者任何可迭代对象 生成器函数返回一个同时具有可迭代性以及遵从迭代协议的生成器对象  给定g = generator()，g遵从可迭代协议，因为g[Symbol.iterator]是里面的一个方法 给定g = generator()，g遵从可迭代协议，因为g.next是一个方法 迭代器对生成器对象g而言就是生成器本身：g[Symbol.iterator]() === g   通过Array.from(g), [...g], for (let item of g)或者仅仅是用g.next()方法获取迭代器对象的值 生成器函数的执行是暂停的并且记住最后的位置，有四种不同的情况  yield表达式返回序列的下一个值 return声明返回序列的最后一个值 throw声明会完全暂停生成器 生成器函数在最后会发出信号{done: true}   一旦g序列结束g.next()指示返回{done: true}且没有副作用 使用生成器能够使得异步流感觉起来像同步流  由用户提供生成器函数 当异步操作发生的时候用户代码会暂停 调用g.next()，用户代码取消暂停操作   看深入ES6生成器  Promises  遵从Promises/A+规范，在ES6标准化之前就已经被广泛实施（如：bluebird） Promises的表现得像是一棵树。通过p.then(handler)和p.catch(handler)来添加枝干 用new Promise((resolve, reject) =\u0026gt; { /* resolve */ })来创建一个新的Promises对象p  resolve(value)回调函数会用提供的value完成promise reject(reason)回调函数会以reason错误来拒绝完成p 你可以异步地来调用这些方法，在promise树的更深的层次里面进行阻塞   每一次调用p.then和p.catch就会创建另外一个promise用于继续为已经成为完成态的p继续提供阻塞操作 Promises开始时是一个等待状态，在__fulfilled__或者__rejected__之后变成完成态 Promises可以只完成一次，然后它就变成完成态，变成完成态的promises会停止阻塞深层的分支 你可以添加任意的promises到你需要添加的任意的分支上 每一个分支都会执行.then处理函数或者.catch处理函数两者中的一个，且只能是一个 .then回调函数可以通过返回一个值来传送前一分支的结果 .then可以返回另外的一个阻塞的promises对象 p.catch(fn).catch(fn)不会像你预期的那样工作-除非你是想要捕捉错误处理器的错误 Promise.resolve(value)创建一个已经处于完成态且提供值的promise对象 Promise.reject(reason)创建一个已经处于失败态且提供原因的promise对象 Promise.all(...promises)创建一个等待所有...promises变成完成态或者其中一个变成失败态就变成稳定态的promise对象 Promise.race(...promises)创建一个只要...promises中有一个处于稳定状态的变成稳定态的promise对象 使用Promises\u0026ndash;一个可视化的promise练习场\u0026ndash;去更好地理解Promises 看深入ES6的Promises  映射  用于代替常见的用纯JavaScript对象实现的哈希映射  避免用户提供的键带来的安全问题 允许键为任意值，你甚至可以使用DOM元素或者函数作为条目的键   Map对象遵从迭代协议 用new Map()方法来创建一个map对象 像初始化一个iterable对象这样[[key1, value], [key2, value2]]来在new Map(iterable)里初始化一个map对象 用map.set(key, value)来添加一个条目 用map.get(key)来获取一个条目 通过map.has(key)来用key作检查 用map.delete(key)来删除一个条目 用for (let [key, value] of map)来迭代一个map对象，要想展开map可以使用Array.from等 看深入ES6的Maps对象  弱映射  跟Map对象差不多，但是不完全一样 WeakMap不可迭代，所以你无法获取到像.forEach，.clear等能在Map对象中获取到的列举方法 WeakMap的键一定要是引用类型，不可以使用像symbols，numbers或者strings等值类型作为键 WeakMap以key为键的条目对变量进行引用，其中引用的变量会被垃圾回收处理 最后的点意味着WeakMap十分适合维持还在使用的对象的元数据（metadata） 避免了内存泄露，无需进行手动引用计数可以将WeakMap想象成.NET中的IDisposable 看深入ES6弱映射  集合  跟Map很像，但不完全一样 Set没有键，只有值 set.set(value)看起来不是很好，所以使用set.add(value)作为替代 Sets不能有重复的值，因为值同时也是键 看深入ES6的集合类型  弱集合  WeakSet就像是Set跟WeakMap的杂交版本 WeakSet就是一个无法迭代，也没有列举方法的集合对象 WeakSet的值必须是一个引用类型 WeakSet在元数据表说明中会很有用，无论这个表中的引用是否一直活跃。 看深入ES6弱集合  代理  代理对象用new Proxy(target, handler)，target目标对象可以是任何对象，handler则是处理器对象 proxy的默认行为作为直通底层target对象的对象 Handlers定义底层对象target在常规对象之上的访问语法 你将引用向下传递给proxy同时对target对象能如何与之交互保持绝对的掌控 Handlers也被称为Traps，这些术语经常互用 你可以用Proxy.revocable(target, handler)创建一个可撤销的proxies对象  这个方法返回一个拥有proxy和revoke属性的对象 你可以方便地进行解构var {proxy, revoke} = Proxy.revocable(target, handler) 你可以用new Proxy(target, handler)对proxy进行相同的配置 在调用revoke()之后，proxy对任何操作都会抛出错误，方便对不信任的使用者进行操作   get-相当于proxy.prop以及proxy['prop'] set-相当于proxy.prop = value以及proxy['prop'] = value has-相当于in操作符 deleteProperty-相当于delete操作符 defineProperty-相当于Object.defineProperty和声明的替代方法 enumerate-相当于for..in循环 ownKeys-相当于Object.keys和相关方法 apply-相当于_function calls_ construct-相当于new操作符的用法 getPrototypeOf-相当于内部调用[[GetPrototypeOf]] setPrototypeOf-相当于调用Object.setProrotypeOf isExtensible-相当于调用Object.isExtensible preventExtensions-相当于调用Object.preventExtensions getOwnPropertyDescriptor-相当于调用Object.getOwnPropertyDescriptor 看 深入ES6的Proxies 看 深入ES6的Proxies Traps 看 更多深入ES6的Proxies Traps  反射  Reflection是ES6中新的静态内置对象（想一下Math） Reflection方法有合理的内部结构，如：Reflection.defineProperty返回一个boolean值而不是抛出错误 每个代理对象trap的handler都具有一个Reflection方法，代表每一个trap的默认行为 更深入地，新的反射方法中同样的Object.keys会被放置在Reflection命名空间中 看深入ES6反射对象  Number对象  使用0b作为二进制数前缀，0o作为八进制前缀 Number.isNaN和Number.isFinite除了不需要Number前缀以外，其他跟同名的全局变量一样。 Number.parseInt和Number.parseFloat跟它们的全局变量一模一样。 Number.isInteger检查输入的数值是否没有小数部分 Number.EPSILON帮忙区分两数相加跟确定值之间的微小差异如：0.1 + 0.2 和 0.3之间的差异 Number.MAX_SAFE_INTEGER代表刚好能在JavaScript中安全显示的最大的整数 Number.MIN_SAFE_INTEGER代表刚好能在JavaScript中安全显示的最小的整数 Number.isSafeInteger检查一个整数是否处于界限内，能够安全精确地显示 看深入ES6中改进的Number对象  Math对象  Math.sign对一个数进行sign运算的函数 Math.trunc求一个数的整数部分的函数 Math.cbrt求一个数的立方根的函数即：∛‾的值 Math.expm1求e的value次方减一的值，或者是evalue - 1的值 Math.log1p计算value+1的自然对数的值或者说ln(value + 1) Math.log10计算以10为底的对数的值或者说log10(value) Math.log2计算以2为底的对数的值或者说log2(value) Math.sinh计算一个数的双曲正弦的值 Math.cosh计算一个数的双曲余弦的值 Math.tanh计算一个数的双曲正切的值 Math.asinh计算一个数的双曲反正弦的值 Math.acosh计算一个数的双曲反余弦的值 Math.atanh计算一个数的双曲反正切的值 Math.hypot计算两个数的平方和相加后求其平方根的值 Math.clz32计算并返回一个数字在转换成 32 无符号整形数字的二进制形式后, 开头的 0 的个数, 比如 1000000 转换成 32 位无符号整形数字的二进制形式后是 00000000000011110100001001000000, 开头的 0 的个数是 12 个, 则 Math.clz32(1000000) 返回 12 Math.imul返回两个参数的类C的32位整数乘法运算的运算结果 Math.fround将任意的数字转换为离它最近的单精度浮点数形式的数字 看深入ES6附加方法  Array对象  Array.from - 从一个类数组对象如arguments或者iterables对象中创建一个数组实例 Array.of - 跟new Array(...items)类似，但不会有特殊情况 Array.prototype.copyWithin - 复制数组中的一个序列到数组中的其他地方 Array.prototype.fill - 用提供的数据填充数组中的所有元素 Array.prototype.find - 返回满足回调处理函数条件的第一个元素 Array.prototype.findIndex - 返回满足回调处理函数条件的第一个元素的下标 Array.prototype.keys - 返回一个会返回保持顺序的键的迭代器 Array.prototype.values - 返回一个会返回保持顺序的值的迭代器 Array.prototype.entries - 返回一个会返回保持顺序的键值对的迭代器 Array.prototype[Symbol.iterator] - 跟Array.prototype.values一模一样的方法 看深入ES6的Array对象拓展方法  Object对象  Object.assign - 将...objects对象的属性进行递归浅覆盖到target中 Object.is - 跟编程时用的===相似，除了NaN vs NaN返回true以及+0 vs -0返回false Object.getOwnPropertySymbols - 返回在对象自身内找到的所有symbols属性 Object.setPropertyOf - 改变原型，相当于Object.prototype.__proto__setter 也可以看看文本对象章节 看深入ES6对象中改变的方法  字符串跟Unicode  字符串操作  String.prototype.startsWith - 判断字符串是不是以value开头 String.prototype.endsWith - 判断字符串是不是以value结尾 String.prototype.includes - 判断字符串是不是包含有value String.prototype.repeat - 返回重复了给定次数的字符串 String.prototype[Symbol.iterator] - 让你以unicode码点（不是字符）对字符串进行遍历   Unicode  String.prototype.codePointAt - 对指定位置返回字符以10为基数的字符码点 String.fromCodePoint - 给定...codepoints，返回一个以unicode编码表示的字符串 String.prototype.normalize - 返回一个以unicode编码表示的规范化版本的字符串   看深入ES6的Strings和Unicode扩展  模块组件  Strict Mode在ES6的模块系统中是默认开启的 ES6模块是一个export一个API的文件 export default value输出默认绑定的API export var foo = \u0026lsquo;bar\u0026rsquo;输出一个命名绑定 输出绑定的命名在模块输出的任何时候都可以改变它们 export { foo, bar }输出一列命名 export { foo as ponyfoo }将命名另起别名后输出 export { foo as default }将命名作为默认输出 在所有模块的最后export default api是最佳实践，其中为避免混乱，api是一个对象 模块加载是一个特定的实现，允许跟CommonJS进行互相操作 import \u0026lsquo;foo\u0026rsquo;将foo模块加载到当前模块当中 import foo from \u0026lsquo;ponyfoo\u0026rsquo;将ponyfoo模块的默认输出分配给本地变量foo import {foo, bar} from \u0026lsquo;baz\u0026rsquo;从baz模块中加载输出的命名foo和bar import {foo as bar} from 'baz'从baz模块中加载foo并重命名为bar import {default} from 'foo'也是加载默认输出 import {default as bar} from 'foo'加载默认输出并重命名为bar import foo, {bar, baz} from 'foo'将默认输出foo以及命名输出bar和baz混合在一起进行声明 import * as foo from \u0026lsquo;foo\u0026rsquo;加载命名空间对象  在foo[name]包含所有的命名输出 如果在模块中定义有默认输出的话，在foo[default]中包含默认输出   看深入ES6的模块拓展  到这里要点就结束了。话又说回来，我要提醒下你记得去阅读系列文章。不要忘记订阅或者甚至捐助Pony Foo，哦，还有，你尝试了绝技了吗？\n翻译自PONYFOO.COM \u0026ndash; 原文\n","description":"","id":7,"section":"posts","tags":["译文","ES6","JavaScript","Front End"],"title":"【译】ES6的350个要点概述","uri":"https://jmwill.github.io/blog/2016/12/16/%E8%AF%91es6%E7%9A%84350%E4%B8%AA%E8%A6%81%E7%82%B9%E6%A6%82%E8%BF%B0/"},{"content":"按照字面意思，生命就是一场所有人都在玩的游戏。但这游戏可以很困难，而这篇文章就是你的游戏攻略。\n基础 你可能没有意识到，但是现实生命就是一场战略游戏，有一些小型的有趣游戏，像：跳舞、驾车、跑步和性等赢取它们的关键仅仅需要管理好你的资源。\n成功的玩家将他们的时间投入到正确的事情里面。之后在玩游戏的过程里面钱、资源什么的自然而然就来了，而其中重要的是你需要始终将明确自己的时间花费在哪这个原则摆在首位。\n幼年阶段 生命开始于你分配到的随机角色与环境：\n生命的前15年左右就是一个教程任务，很烦人。但是没有任何方法避免。\n青年阶段 作为一个年轻玩家，你会有许多的时间和能量，但是，几乎没有什么经验。你会发现大多数的东西都是上锁的。像最好的工作，财产和伙伴们。\n这是一个快速升级你的技能的绝佳时机，错过了，你将不会再有这样的精力与时间。\n现在你可以好好地玩了，你的首要任务就是尽可能好地分配你的时间，你做的每一件事情都会影响你的状态与能力\n这听起来可能很简单，但问题是你并不总是知道什么任务应该选择，而且你的身体也不总是遵循你的命令。接下来，让我们打破这样的情况。\n如何遵循你自己的命令 很多的玩家都会发现当他们选择做某些东西的时候，像说-“去健身房运动”-这样的事情，他们的身体却完全不理睬他们。\n这是一个错误。每个人都有一个状态条，你不能直接看见，但看起来像下面一样：\n如果你的其中一条状态条过低，你的身体将不会遵从你的指令直到你的需求得到满足。或者你可以尝试在口渴或者饥饿的时候去学习，然后留意自己的注意力是怎么转到推特上的。\n你的意志力高低是尤其重要的，意志力会在一天当中逐渐消退，它能通过进食来少量补充，或者通过一晚好睡眠来完全补充。当你的意志力底下时，你仅仅只能够做到你真心想要做到的事。\n每一个你做的决定都会消耗你的意志力，通常这些决定都需要更强的意志力让你压制具有更强吸引力的选项而去选择吸引力更小的那个（比如：去运动而不是看电视）。\n下面有几个技巧让你保持最好的状态：\n 保持你的状态良好。如果你正忍受饥饿，口渴，或者觉得被完全剥夺了快乐，你的意志力会崩溃。所以，要始终保证照顾好自己。 __不要一天耗费过多的意志力__将艰巨的任务分块，在几天内完成它，然后将任务组合在一起能够减少整体的困难度 尝试以最重要的任务为先。这会使其他的任务更加困难，但是却可以让优先级最高的任务变得容易。 通过减少选择来减少意志力的消耗。如果你尝试在可以登陆脸书的电脑上工作，你会需要花费更多的意志力，因为你会经常倾向于选择容易的任务多过困难的任务。消除这些分心的东西吧。  玩这个游戏的关键是你要根据自身的状态来选择优先工作的任务，不要让你自己处于自动驾驶的状态，这样的话你将什么也做不完。\n选择正确的任务 在游戏中尽可能多地在对的时间选择对的任务，一些任务主要对你的状态造成影响，例如：\n其他的主要对你的技能造成影响：\n你需要投入时间以保证有健康的状态\u0026ndash;像吃饭跟睡眠\u0026ndash;会让你的意志力保持高昂。然后你需要用剩下的时间去发展提升你的技能。\n一些技能会比另外一些更有价值。那些好的技能能打通整个学习路径，如科技树：\n另外一些是个死胡同：\n将多个技能组合起来是最有效的。在一项技能上成为顶尖人物是十分困难的，而这在现实中也常常是不可能的，但是将许多相关的技能组合成更大且体面的技能却是十分容易的。\n从上面可以看出心理学能够让你变得有钱又有吸引力，所以应该去学习它。\n在哪里生活 你所处的环境会对你的状态，技能，以及练级的机会有着不断的冲击/影响。\n是有可能在任何地方玩好一个游戏，但是在某些地方会使其变得容易。例如：如果你是一个女性同时又去到了一个错误的国家，你的很多成就将不能解锁。\n任何人能够出生在最合适他们的环境里的概率几乎为0，所以重新研究你的选择，并考虑尽早离开现有的环境，（好的）环境是你的状态与技能的倍增器。\n找到一个伴侣 吸引本身是一个复杂的小型游戏，但我们参与的且已经在玩的主要是它的副产品。如果你有出色的状态与技能，你就已经十分有吸引力了。一个疲惫，敏感，缺乏技能的玩家是没有吸引力的，而且页不需要期待能够建立关系。\n在这个游戏的早期，拒绝其他玩家与被拒绝都是十分常见的。这是正常现象，但是不幸的是这会导致你的状态流失，因为大多数玩家不能很好地处理被拒绝这个事情。你需要花费精力去让自己继续生活，而精力需要通过睡眠补充，所以，给自己点时间恢复。\n寻找一个伴侣80%都归结于自身最有吸引力的部分，这就像生活一样，将你的时间分配到正确的地方。如果你一直坚持运动，保持社交，有充足的营养，且事业一直在发展。你自身会不断地散发吸引力。剩下的20%仅仅需要让自己出现在能遇到合适的人的地方。\n钱钱钱 之后，在游戏里你需要去管理一种新的叫做“钱”的资源，大多数玩家会通过早期的游戏来寻找增加钱的办法，但这实际上会带来更多的问题，而不是更少。\n对于钱，最重要的法则是永远不要借钱，除非这样做是能够让你赚取更多的钱。例如：借钱去接受教育或者还抵押会是值得的（但是不一定，这取决于这个教育或者抵押（是否有价值））。而借钱去买鞋子则是不值得的。\n根据你对自己财务的志向，这里有几个策略需要牢记在心：\n 没有多余的钱 低应力战略：过简单的生活同时积蓄一点钱以备不时之需。一定要确保将节省下来的所有时间用在最好的地方，否则你会后悔的。 小康 小心地选择事业与所处的环境同时准备好经常提升自己。你会需要投入大量资源到搭配技能上，这会花费你的时间，且注意不要滥用你的精力，否则你会劳累过度的。 巨富 自己创业。替他人打工几乎不可能变得富有起来。财富不单单通过工作得来，它们来源于你拥有的东西——资产——它们带来的比它们花费的多，而你自己的公司就是一个你可以从头建立的强大的资产，不断将金钱转化为你的资产，最终它们将使你免于工作。  后续生活 随着游戏的继续你的选择会不断改变。婚姻与孩子会降低你的时间与精力，同时引入更多不确定的元素（“紧急换尿布！”）到游戏里面。这会使得快速提升自己变得困难起来。\n年长的人物通常会有更多的技能，资源和经验，能解锁以前几乎不可能解锁的任务，像”拥有一栋房子“，或者”写一部（好的）小说“。\n所有的玩家都会在29000天或80年后死亡，如果你的状态与技能十分好，你有可能能够坚持得久一些。这个没有任何金手指代码来延长生命。\n在游戏之初，你没有任何能力控制你是谁或你所处的环境。在游戏的最后你也再一次无法控制这些。你过去的决定大幅塑造了你最后结束的地方，不管你是开心，健康或者满足与否，在你最后的日子里你可以做到的极其有限。\n这就是为什么战略这么重要，因为随着时间的推移，我们大多数人都会想通生命的真谛就是我们已经将最好的部分使用过度了。\n现在你最好开始继续游戏了\n原文\n","description":"","id":8,"section":"posts","tags":["翻译"],"title":"【译】生命是一场游戏，而这是一份攻略","uri":"https://jmwill.github.io/blog/2016/06/29/%E8%AF%91%E7%94%9F%E5%91%BD%E6%98%AF%E4%B8%80%E5%9C%BA%E6%B8%B8%E6%88%8F%E8%80%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%BB%BD%E6%94%BB%E7%95%A5/"},{"content":"因为一些开发需求需要用到正则表达式，但是实际开发中每用一次正则就重看一次这样的事情实在是羞愧至极，所以在这里再进行一次正则的复习。以求能够较全面地理解正则表达式。\n好了，那么什么是正则表达式呢？正则表达式，个人目前的理解是遵照一定的限定规则进行字符（串）匹配。百度百科的说法：使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。通常被用来检索、替换那些符合某个模式的文本。看来，概念理解还可以，下面进行正则的复习阶段。\n基础 使用正则表达式可以直接通过生成一个字符串作为最基础的匹配。在JavaScript中就是myReg = /Will/;，使用这个正则对象执行exec操作就可以把字符串中的匹配部分拿出来。可是，有时候，不一定输入的就是大写的Will，有可能用户输入的是“Hi，will！”，这个时候，使用正则的i参数可以忽略大小写进行匹配。即myReg = /Will/i;。\n好了，上面的正则表达式可以匹配到需要的单词了，然而真的是这样么，假如有一个用户叫JMwill，现在使用meReg来测试一下这个句子“Hi，JMwill”，毫无疑问，这个表达式一样可以找到will，当然如果不管什么情况下你只要will，这个表达式是可以用的，可是大多数时候需要的是精确匹配，那么，这里可以用什么办法来进行匹配出精确的will呢？在这里需要引入元字符这个新的东西，\n元字符 正则表达式由普通字符与元字符组成，可见元字符就是正则表达式中的重中之重，那元字符是什么？元字符其实就是具有特殊含义在正则表达式中用于进行规则制定的字符。上面说到，myReg会对任意含有will的词组进行匹配，无法找出单独的will单词，那么，在这里我们就需要加上一个\\b作为限定，\\b的含义是匹配一个单词边界，也就是指单词和空格（符号）间的位置，在这里需要知道的一个事情是：正则表达式的匹配有两种概念，一种是匹配字符，一种是匹配位置。这里的\\b正是用于匹配位置的，所以现在myReg变成了myReg = /\\bwill\\b/i;。这里是元字符的表格。下面会列出一些常用的元字符。\n代表数量： + --代表前面的子表达式（内容）至少出现一次或多次出现（大于等于1次） * --代表前边的内容可以连续重复使用任意次（零次或更多次）以使整个表达式得到匹配 ? --代表前边的内容可以重复零次或一次以使整个表达式得到匹配 {} --有三种使用方式，第一，{number}，表示仅匹配number次前面的子表达式。 第二，{number,}，表示至少匹配number次前面的子表达式。 第三，{numberOne,numberTwo}，表示最少匹配numberOne次且最多匹配numberTwo次前面的子表达式 匹配字符： . --代表匹配除了换行符以外的任意字符一次。 \\d --匹配0~9中的一位数字 \\s --匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v] \\w --匹配包括下划线的任何单词字符（Unicode字符集，即包括中文）。 [] --用于定义一个字符集合，匹配所包含的任意一个字符。如：[xyz]可以匹配zoo中的z，或者定义一个范围[0-9]，匹配0~9任意一个数字。 匹配位置： \\b --匹配一个单词边界，指单词和空格（符号）间的位置 ^ --匹配输入字符串的开始位置 $ --匹配输入字符串的结束位置 分支条件 在正则表达式中可能需要进行一些逻辑选择，这个时候，可以使用|符号进行或选择，这个元字符作用是：将两个匹配条件进行逻辑“或”（Or）运算，即如有一个这样的表达式：(JMwill|will)，这个将会匹配“Hi JMwill！”或者匹配“Hi will”，但是在使用|时需要注意的是它进行的是短路求值，这将会对一些表达式造成影响。如：“z|food”能匹配“z”或“food”或\u0026quot;zood\u0026quot;而“(z|f)ood”则匹配“zood”或“food”。\n反义 当有一些需求如：需要一些除某某某以外的数据，这个时候，使用正常的表达式来进行定义可能会变得麻烦或者无法达成，这个时候可以使用反义，在正则表达式中定义一般的反义，可以使用[^some chart you need]，在方括号里面需要在最靠前的地方添加一个^符号，这个符号在方括号的最前面才有意义，代表‘除了\u0026hellip;’的意思。同时，在正则表达式中也提供了一些常用的反义：\n\\W --代表匹配任意不是字母，数字，下划线，汉字的字符 \\S --代表匹配任何可见字符。 \\D --代表匹配一个非数字字符。 \\B --代表匹配非单词边界位置。 分组 在正则表达式中需要进行多个字符或多个内容匹配应该怎么进行呢？在这里，可以使用分组（子表达式）来实现需求。通过使用()来进行分组的定义，将需要的内容包括在里面，然后就可以使用元字符来对分组进行限制了。\n后向引用 这里，将会讲述后向引用的基本内容，后向引用需要跟分组配合一起使用，通过后向引用可以重复搜索前面某个分组匹配的文本。一般的分组使用\\n来进行匹配，n代表的是分组的组号，即要匹配第一个分组就使用\\1来进行匹配。来个例子说明一下：testReg = /(will|JMwill)\\s+\\1/;这个表达式就会匹配文本“Hi JMwill JMwill, where is Lucas?”。\n当需要对分组进行命名的时候，可以使用(?\u0026lt;name\u0026gt;exp)来进行，?\u0026lt;name\u0026gt;（也可以替换为：?'name'）是进行命名所必须的，name处替换为想要的名字。而exp就是正常想要匹配的内容。当需要进行分组又不想要让分组具有引用的时候，可以使用(?:exp)这样的写法，?:代表不捕获匹配文本，也不分配组号。还有一些特定用途的语法，不过这是进阶问题了。\n零宽断言 零宽断言，嗯，好高级的名字，乍一看，我都吓怕了。其实，零宽的意思是没有宽度，那什么是没有宽度的呢？在正则表达式里，位置是没有宽度的，因此这个用于指定位置。那断言呢？断言也就是指满足一定的条件。所以，零宽断言就是满足一定条件的位置。下面进行解释：\n(?=exp)这个叫做零宽度正预测先行断言，还是深奥的名字，它的作用是：在自身出现位置的后面能匹配表达式exp，这个自身是指分组前的表达式匹配出来的内容如：nameReg = /\\b+w(?=will\\b)/;，这里的式子能够匹配字符串“name is JMwill”中的JM出来。\n(?\u0026lt;=exp)这个叫做零宽度正回顾后发断言，它的作用跟上面的相反：用于在自身出现位置的前面能匹配表达式exp，这个自身跟上面一样。\n负向零宽断言 这里的负向，顾名思义就是相反。即这个位置不能去匹配分组内的表达式exp。\n(?!exp)这个叫做零宽度负预测先行断言，即在自身出现位置的后面不能匹配表达式exp，自身指分组前的表达式匹配出来的内容。这里使用位置来进行判断，不会出现使用元字符判断出现跳过，或误判的情况。如使用[^exp]来进行判断，有可能会把不希望要的空格、标点等包括进去。\n(?\u0026lt;!exp)这个叫做零宽度负回顾后发断言，作用：在自身出现位置的前面不能匹配表达式exp，自身指分组前的表达式匹配出来的内容。\n注释 有时候，我们可以对正则表达式添加一些注释，（what？Are you kidding me？），没错，这是真的。可以通过使用(?#comment)来添加注释，comment就是注释的内容。或者可以通过忽略正则表达式内的空白符，以这样的方式来写注释：\n(?= #comment \u0026lt;(\\w+)\u0026gt; #comment ... ) 这种方式可以方便理解表达式的内容。\n贪婪匹配与懒惰匹配 正则表达式是非常勤劳的，它在对进行要求的匹配的同时尽可能地匹配最长的内容，当你需要匹配重复的字符时，如：testReg = /ha.*!/;这个式子会对句子“hahahaha!hahahaha!”整个匹配，但是当在*号后面添加一个?号之后，式子就会仅仅匹配前面的“hahahaha!”了，即testReg = /ha.*?!/;。这个添加?的方法对所有重复匹配的元字符都有用。\n*? --尽可能少地重复任意次 +? --尽可能少地重复一次或多次 ?? --尽可能少地重复零次或一次 {n,m}? --尽可能少地重复n次到m次 {n,}? --尽可能少地重复n次以上 平衡组/递归匹配 总有些需求是需要将一组成对的符号内的内容匹配出来，如果仅仅是一对，这个问题就好办了，直接写就好。但是，有些时候需要对多个成对且相互嵌套符号进行配对，这时使用简单的方式就无法进行准确的匹配。（由于由于这个主题我理解得也不是很深入，只好借助deerchao的解释以及例子）这个问题可以通过以下语法构造解决：\n(?'group') --把捕获的内容命名为group,并压入堆栈(Stack) (?'-group') --从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败 (?(group)yes|no) --如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分 (?!) --零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败 \u0026lt; #最外层的左括号 [^\u0026lt;\u0026gt;]* #最外层的左括号后面的不是括号的内容 ( ( (?'Open'\u0026lt;) #碰到了左括号，在堆栈上压入一个\u0026quot;Open\u0026quot; [^\u0026lt;\u0026gt;]* #匹配左括号后面的不是括号的内容 )+ ( (?'-Open'\u0026gt;) #碰到了右括号，堆栈弹出一个\u0026quot;Open\u0026quot; [^\u0026lt;\u0026gt;]* #匹配右括号后面不是括号的内容 )+ )* (?(Open)(?!)) #在遇到最外层的右括号前面，判断堆栈上还有没有没弹出的\u0026quot;Open\u0026quot;；如果还有，则匹配失败 \u0026gt; #最外层的右括号 上面的正则表达式每碰到了左括号，就压入一个\u0026quot;Open\u0026rdquo;,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就会失败。正则表达式引擎就会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。\n总结 在进行编写简单正则表达式的时候，需要记住的东西不多，这一次复习，通过归纳整理，相信已经对正则表达式了解更深刻一些了。最后的最后，需要补充的是JavaScript中的正则表达式可以添加三个处理选项跟别是：\ni --不区分大小写 m --多行匹配 g --全局匹配 参考资料：\n 正则表达式30分钟入门教程 JavaScript RegExp 对象  ","description":"","id":9,"section":"posts","tags":["笔记"],"title":"复习正则表达式","uri":"https://jmwill.github.io/blog/2015/11/17/%E5%A4%8D%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"content":"什么是构造函数？构造函数在JavaScript中也就是一个普通的函数，之所以能成为构造函数是因为需要使用其来进行对象的构造。而构造新对象的情况出现在使用new操作符调用构造函数的时候。在这里引用图片一张由图片的关系可以看出每一个函数的内部都有一个prototype属性，这一个属性指向一个prototype对象，prototype对象内显式地包含了一个constructor属性指向函数，这样构成一个循环引用。\n那么问题来了，为什么需要这样的一个constructor属性呢？因为在JavaScript中，每一个对象都隐式地包含了一个**__proto__**属性，这一个属性用于指向**构造函数的prototype对象**，这样当对象查找自己内部属性无果时，可以通过原型链，也即prototype对象来进行查找引用。这就是JavaScript的原型继承，这个时候，通过原型链也就能够找到对象自身的创建者，即constructor属性指向的对象（构造函数）。\n所以看回图片可以看到b、c两个对象的**__proto__**都指向**Foo**的prototype对象，因为都是由Foo创建出来的，而**Foo**的**__proto__**指向**function**的prototype对象，显然这是由于Foo是由**function对象**创建出来的，最后要说一下的就是，所有的**prototype对象**的**__proto__**都是指向**object对象**，结果自然就是因为**prototype对象**是由object创建出来的。\n但是还是没有说明白为什么需要这一个constructor属性啊，对，如果我们根本不需要知道对象的创建者，那么constructor存在好像也没有什么必要，但是当我们使用instanceof运算符的时候，假设A是B创建出来的实例对象。即A instanceof B就是正确的，而内部的查找线路会是这样：先查看A.__proto__是否等于B.prototype，如果等于那么就返回true，如果错误那么就继续按照A的**__proto__**这条链来进行查找，而B则按照**prototype**这条链来进行查找，如果找到同一引用，也返回true，否则到最后结束，没有则返回false。\n参考资料：\n http://www.nowamagic.net/librarys/veda/detail/1642  ","description":"","id":10,"section":"posts","tags":["javascript","笔记"],"title":"javascript构造函数","uri":"https://jmwill.github.io/blog/2015/11/02/javascript%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"content":"根据阮一峰大大所说JavaScript是一种基于对象的语言，但由于缺失了类这一个语法特性，JavaScript又不是一种面向对象编程的语言。\n对象 生成对象的原始模式： var Obj = { property: 'num or string', method: function() { } } 上面的方法生成的对象是一个个的独立个体，相互之间除了都是由Object对象创建出来之外，没有其他任何关系。\n构造函数模式： 要实现从原型生成一个实例，可以通过JavaScript提供的构造函数。而所谓的构造函数也就是一个普通的函数，但是其内部使用了this这个变量，在通过new运算符进行实例生成的时候，this会动态地绑定到生成的对象上。\nfunction Obj(name, age) { this.name = name; this.age = age; } var objOne = new Obj('one', 10), objTwo = new Obj('Two', 5); 如上的对象生成方式就利用了JavaScript的构造函数，通过这种方式构造出来的实例对象会包含一个指向构造它们出来的对象（函数）的属性叫做：constructor，这种关系可以使用instanceof运算符来进行判断：console.log(objOne instanceof Obj); // true\n通过构造函数可以很好地构造出对象，但是当构造函数中包含有很多的属性、方法时，这种方式进行构造就会极大地浪费内存，因为每一次创建出来的对象内部的所有东西都是独立的，没有进行重用。即使是相同的方法（函数），构造函数也会重新运行一次操作，进行申请资源，分配空间等然后分配给新的对象。\nprototype 因为构造函数无法解决重用的问题，因此，需要用一个额外助手：prototype。prototype属性是每一个构造函数中都存在的一个属性，它指向另外的一个对象可以称为prototype对象，这个对象中的所有属性和方法都会被构造函数构造出来的实例对象所继承。\n因为有了prototype对象，现在，可以将需要进行重用的属性或者方法等放到它里面：\nfunction Obj(name, age) { this.name = name; this.age = age; } Obj.prototype.type = 'Person'; Obj.prototype.getName = function() { return this.name; } var objOne = new Obj('one', 10); 这样这些不变的方法以及属性就可以避免重复创建了。\nprototype验证 为了方便验证prototype或进行一些其他操作，JavaScript里提供了一些辅助方法：\n// isPrototypeOf()方法，判断某个proptotype对象和某个实例之间的关系 console.log(Obj.prototype.isPrototypeOf(objOne)); // true // hasOwnProperty()方法，判断某一个属性是本地属性，还是继承自prototype对象的属性 console.log(objOne.hasOwnProperty('name')) // true console.log(objOne.hasOwnProperty('type')) // false // in运算符，判断某个实例是否含有某个属性 console.log('age' in objOne); // true; console.log('type' in objOne) 构造函数的继承 绑定方式 关于构造函数的继承，说白了就是要让实例对象能够找到需要继承的对象的属性以及方法。而在构造函数中，使用到了this这个对象，在JavaScript中，能够修改this指向的方法有apply和call，这样，一种继承的方式就有着落了：\nfunction Person(name, age) { this.name = name; this.age = age; } function Student(name, age, school) { Person.apply(this, arguments); this.school = school; } var studentOne = new Student('xiaoming', 10, 'Oxford'); 这里已经实现了继承，然而这种实现需要记得参数的位置要保持一致，虽然可以在Student定义时不添加name，age这两个参数，但是为了不造成混淆，还是加上的好。\nprototype方式 prototype方式是通过将prototype设置为需要继承的对象的一个实例，通过这个实例来进行属性以及方法的查找。\nfunction Person(name, age) { this.type = \u0026quot;Person\u0026quot;; } function Student(name, age, school) { this.name = name; this.age = age; this.school = school; } Student.prototype = new Person(); Student.prototype.constructor = Student; var studentOne = new Student('xiaoming', 10, 'Oxford'); 使用这种方式能够实现继承，但是明显有这其特有的限制，参数会被固定，或者只能继承固定的属性。同时，因为在外部重写了prototype属性，因此需要将新的prototype属性里面指向原构造函数的constructor重写成目标构造函数，在这里就是用Student覆盖掉Person，避免继承链的混乱。由于这里继承的是不变的属性，因此可以直接将属性写入到prototype中，然后通过指向prototype来实现继承。\nfunction Person() {}; Person.prototype.type = \u0026quot;Person\u0026quot;; function Student(name, age, school) { this.name = name; this.age = age; this.school = school; } Student.prototype = Person.prototype; Student.prototype.constructor = Student; var studentOne = new Student('xiaoming', 10, 'Oxford'); 使用上面的方法实现继承，能够提高效率，但是当有需要对prototype（这里指Student的prototype对象）进行改写的时候，其继承的对象的prototype（这里指Person的prototype对象）的属性也会一并受影响。因此这种继承只适合继承永远不变的属性。\n空对象跳板 由于直接继承prototype即使用被继承对象的prototype实现继承会出现间接修改的问题，而通过使用实例实现继承会出现浪费资源的问题。所以这里通过使用一个空对象来作为跳板，影响最小化。由于空对象的内存占用小，而且对其进行修改不会有什么问题，因此可以这样来实现继承：\nfunction Person() {}; Person.prototype.type = 'Person'; function tempFun(){}; tempFun.prototype = Person.prototype; function Student(name, age, school) { this.name = name; this.age = age; this.school = school; } Student.prototype = new tempFun(); Student.prototype.constructor = Student; var studentOne = new Student('xiaoming', 10, 'Oxford'); 上面通过空对象而且使用prototype直接继承的方式，使得内存开销小。同时避免了prototype修改的副作用。\n另外一种空对象的实现方式可以通过为父类添加一个init方法，从而避免在构造函数内进行父类属性的初始化。\nfunction Person() {}; Person.init = function(name, age) { this.name = name; this.age = age; } function Student() {}; Student.prototype = new Person; Student.prototype.constructor = Student; Student.prototype.init = function(name, age, school) { this.name = name; this.age = age; this.school = school; } var xiaoming = new Student; xiaoming.init('xiaoming', 10, 'Oxford'); console.log(xiaoming.school) 在这里实现了父类的继承，无法使用父类的初始化方法，而且需要人手调用init方法。虽然可以通过一个变量标识是否在进行实例化从而在父类的构造函数内进行判断来调用init方法，不过这样会引入全局变量，不推荐使用。\n万能拷贝 既然是继承，那么也就是要用到被继承的对象的资源，因此，通过变通的方法，使用拷贝来进行继承。把所有的对象都放到prototype上，然后通过遍历将属性都拷贝到要继承的对象上。\nfunction Person() {}; Person.prototype.type = 'Person'; function Student(name, age, school) { for (var i in Person.prototype) { Student.prototype[i] = Person.prototype[i]; } this.name = name; this.age = age; this.school = school; } var studentOne = new Student('xiaoming', 10, 'Oxford'); 当然，当对象的属性构成比较复杂的时候就需要通过深拷贝来实现精确拷贝，而非引用拷贝。这样才能够真正避免修改prototype的副作用。\n非构造函数继承 修改子对象prototype 当我们拥有一些普通对象，而且想要实现对象间的继承的时候，因为普通对象没有构造能力，无法使用new，那么这时通过使用什么方法来达到继承的目的呢？通过使用prototype。对象进行属性查找的时候在自身上无法查找到的时候就会通过prototype来进行查找。因此可以通过prototype来实现继承。\nvar goodness = { sympathetic: true, helpful: true } function object(obj) { function fun() {}; fun.prototype = obj; return new fun; } var person = object(goodness); person.name = 'xiaoming'; person.age = 10; 这一种方法，只不过是让被继承的对象变通地赋予构造的能力而已。\n还是万能的拷贝 既然对象没有构造能力，那么我们就人为的帮它实现继承。所以，这里可以使用拷贝的方法。而正如上面构造函数的最后一种继承方法一样，当对象属性不复杂时，可以使用浅拷贝。而当属性为另一个对象时，浅拷贝就只能拷贝引用了，所以，这里统一使用深拷贝。来进行继承实现。\nvar goodness = { sympathetic: true, helpful: true } function deepCopy(beCopy, copyer) { var copyer = copyer || {}; for (var i in beCopy) { if (typeof beCopy[i] === 'object') { copyer[i] = (beCopy[i].constructor === Array) ? [] : {}; deepCopy(beCopy[i], copyer[i]); } else { copyer[i] = beCopy[i]; } } return copyer; } var person = deepCopy(goodness); person.name = 'xiaoming'; person.age = 10; 以上就是继承的一些方式，在进行面向对象编程的时候可以斟酌使用。\n参考资料：\n http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html http://www.cnblogs.com/sanshi/archive/2009/07/08/1519036.html http://segmentfault.com/a/1190000002440502  ","description":"","id":11,"section":"posts","tags":["javascript","笔记"],"title":"javascript面向对象编程","uri":"https://jmwill.github.io/blog/2015/11/02/javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"content":"预备知识 this 在JavaScript中，this指向函数执行时的当前对象。this关键字在JavaScript中和执行环境，而非声明环境有关。而当没有明确的执行时的当前对象时，this指向全局对象window。\nJavaScript中我们需要了解几类函数：\n 对于eval函数，其执行时候似乎没有指定当前对象，但实际上其this并非指向window，因为该函数执行时的作用域是当前作用域， 浏览器中setTimeout、setInterval和匿名函数执行时的当前对象是全局对象window， apply和call能够强制改变函数执行时的当前对象，让this指向其他对象。 new关键字后的构造函数中的this指向用该构造函数构造出来的新对象  作用域 在JavaScript中除了全局作用域之外，只有函数可以创建的作用域，因此，全局代码最好在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。声明时建议用“单var”形式。同时我们需要记住的一点是作用域在函数定义时就已经确定了。而不是在函数调用时确定\n函数定义与执行 假设现在需要定义一个函数A，当定义函数A的时候，js解释器会将函数A的作用域链(scope chain)设置为定义A时A所在的“环境”，如果A是一个全局函数，则scope chain中只有window对象。\n当执行函数a的时候，A会进入相应的执行环境(excution context)。在创建执行环境的过程中，首先会为A添加一个scope属性，即A的作用域，其值就为定义A时的scope chain。即A.scope=A的作用域链。\n之后执行环境会创建一个活动对象(call object)。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对象后，把活动对象添加到A的作用域链的最顶端。此时A的作用域链包含了两个对象：A的活动对象和window对象。\n接下来是在活动对象上添加一个arguments属性，它保存着调用函数A时所传递的参数。\n最后把所有函数A的形参和内部的函数的引用也添加到A的活动对象上。在这一步中，完成了内部函数的定义，因此如同定义A函数，函数的作用域链被设置为内部函数所被定义时的环境，即A的作用域。\n到此一个函数从定义到执行的过程结束了。\n自由变量 在一个作用域中（称为A）使用的变量x，却没有在这个A作用域中声明（即在其他作用域中声明的），对于这个作用域A来说，x就是一个自由变量。\nvar x = 10; var myFun = function() { console.log(10 + x); } 而需要记住的一个问题就是，在一个函数（myFun）中的自由变量需要到哪里取值？答案是：取自由变量x的值时，要到创建myFun函数的那个作用域中取————无论fn函数将在哪里调用。如一个迷惑人的例子：\nvar x = 10; var myFun = function() { console.log(10 + x); } var testFun = function(fn) { var x = 20; fn(); } testFun(myFun); // 得到20而不是30 在上面的例子中，如果认为自由变量应该由上一级作用域中取值的话，就会得到错误的答案。所以要记住取自由变量x的值时，要到创建myFun函数的那个作用域中取\n闭包 有了上面的预备知识，下面来了解一下，什么是闭包（简而言之）：\n 闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在 闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配 当在一个函数内定义另外一个函数就会产生闭包  它的应用有两种情况————函数作为返回值，函数作为参数传递。而闭包最大用处有两个，一个是可以读取外部函数内部的变量，另一个就是让使用到的外部变量的值始终保持在内存中。\n// 情况一 var myFun = function() { var name = 'will'; return function sayName() { console.log(name); }; } var sayName = myFun(); sayName(); // 情况二 var name = 'will', sayName = function() { return name; } var theName = function(fn) { var name = 'another will' return fn(); }(sayName); console.log(theName); 在上面的例子中可以看到，返回的函数创建了一个独立的作用域，而这个返回的函数使用了自由变量，因此，在这个返回的函数未销毁前，创建自由变量的上下文环境不会被销毁，如此才能够使用自由变量，但是这样做会增加内存开销，同时还可能在IE上造成内存泄露所以要在必要时再使用闭包。\n在看参考资料中了解到Javascript中的闭包(Closure)，有两个特点：\n 作为一个函数变量的一个引用 - 当函数返回时，其处于激活状态。 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。  而比较让人认同的闭包实现可以通过三种方式：\nwith(obj){ //这里是对象闭包 } (function(){ //函数闭包 })() try{ //... } catch(e) { //catch闭包 但IE里不行 } 参考资料：\n http://www.cnblogs.com/wangfupeng1988/p/3977987.html http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html http://www.cnblogs.com/rubylouvre/archive/2009/07/24/1530074.html http://www.jb51.net/article/18303.htm http://www.oschina.net/question/28_41112  ","description":"","id":12,"section":"posts","tags":["javascript","笔记"],"title":"javascript闭包","uri":"https://jmwill.github.io/blog/2015/10/29/javascript%E9%97%AD%E5%8C%85/"},{"content":"Ecmascript 6之前，JavaScript不包含传统的类，JavaScript中对象通过原型链进行继承，通过原型链就能够让函数成为对象的方法。\n对象 在理解什么是原型之前，我们要先了解JavaScript中的对象，在JavaScript中除了主数据类型(undefined，null，boolean，number，or string)，剩下的都是对象，或者说一切（引用类型）都是对象，对象是属性的集合。而对象都是通过函数来创建的，而当试图获取一个主数据类型的原型时，它会被强制转化成了一个对象，如：false.__proto__ === Boolean(false).__proto__; \n原型 那什么是原型？原型是一个对象，其他对象可以通过它实现属性继承。既然如此，在以对象为先的JavaScript中，所有的对象都有一个原型，原型本身也是对象，因此原型本身也有一个原型。所有的对象都可以成为原型。\n获取对象原型的方法：\nvar obj = {}; // 创建一个对象 //Firefox 3.6 and Chrome 5 Object.getPrototypeOf(obj); //Firefox 3.6, Chrome 5 and Safari 4 obj.__proto__ //All obj.constructor.prototype; 使用对象原型 var Person = function() { this.name = null; this.setName = function(name) { this.name = name; }; this.getName = function(name) { return this.name; } }; var me = new Person(); me.setName('JMwill'); console.log(me.getName()); 上面就是一般使用对象的方法，但是上面的方法每创建一个对象，内部的方法就需要创建一次，浪费资源。下面是另外一种写法：\nvar Person = function() { this.name = null; }; Person.prototype = { setName: function(name) { this.name = name; }, getName: function() { return this.name; } }; var me = new Person(); me.setName('JMwill'); console.log(me.getName()); 在进行继承时，若不希望子对象继承父对象的属性，可以在使用prototype的基础上进行prototype继承：\nvar Person = function() { this.name = null; }; Person.prototype = { setName: function(name) { this.name = name; }, getName: function(name) { return this.name; } }; var Student = function() { this.school = null; }; Student.prototype = new Person(); //继承属性 Student.prototype = Person.prototype; //不继承属性 Student.prototype.setSchool = function(school) { this.school = school; }; Student.prototype.getSchool = function() { return this.school; }; var me = new Person(); console.log(me.name); var me = new Student(); console.log(me.name); 尽管这个例子有点问题，但是，可以说明使用原型链继承，可以使得父对象的属性不会在子对象中出现。\nInstanceof 在使用到原型以及原型链时，常常会碰到需要确定对象所属的情况，这里使用typeof是无法得出想要的结果的，这时就到instanceof上场了。\nA instanceof B\n上面的例子中，A为B创建出来的对象。Instanceof的判断队则是：沿着A的_\n_proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。\n原型链 先盗图一张，来源： http://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/figure1.jpg\n正常情况下，当我们进行原型链的继承时，使用的方法就是将原型对象赋予一个继承的对象的实例，即：\nvar Person = function() { this.name = null; }; Person.prototype = { setName: function(name) { this.name = name; }, getName: function() { return this.name; } }; var Student = function() { this.school = null; }; Student.prototype = new Person(); Student.prototype.constructor = Student; //修正原型的构造对象 上面的方法就是一般继承时需要做的步骤。\n属性查找 在JavaScript中对象的属性会通过原型链进行查找，而hasOwnProperty方法是JavaScript中唯一一个处理属性但是不查找原型链的函数。因此可以使用其来进行自定义属性的查找。\nvar Person = function() { this.name = null; }; Person.prototype = { setName: function(name) { this.name = name; }, getName: function() { return this.name; } }; var Student = function() { this.school = null; }; Student.prototype = new Person(); Student.prototype.constructor = Student; Student.id = 0 console.log(Student.hasOwnProperty('id')); // true console.log(Student.hasOwnProperty('getName')); // false __proto__对象 再盗图一张\nJavaScript中的对象都具有一个__proto__属性，这个属性默认引用了创建这个对象的函数的prototype对象，因此，可以有：\nvar Person = function() { this.name = null; }; Person.prototype = { setName: function(name) { this.name = name; }, getName: function() { return this.name; } }; var p1 = new Person(); var p2 = new Person(); // 上面创建的对象中，p1、p2的proto指向Person的prototype对象 // 而Person由Function对象创建而来的，因此proto指向Function的prototype对象 // Person的prototype以及Function的prototype都是Object创建而来，因此proto // 指向Object的prototype对象 // 而每一个prototype对象，在最初状态下其constructor属性指向的都是本身所属的函数 额外记录：this this是掌握JavaScript中的重点，而更多时候，让我们迷惑的是this到底代表什么？其实在函数中的this取何值是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。\n 当函数作为构造函数被调用时，this为构造出的对象。当函数进行全局或者普通调用时，this为全局Window（浏览器上） 在作为一个对象属性的函数中被调用时，this指向的是当前对象  var obj = { name: 'will', setAge: function() { var generateAge = function() { this.age = 10; } generateAge(); // 这里也相当于普通调用，this指向window } } obj.setAge(); console.log(window.age); // 10 console.log(obj.age); // undeifned 参考资料：\n http://www.nowamagic.net/librarys/veda/detail/1648 http://www.jb51.net/article/30750.htm http://blog.jobbole.com/9648/ http://www.cnblogs.com/wangfupeng1988/p/3977987.html  ","description":"","id":13,"section":"posts","tags":["javascript","笔记"],"title":"javascript原型链","uri":"https://jmwill.github.io/blog/2015/10/28/javascript%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"content":"JavaScript（以下简称js）中作用域有全局作用域与局部作用域两种，这里重点讲局部作用域。\n什么是作用域？ 字面意思来看，作用域就是某样事物在一个或多个地方里面能够起作用。对于js而言，抛开最新版本的EcmaScript 6不说，EcmaScript 5以及之前的版本里面只有函数能产生域，同时没有块级作用域这个东东。对于作用域这个问题js权威指南的描述十分好理解：JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里。\n实例 var scope = 'global scope'; function funOne() { alert(scope); } function funTwo() { var scope = 'funTwo scope'; funOne(); } funTwo(); 这段代码运行后会弹出global scope，为什么不是fun2 scope呢？明明我已经在fun2里面覆盖了scope的值了呀，\n其实，在创建funOne的时候，它的一个属性**“作用域链”**会保存当前作用域的状态，就funOne而言，作用域链中会填入全局环境（即window）下的所有可访问的对象名，如果funOne在另外一个或多个函数里面，在记录全局作用域之前会先记录外层函数的作用域，而后一级一级向上记录直到全局作用域，就像一个队列一样，先记录的先访问。而后，当funOne被调用的时候，一个叫做**“运行期上下文”**的对象被创建，里面包含有函数保存的**“作用域链对象”**，而当funOne被调用需要进行标识符解析时就会在里面进行查找，funOne[Scope]——\u0026gt;Scope Chain[0] \u0026hellip; ——\u0026gt;Global Object，显然，当funOne定义时没有在funTwo的作用域内，因此并没有把其包含进去，而在调用funOne时产生的活动对象也就不包括funTwo的作用域，因此，funOne调用时得到global scope也就可以理解了。\n总之，最需要记住的就是：\n函数运行在它们被定义的作用域里\n函数运行在它们被定义的作用域里\n函数运行在它们被定义的作用域里\n重要的事情说三遍。\n优化 从上面可以看出，作用域嵌套得越深，访问标识符就越耗时间，那么，当需要跨作用域进行多次访问的时候，可以通过变量将要访问的值保存到局部来进行优化。就像经常会使用的Array.prototype，可以将其局部化，用一个变量如：arrProto来保存。\n作用域链改变 js中作用域链一般情况下，在运行期上下文运行的过程中，其作用域链会被 with 语句和 catch 语句影响。with语句不推荐使用，因此直接不用就好，而对于catch语句，当发生错误而执行转跳到catch部分时，一个包含异常对象的可变对象会被置于作用域的头部，而函数的原作用域的其他部分将全部后延一位，这里会带来一些性能的损耗，一般不用去在意，如果真的十分重视性能，可以通过将错误处理委托给另一个函数来进行，\ntry { myErrorFun(); } catch (e) { dealWithError(e); } 上面由于dealWithError方法是catch子句中唯一执行的代码。该函数接收异常对象作为参数，由于只执行一条语句，且没有局部变量的访问，作用域链的临时改变就不会影响代码性能。\n参考资料：\n http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html http://www.laruence.com/2009/05/28/863.html  ","description":"","id":14,"section":"posts","tags":["javascript","笔记"],"title":"JavaScript作用域","uri":"https://jmwill.github.io/blog/2015/10/17/javascript%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"content":"HTTP协议 HTTP协议属于应用层的协议，由于简捷、快速等原因适用于web，对于HTTP协议来说，它需要建立在能提供可靠交付的底层协议上，而TCP/IP协议正好满足，于是，HTTP协议基本都是建立在TCP/IP上。同时，HTTP协议属于无状态协议，无状态表明，协议对于事务处理没有记忆能力，一次链接就是一次链接，与上一次以及下一次链接没有关系。\nHTTP请求 HTTP请求是进行web开发时需要去了解的概念，其中请求由三部分组成，分别是：请求行、消息报头、请求正文。一个普通的请求例子：GET /index.html HTTP/1.1 (CRLF)。\n请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF。其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）\n各种请求方法：\n GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求  HTTP响应 HTTP响应从服务器发出，也是由三个部分组成，分别是：状态行、消息报头、响应正文，格式为HTTP-Version Status-Code Reason-Phrase CRLF，其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。\n其中，响应状态码中我们最熟悉的莫过于404，这就是一个HTTP响应状态码，一般代表请求不存在，而常见的响应状态码可以分为5类（详细的状态码解释在这里）\n 1xx：指示信息\u0026ndash;表示请求已接收，继续处理 2xx：成功\u0026ndash;表示请求已被成功接收、理解、接受 3xx：重定向\u0026ndash;要完成请求必须进行更进一步的操作 4xx：客户端错误\u0026ndash;请求有语法错误或请求无法实现 5xx：服务器端错误\u0026ndash;服务器未能实现合法的请求  HTTP消息报头 HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。\nHTTP消息报头包括普通报头、请求报头、响应报头、实体报头。\n每一个报头域都是由名字+\u0026rdquo;:\u0026ldquo;+空格+值 组成，消息报头域的名字是与大小写无关的。\n在这里记录一下每种报头的作用：\n 普通报头（在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。）  Cache-Control: 用于指定缓存指令，HTTP1.0使用的类似的报头域为Pragma。请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage. Date：普通报头域表示消息产生的日期和时间 Connection：普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接   请求报头  Accept：用于指定客户端接受哪些类型的信息。如：image/gif，表明客户端希望接受GIF图象格式的资源 Accept-Charset：用于指定客户端接受的字符集。如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。 Accept-Encoding：类似于Accept，但是它是用于指定可接受的内容编码 Accept-Language：类似于Accept，但是它是用于指定一种自然语言。 Authorization：主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。 Host：主要用于指定被请求资源的Internet主机和端口号，发送请求时，该报头域是必需的。 User-Agent：允许客户端将它的操作系统、浏览器和其它属性告诉服务器。   响应报头（响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。）  Location：用于重定向接受者到一个新的位置。 Server：包含了服务器用来处理请求的软件信息。   实体报头 （请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文和请求所标识的资源的元信息。）  Content-Encoding：被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法。 Content-Language：描述了资源所用的自然语言。 Content-Length：用于指明实体正文的长度。 Content-Type：用于指明发送给接收者的实体正文的媒体类型 Last-Modified：用于指示资源的最后修改日期和时间 Expires：给出响应过期的日期和时间，指定页面过期的时间。    关于HTTP协议就简单介绍到这里，本文章参考于：这里\n","description":"","id":15,"section":"posts","tags":["笔记","web"],"title":"HTTP协议学习","uri":"https://jmwill.github.io/blog/2015/10/16/http%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"},{"content":"转回windows系统后，用于老师方面的项目还没有完结，因此需要在windows下进行django的开发。现在先记录一下windows下的环境搭建方法，留作记录，同时也给其他需要在windows下进行django开发的童鞋一些方便*´∀`)´∀`)*´∀`)*´∀`).\n安装python 在这里我选择的是官方的最新版本，自带有pip，如果是python 2.7.9或者3.4.0以下的版本就需要自己进行pip的安装，具体方法看这里。python的官网。安装python的时候记得需要进行path的添加，安装的时候有选项的，不过在最下面，需要拉一下滚动条。如果没有添加path的话就需要自己手动添加了，比较麻烦而已。\n安装setuptools 可能有的童鞋已经安装了python的其他没有pip的版本，因此需要用setuptools来进行pip的安装，同时使用setuptools还可以进行ipython的安装，这里的ipython最好使用setuptools来进行安装，这样可以将相应的附加内容也一并安装，而在pip上并不会安装附加内容（（≥ｍ≤）这个我只是在别人的安装记录上看到的，没有验证，有兴趣的童鞋可以试一下）。\n安装setuptools的方法是在这里下载安装脚本，然后运行，我这里具体是直接双击，因为python已经加入路径，所以脚本可以直接运行。到这里setuptools就已经安装完成了。到这里，没有pip的童鞋可以在这里进行pip的下载，下载完成后用7-zip进行解压（其他也可以喇），然后用cmd进入文件夹运行找到setup.py并运行它python setup.py install。到这里没有pip的童鞋也有pip可以用了。\n安装ipython 在这里我推荐安装ipython，它比python自带shell模式好用很多，安装的方法在这里就很简单了直接在cmd上输入easy_install ipython，如果出错，有可能是原python的Scripts/路径没有添加，或者网络不稳定的原因，具体看出错信息，自行解决吧。\n安装virtualenv 由于已经具有pip这一个工具，这里就可以使用pip来进行virtualenv的安装pip install virtualenv，等待安装完成后，创建一个文件夹用于存放virtualenv创建的虚拟环境，在cmd中进入到创建的文件夹，然后输入virtualenv --no-site-packages [name you prefer]。\n创建完成自己的虚拟环境之后就可以通过activate脚本来运行虚拟环境了。在我这里是C:\\Users\\JMwill\\virtualenvs_of_will\\willenv\\Scripts\\activate，输入后回车，就会看见C盘符的前面带着虚拟环境的名字了。之后使用pip安装的包都会安装在虚拟环境下。这样就不用担心原python环境被搞得一团糟了。\n如果想要退出虚拟环境，将activate换成deactivate回车就行。\n让ipython支持env 按照安装的资料上说之前安装好的ipython默认是不会去查找env内的包的，这样在ipython中就无法引入相应的包。当然，你也可以在env内再一次安装ipython，但是这不是一个好的处理方法。所以，在这里需要对ipython进行一下小修改。但是，在我这里ipython并没有这种情况出现，但是，还是在这里将解决办法提供一下。\n在cmd中输入ipython prefile create，生成的文件名称应该是ipython_config.py。文件应该是存在ipython的profile文件夹内，windows中应该是[你的用户文件夹]\\.ipython\\profile_default这里。\n打开ipython_config.py文件的最后输入以下页面中的代码这里，参考这里，还有这里进行微调。到这里，再次启动ipython，注意输出信息是否有VIRTUAL_ENV -\u0026gt; c:\\[你的虚拟环境路径]\\Lib\\site-packages这样的信息。\n安装Django 到这里，终于要安装Django框架了。进入或者创建一个虚拟环境，然后运行虚拟环境。再在cmd中输入pip install django，安装完成后可以使用ipython进行检查，输入import django;django.VERSION，检查完毕后就可以开始创建一个django项目来玩玩了。\npython -m django-admin startproject [projectname] -m参数是告诉python寻找django-admin模块，记得不要直接使用django-admin来创建新项目哦，输入后回车应该就可以在当前目录下创建一个django项目了。\n安装MySQL 接下来进行MySQL下载以及安装，下载这里，可以选择下载一个完整的mysql，我这里硬盘肚量不够（┬＿┬），无奈只好下载一个server版本足够使用就算了。安装完成后记得检查是否将mysql添加到了path里面，打开cmd输入mysql --version，可以查看到mysql的版本，这样mysql server就安装完毕了。到这里，可以创建一个用于项目的用户，或者创建一个用于项目的数据库。\n----------------------------------我是分割线2015-10-14-----------------------\n这段时间需要在其他地方重新搭建一个django的运行环境，MySQL的安装的部分使用如果使用zip包的话还要自己配置路径、新增用户等的一些操作，过程比较麻烦，在这边还是推荐使用集成好的wamp来进行MySQL的安装，wamp中还有好用的PHPmyadmin和Apache、有时间还可以玩玩夹带的PHP。在这里需要注意的是，wamp下载可能需要用到梯子，如果发现点击下载链接没有反应，那就需要翻一下墙，而且wamp安装好之后默认root是没有密码的，如果只是测试的话，可以不设定，但最好还是设定一下密码。\n安装MySQL-python 在这里可以找到MySQL-python的下载链接，记得要看清对应的版本。下载完成之后不要立即启动安装程序，如果直接安装，安装到的地方是源python的安装目录下，这样python的虚拟环境是无法使用的。因此，我们需要先运行虚拟环境，然后使用easy_install来安装。在cmd内进入到软件的下载目录下输入easy_install mysql-python-1.*.*...，*\u0026hellip;*指的是你的软件名称，或者你也可以使用绝对路径来安装file://...。\n到这里Django环境就基本安装好了，\n这里是原文链接\n","description":"","id":16,"section":"posts","tags":null,"title":"构建windows下的django开发环境","uri":"https://jmwill.github.io/blog/2015/09/26/%E6%9E%84%E5%BB%BAwindows%E4%B8%8B%E7%9A%84django%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"content":"因为office的强大覆盖范围，我又无奈地投入到了windows的怀抱。但是之前使用Linux时手指在键盘上点击如飞的感觉实在是爽，于是，我又贱贱地装回了虚拟机来使用Ubuntu，不要问我为什么不装双系统 (ಥ _ ಥ)，谁叫我手贱买了个120G的固态硬盘，又不想加装个机械硬盘呢。没地方分啊_(:з」∠)_。好了，那装回了Ubuntu系统之后，当然是尽量配置一个自己喜欢的环境了。这里只是列出了我自己喜欢的环境，以作记录。\n材料准备  Ubuntu系统一枚； 翻墙软件一枚； 已点翻墙天赋；（想要点翻墙技能可以点击这里 装备VMware软甲；（软甲在此） 较为熟悉命令行操作；（步步高点读机，不会就点这里）  好了，材料就先准备这些先，之后会慢慢补充进去的。\n搭建python环境 因为我是一只程序猿，所以，一个舒适的文档编辑环境对我来说是非常重要的事情，在Ubuntu下，使用控制台进行日常开发是很舒适的，因此，这里我选择的编辑器就是vim，一个被誉为神之编辑器的编辑器，但是，在进行编辑器的全副安装之前，因为部分资源有可能需要搬（fan）梯（qiang）子，而搬梯子之前又需要pip，所以，第一步，先搭建较为舒服的python开发环境。由于最近的Ubuntu都有安装python的两个版本，因此，这里我们就省略安装python3的步骤先。\npip的许多包都需要libssl、以及libevent的编译环境，所以先安装：sudo apt-get install build-essential libssl-dev libevent-dev libjpeg-dev libxml2-dev libxslt-dev\n安装完成后就进行pip以及python中十分好用的virtualenv的安装：\n#安装pip sudo apt-get install python-pip #安装virtualenv sudo pip install virtualenv 仅仅安装完当然是不行的，为了避免我们每一次都需要启动virtualenv来进行pip包的下载，我们直接默认启动virtualenv。先创建virtualenv环境：\n# *号的位置为版本号，python有2.5,2.7,3.4,3.5等的版本 # 记得将*号换成相对应的版本号。 # 安装 python2.* virtualenv virtualenv --no-site-packages -p /usr/bin/python2.* ~/.venv/python2.* # 安装 python3.* virtualenv virtualenv --no-site-packages -p /usr/bin/python3.* ~/.venv/python3.* 然后将代码添加到~/.bashrc的最后面，这里的意思是在启动控制台时就默认用virtualenv环境替代系统的环境。\n# 缺省激活python2.7环境，这里为默认2.7的环境 if [ -f ~/.venv/python2.7/bin/activate ]; then . ~/.venv/python2.7/bin/activate fi 到这里，一个较好的python开发环境就好了，之后就不怕弄坏系统的python咯。\n搭梯子 在搭建好这个开发环境之后，就可以使用pip来下载梯子了，pip install shadowsocks，然后在你喜欢的地方进行shadowsocks的配置文件的编写：\n# 可以在这一个文件夹下进行安装/etc/shadowsocks/config.json { \u0026quot;server\u0026quot;:\u0026quot;remote-shadowsocks-server-ip-addr\u0026quot;, \u0026quot;server_port\u0026quot;:443, \u0026quot;local_address\u0026quot;:\u0026quot;127.0.0.1\u0026quot;, \u0026quot;local_port\u0026quot;:1080, \u0026quot;password\u0026quot;:\u0026quot;your-passwd\u0026quot;, \u0026quot;timeout\u0026quot;:300, \u0026quot;method\u0026quot;:\u0026quot;aes-256-cfb\u0026quot;, \u0026quot;fast_open\u0026quot;:false, \u0026quot;workers\u0026quot;:1 } 具体参数代表的意思： server 服务端监听地址(IPv4或IPv6) server_port 服务端端口，一般为443 local_address 本地监听地址，缺省为127.0.0.1 local_port 本地监听端口，一般为1080 password 用以加密的密匙 timeout 超时时间（秒） method 加密方法，默认的table是一种不安全的加密，此处首推aes-256-cfb fast_open 是否启用TCP-Fast-Open wokers worker数量，如果不理解含义请不要改 各项填写完整之后，就可以使用sslocal -c /etc/shadowsocks/config.json来运行客户端了，其他具体的问题，就需要自行解决了。都说用Linux系统的人都是喜欢折腾的人，感觉好像是的_(:з」∠)_，于是，在这里提供一个GUI形式的方便各位使用：\n# 在进行gui的源添加后进行update时可能会出现hash校验和不符的情况 # 这时服务器商的缓存造成的，遇到这种情况可以使用这个方法： # http://dockone.io/article/366，在这里我推荐换协议，毕竟， # 这时候我们还没有成功搬到梯子，无法使用代理方法。 sudo add-apt-repository ppa:hzwhuang/ss-qt5 sudo apt-get update sudo apt-get install shadowsocks-qt5 各位在Ubuntu下进行源的添加，然后安装完后就可以自动设置参数来使用,有没有windows下的方便感。ヽ(･∀･)メ，其他各个版本的安装方法在这里\n安装Git 在梯子搭建后之后，我们还需要现在炙手可热的版本管理工具Git的帮助，这个工具能够，让我们对自己的程序，工程，文件等进行版本管理。而且在编辑器添加功能的时候还是需要它的。下面我们先来安装Git：\n# Git安装 sudo apt-get install git # 安装完成后的配置工作 # 进行常用的命令设置alias git config --global alias.br branch git config --global alias.ci commit git config --global alias.co checkout git config --global alias.st status # 更好地显示git log，加不加无所谓 git config --global alias.lg \u0026quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen (%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset' --abbrev-commit --\u0026quot; # 设置用户信息 git config --global user.name \u0026quot;Your Name\u0026quot; git config --global user.email you@email.com # 缺省使用颜色显示，可加可不加。 git config --global color.ui true 为了让我们能够更好使用Git，在这里，我推荐安装git-flow这个分支模型，使用方法在这里，好，接下来是安装方法：sudo apt-get install git-flow，就这样，我们安装好了这个好用的版本管理工具了。具体的使用方法等，可以在以后慢慢熟悉。\n安装编辑器 好了，梯子搭好了（其实可以不用，不过有了就可以在需要时用上），版本管理工具（这个是一定要有）也装好了，现在我们可以进行编辑器的安装工作了(ρ_・).。_)，首先安装vim：sudo apt-get install vim vim-gtk，在这里需要安装vim-gtk，具体原因是在之后安装编辑器的时候需要用到gtk附带的一些功能。\n在安装完成vim后，我们就可以安装编辑器的插件，一般使用的是Vundle来进行管理，但是，在这里我比较推荐的是使用别人写好的脚本来进行编辑器的配置，我使用的是spf13。在控制台内输入curl https://j.mp/spf13-vim3 -L \u0026gt; spf13-vim.sh \u0026amp;\u0026amp; sh spf13-vim.sh即可进行spf13的下载，其会自动执行编译安装等环节。等待安装完成就可以。这样，一个较为舒适的Ubuntu下编辑环境就好了，\n最后，个人推荐在Ubuntu等Linux环境下使用 tmux，这是一个优秀的终端复用软件，好处以及使用方法可以自行man或者google。直接sudo apt-get install tmux进行下载就可以了。在这里需要记住的就是，使用tmux时，默认使用颜色集为8，类似spf13中下载了多种主题的插件，其颜色就会变得不一样，使得难以使用，这使因为主题需要的颜色集是256，因此，在启动tmux时可以加上-2参数，即：tmux -2，这样就可以让tmux以256颜色集来启动终端。于是，又可以愉快地使用vim编辑器了。\n结语 其实我一直很懒，每次都是临时在网上找资料来进行环境的配置，不过，总会忘了一些，这时候反而会更麻烦，因此就写了这样的一篇东抄西抄的东东出来，O__O \u0026ldquo;…\u0026quot;。还有，最后再说一下，我喜欢在控制台用黑底绿字的颜色配置，有没有黑（屌）客（丝）_(:з」∠)_的感觉，\n参考链接：开发舒适的python开发环境\n","description":"","id":17,"section":"posts","tags":null,"title":"创建舒服的Ubuntu开发环境","uri":"https://jmwill.github.io/blog/2015/09/13/%E5%88%9B%E5%BB%BA%E8%88%92%E6%9C%8D%E7%9A%84ubuntu%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"content":"ubuntu上制作Hexo博客 现在这个国内氛围里，我们什么都要求最低成本，所以咯，我们现在就搭建个免费的博客来使用一下下吧！(￣▽￣)~*\nhexo是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管在github上。其作者是来自台湾的**@tommy351**。我们搭建**hexo**这个东东，是拿做博客的嘛，那想要找个地方来放我们写下的文章，应该要放到哪里呢，答案当然是大热的github上啦。所以我们需要先装上git和node.js。因此，我们又可以趁机来学一下node.js了。不多说，开工。\n1. Git安装 ubuntu上安装git只需要执行下面的命令：\nsudo apt-get install git 为使用Github Page搭建博客, 我们需要在github上建立仓库,仓库名为Github用户.github.io，这样子我们才能通过http://Github用户.github.io访问到自己的博客。（关于git与github的操作配置，请看官网github官网\n2. Node.js安装 因为hexo官网推荐使用nvm来安装node.js，所以我们可以使用下面这条命令安装nvm：\n$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n然后来安装node.js的包管理器nvm:\n$ nvm install 0.12 #目前官方最新版是0.12.X,按照实际情况修改\n安装完npm后，测试一下是否存在：\n$ npm -v\n3. 安装并初始化Hexo 安装完node.js跟git后，使用npm安装将要使用的Hexo：\n$ npm install hexo -g\n当安装完Hexo后在自己本地创建一个目录，在目录内运行：\n$ hexo init\n运行：\n$ hexo server或者hexo s\n就可以在本地http://localhost:4000/上看到效果了\n接下来的操作可以自行官网学习（写文章时，如果不想博文在首页全部显示, 并能出现阅读全文按钮效果, 记得在你想在首页显示的部分下添加\u0026rsquo;\u0026lt;!\u0026ndash;more\u0026ndash;\u0026gt;'），下面说一说配置。\n配置_config.yml 当初始化完成hexo之后，需要修改目录下的**_config.yml**文件下的**deploy**项：\ndeploy: type: git repo: git@github.com:github用户名/创建仓库.git.io.git #就是部署仓库的SSH,当然要记得上传ssh公钥到github啦。 branch: master message: 随便写 教程初步完成，现在应该能够在github上看到自己的博客啦。ps：换个好看好玩的主题吧，慢慢玩！\n","description":"","id":18,"section":"posts","tags":["Ubuntu","Hexo"],"title":"ubuntu下搭建Hexo博客","uri":"https://jmwill.github.io/blog/2015/03/17/ubuntu%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"},{"content":"初步接触记录1： 建立一个项目：  在需要储存代码的目录内运行以下命令：django-admin.py startproject your_porject_name，会生成以下目录结构：  your_porject_name/ manage.py your_porject_name/ __init__.py settings.py urls.py wsgi.py 其中最外层的根目录是项目所在的位置，允许任意更改 manage.py是一个命令行工具，用于管理django项目 内层的应用目录是项目里的一个python包。 setting.py是Django项目的配置文件。 urls.py是Django项目的URL声明  安装数据库：根据使用的不同的数据库在setting.py内的ENGINE项内填入相应的值，以及数据库所需要的option值 运行python manage.py migrate在数据库中建立应用所需的相应的表。（注：在运行命令之前可以在setting内的INSTALLED_APPS中决定使用哪些应用 开发所使用的服务器：运行python manage.py runserver命令来运行开发所使用的服务器。（注：可在其后接端口或ip地址加端口。如：8080， 0.0.0.0：8000）  创建模型：  在与manage.py相同的目录下：运行python manage.py startapp your_app_name，会生成以下目录结构：  polls/ __init__.py admin.py migrations/ __init__.py models.py tests.py views.py  根据开发习惯，一般会先开发models部分，开发完后再进行后续的视图和控制器的开发工作  激活模型：  在进行模型激活前，需要先在setting的INSTALLED_APPS中加入需要激活的应用的名称。（注：应用在项目目录下无需在项目前加入包名等，直接填入应用名称） 包含应用后可以使用命令：python manage.py makemigrations your_app_name，将对模型的更改存储为迁移文件，可以通过查看app_path/migrations/0001_initial.py文件来查看 想要查看迁移行为会执行那些sql语句可以运行命令：python manage.py sqlmigrate app_name 0001 最后通过运行：python manage.py migrate来修改数据库  使用API  在Django中可以使用python manage.py shell的交互式命令行，因为manage.py里面设置了DJANGO_SETTINGS_MODULE环境变量，这个变量给定了Django需要导入的app_name/settings.py文件所在的路径。 在交互式命令行中可以对数据库等进行探索，操作。  首先，需要导入所用的类from app_name.models import model_one, model_two 查看系统拥有的对象model_one.objects.all() 在系统中创建使用的对象instance = model_one(...) 保存对象instance.save() 其他操作   查看对象的时候model_one.objects.all()返回的是没有意义的表达式，可以通过在模型中添加方法来解决。  class OwnClass(models.Model): # ... def __str__(self): # 在Python 2中使用__unicode__ return self.some_text  Django中添加自定义方法：直接在类中添加函数并传入：self 就可以  小认识  在Django中创建项目，默认的时区时UTC，想要正确显示本地时间，需要修改setting.py文件内的TIME_ZONE为Asia/Shanghai  初步接触记录2 创建管理员账户  在项目目录下运行python manage.py createsuperuser来创建管理员账户，按照提示填入信息。运行开发服务器后就可以在这里看到登录界面  编辑管理站点  想要在管理站点中编辑应用的数据，就需要在应用的admin.py文件中进行注册登记。   from django.contrib import admin from yourapp.models import MODEL admin.site.register(MLDEL)  注册后的应用还应该在settion.py中被包含，这样就可以在管理站点中看到MODEL的出现，并且可以对其进行编辑了。 在注册后可以看到，MODEL可以进行一般的编辑。通过在admin.py中加入自定义控制类可以自定义管理界面中的对象表单。   from django.contrib import admin from yourapp.models import MODEL class.MODELAdmin(admin.ModelAdmin): fields = ['your_field1', 'your_field2'] admin.site.register(MODEL, MODELAdmin)  分割字段：对象表单的修改还可以进行字段分割使得页面以你的方式来显示   class MODELAdmin(admin.ModelAdmin): fieldsets = [ (None, {'fields': ['your_field1']}), ('information text', {'fields': ['your_field2']}), ]  想要使得字段集能够折叠，可以在feilds添加后再加入一个'classes':['collapse']到字典中去。 添加关联对象：像具有ForeignKey类型的字段在管理界面中会被显示为一个select框，就像一个问题会有多个选择一样，如果每个选择都要手动选择所属的问题的话，无形中增加了工作量，因此，在这里使用关联对象就能够使得添加更为方便。   from django.contrib import admin from yourapp.models import MODEL1, MODEL2 class MODEL2Inline(admin.StackedInline): #TabularInline为紧缩排列 model = Choice extra = 3 #初始选项字段空间 class MODEL1Admin(admin.ModelAdmin): fieldsets = [ (None, {'fields': ['feild1']}), ('Date information', {'fields': ['field2'], 'classes': ['collapse']}), ] inlines = [MODEL2Inline] admin.site.register(MODEL1, MODEL1Admin) #如上就是MODEL2的外键为MODEL1，因此进行关联后，在管理MODEL1的时候就可以直接进行MODEL2的创建了。  Djangoadmin中默认显示对象str()函数返回的内容，可以在admin.py使用list_display变量来实现这个功能，其接收一个包含显示字段名（或自定义方法）的元组，字段名将作为变更列表的列名出现list_display = ('field1', 'field2', 'method')。添加list_filter和search_fields属性能够增加“过滤器”侧边栏和搜索框。对模板中的方法进行属性的修改能够修改显示样式：`method.admin_order_field = \u0026lsquo;one_field\u0026rsquo; 自定义管理站点外观：想要自定义项目的管理站点的外观可以建立一个templates文件夹。然后修改或添加setting.py中的TEMPLATE_DIRS=[os.path.join(BASE_DIR, 'templates)] TEMPLATE_DIRS是一个包含文件系统路径的可迭代对象。当Django载入模板的时候会对它进行检查；它包含了搜索路径,然后复制Django源码中管理站点的模板目录（django/contrib/admin/templates）到templates中 如果找不到Django源码可以运行以下程序：   python -c \u0026quot; import sys sys.path = sys.path[1:] import django print(django.__path__)\u0026quot; 初步接触记录3 注，由于解析的问题，%与} 前的\\无实际意义，实际上不存在,要去掉\n Django页面内容需要由视图负责生成，一般情况下，视图处理函数放在view.py文件内处理。然后在应用目录内创建一个urls.py文件，来编写url匹配模式。如下：   from django.conf.urls import patterns, url from polls import views urlpatterns = patterns('', # 例如：/appName/ url(r'^$', views.index, name='index'), # 例如：/appName/5/ url(r'^(?P\u0026lt;question_id\u0026gt;\\d+)/$', views.detail, name='detail'), # 例如：/appName/5/results/ url(r'^(?P\u0026lt;question_id\u0026gt;\\d+)/results/$', views.results, name='results'), # 例如：/appName/5/vote/ url(r'^(?P\u0026lt;question_id\u0026gt;\\d+)/vote/$', views.vote, name='vote'), ) #里面\u0026quot;?P\u0026lt;question_id\u0026gt;\u0026quot;定义了所“捕获”的字符串的名字  下一步让主URLconf，加入url(r'^appName/', include('appName.urls')),，regex的最后使用的是一个**/**，没有使用**$**作为结尾，原因是调用include()时，之前匹配到的字符串去掉，剩下的部分交给include()指定的URLconf处理。 url()可以传递4个参数，其中regex和view是必须的。regex就是匹配url的正则表达式。而view则是在匹配到请求的url时调用给定的视图函数，并传递HttpRequest对象作为视图的第一个参数，正则捕获的所有值作为视图函数的其他参数，如果正则表达式是用最简单的捕获方式捕获的值，这些值将按照捕获位置的前后顺序，被代入函数；如果正则表达式在捕获参数时，命名了这些参数，那么这些参数将以关键字参数的形式被代入函数。 在Django中，每个视图函数只负责处理两件事中的一件：返回一个包含所请求界面内容的HttpResponse对象，或者引发一个诸如Http404的异常。 想要使用模板系统，而又不增加应用的耦合度，最好是在应用目录下创建一个templates的文件夹，在templates内再创建一个应用文件夹appName/在appName/里面就可以创建我们自己的模板文件了。在templates内再创建一个与应用同名的文件夹是因为Django无法区分不同的应用中存在着拥有相同名字的模板文件，这样，我们就可以使用命名空间来区分，也就是将这些模板文件放在以应用的名字来命名的另一个文件夹下。 Django中最普通的处理方法是载入一个模板文件，然后填充一个上下文变量，接着返回一个含有模板渲染结果的HttpResponse对象。但是可以使用Django提供的快捷方式，render()函数   #原方法 from django.http import HttpResponse from django.template import RequestContext, loader from appName.models import Question def index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] template = loader.get_template('polls/index.html') context = RequestContext(request, { 'latest_question_list': latest_question_list, }) return HttpResponse(template.render(context)) #现方法 from django.shortcuts import render from appName.models import Question def index(request): latest_question_list = Question.objects.all().order_by('-pub_date')[:5] context = {'latest_question_list': latest_question_list} return render(request, 'polls/index.html', context)  在显示页面时会遇到无法在数据库中找到相关索引的情况。在这个时候我们需要引发一个404页面。   #通常做法 from django.http import Http404 from django.shortcuts import render from polls.models import Question # ... def detail(request, question_id): try: question = Question.objects.get(pk=question_id) except Question.DoesNotExist: raise Http404 return render(request, 'polls/detail.html', {'question': question}) #Django快捷方式“get_object_or_404()”还有“get_list_or_404()” from django.shortcuts import get_object_or_404, render from polls.models import Question # ... def detail(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/detail.html', {'question': question}) #传递了question对象到模板的上下文变量中。  在上面的演示代码中可以看到question变量被传递到了模板中，因此在模板中就可以使用这一个，对象进行操作。   \u0026lt;h1\u0026gt;{{ question.question_text }}\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; \\{\\% for choice in question.choice_set.all \\%\\} \u0026lt;li\u0026gt;{{ choice.choice_text }}\u0026lt;/li\u0026gt; \\{\\% endfor \\%\\} \u0026lt;/ul\u0026gt; \u0026lt;!-- 在\\{\\% for \\%\\}循环中出现了方法调用：question.choice_set.all被解释成了Python代码question.choice_set.all()，它返回了一组可迭代的Choice对象。这组对象可以在\\{\\% for \\%\\}标签中使用。 --\u0026gt;  在模板中写a链接时，尽量不要把硬链接写在里面，而可以使用在appName.urls模块的url()函数中定义了的name参数，在模板的URL配置中可以通过使用\\{\\% url \\%\\}模板标签来移除对于特定的URL路径的依赖，\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\\{\\% url 'detail' question.id \\%\\}\u0026quot;\u0026gt;{{ question.question_text }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; 假如在真实的项目中有许多的应用，当在应用中出现重名的视图时，模板中的\\{\\% url \\%\\}将需要另外一些改动才能够正确使用   #在主URLconf下添加命名空间。 from django.conf.urls import patterns, include, url from django.contrib import admin urlpatterns = patterns('', url(r'^polls/', include('polls.urls', namespace=\u0026quot;polls\u0026quot;)), url(r'^admin/', include(admin.site.urls)), )  #视图链接从 \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\\{\\% url 'detail' question.id \\%\\}\u0026quot;\u0026gt;{{ question.question_text }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; #改成 \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\\{\\% url 'polls:detail' question.id \\%\\}\u0026quot;\u0026gt;{{ question.question_text }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; 初步接触记录4 在后台开发中，表单无疑是在开发中占据了较大比重的一项。因此Django提供了许多好用的api来供我们使用。但是我们也需要遵守一些约定俗成的规则\n 无论何时，当需要创建一个可以改变服务器端数据的表单时，请使用method=\u0026quot;post\u0026rdquo;。 为了防止跨站点请求伪造，在所有针对内部URL的POST表单中添加\\{\\% csrf_token \\%\\}模板标签。 进行服务器端数据修改后，一般使用一个HttpResponseRedirect对象，将重定向到指定的URL，在构造HttpResponseRedirect对象的参数时，使用reverse()函数。这个函数可以帮助我们避免在视图中出现硬编码的URL。它需要给出想要跳转的视图的名字和该视图所对应的URL模式中需要给该视图提供的参数。 使用通用视图：根据URL中的参数从数据库中获取数据，载入模板文件，返回渲染之后的模板。这是一种特别常见的情况，因此Django提供了一种快捷方式，叫做“通用视图”系统。   #appName/urls.py文件 from django.conf.urls import patterns, url from polls import views urlpatterns = patterns('', url(r'^$', views.IndexView.as_view(), name='index'), url(r'^(?P\u0026lt;pk\u0026gt;\\d+)/$', views.DetailView.as_view(), name='detail'), url(r'^(?P\u0026lt;pk\u0026gt;\\d+)/results/$', views.ResultsView.as_view(), name='results'), url(r'^(?P\u0026lt;question_id\u0026gt;\\d+)/vote/$', views.vote, name='vote'), ) #appName/views.py文件 from django.shortcuts import get_object_or_404, render from django.http import HttpResponseRedirect from django.core.urlresolvers import reverse from django.views import generic from polls.models import Choice, Question class IndexView(generic.ListView): template_name = 'polls/index.html' context_object_name = 'latest_question_list' def get_queryset(self): \u0026quot;\u0026quot;\u0026quot;返回最新发布的五个议题。\u0026quot;\u0026quot;\u0026quot; return Question.objects.order_by('-pub_date')[:5] class DetailView(generic.DetailView): model = Question template_name = 'polls/detail.html' class ResultsView(generic.DetailView): model = Question template_name = 'polls/results.html' #这里使用了两个通用视图：ListView和DetailView。这两个视图可用于显示两种抽象概念，分别为“显示一列对象列表”和“显示一个特定类型的对象的详细信息页”。 #每一个视图需要知道它将作用于什么模型。这个信息是由视图类里的model属性来提供的。 #通用视图DetailView期望从URL中捕获名为\u0026quot;pk\u0026quot;的主键值 #默认地，通用视图DetailView会使用名称为\u0026lt;应用名\u0026gt;/\u0026lt;模型名\u0026gt;_detail.html的模板。在我们的例子中，它将使用\u0026quot;polls/question_detail.html\u0026quot;这个模板。template_name属性是用来告诉Django，我们需要为要使用的模板指定一个名称，来替代默认生成的名称。同时，这确保结果视图和细节视图即使都有一个DetailView隐藏在幕后，在渲染后也会拥有不同的外观。 #在视图DetailView中，question变量是被默认提供的－由于我们使用了一个Django模型（Question），Django能够为上下文变量提供一个合适的名字。然而，对于ListView来说，自动生成的上下文变量的名字为question_list。我们可以使用context_object_name属性来重写这个名字， 初步接触记录5  在开发Django应用的时候，我们需要引入自动化测试。这样做能够使我们在开发的过程中，避免繁重的手动测试工作。同时，测试可以划分为不同的级别，或专注于小细节等等。这样做在开发的时候便能够使得应用出错较少。向着我们想要的方向发展。 创建测试来暴露漏洞。应用程序的测试文本一般放在test.py文件中，测试系统会自动在任何以test开头的文件中查找测试文本。文本内容例子：   import datetime from django.utils import timezone from django.test import TestCase #创建测试需要用到 from appName.models import MODEL class MODELMethodTests(TestCase): #创建测试类 def test_method(self): #创建测试方法，需要以**test**开头 \u0026quot;\u0026quot;\u0026quot; 描述 \u0026quot;\u0026quot;\u0026quot; time = timezone.now() + datetime.timedelta(days=30) future_question = Question(pub_date=time) self.assertEqual(future_question.was_published_recently(), False) #测试返回值与期待值是否吻合   在编写完测试代码后，运行测试python manage.py test appName。\n 其中测试系统在polls应用中查找测试。 发现django.test.TestCase的子类。 创建特定数据库 查找用于测试的方法-以test开头 执行方法    在测试时，我们可以编写多个方法来进行测试。测试系统会一一帮我们进行方法的调用，免却我们自己手动测试bug的麻烦。\n  Django测试客户端：Django提供了一个测试客户端来模拟用户和代码的交互。需要在test.py中引入from django.test import Client\n  在Django中测试越多越好，最好写一个测试一次，因为测试程序不像应用程序代码，在测试代码中，当应用有所修改而测试代码已经不适用的时候我们可以直接删除，而当应用并没有修改的时候，先前编写的测试代码并不会对我们有任何影响，可以一直存在。但是还是需要遵守一些点：\n 为每个模型或者视图建立一个单独的TestClass类 为你想测试的每一种情况建立一个单独的测试方法 在测试方法的名字中指明他们的作用    ","description":"","id":19,"section":"posts","tags":["笔记","Python","Django"],"title":"Django学习笔记","uri":"https://jmwill.github.io/blog/2015/03/16/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"content":"入门所学知识：  python中print的方法跟c语言的基本一样，同样可以使用print 'output %s, something %s.' %(temp1, temp2) raw字符串与多行字符串：r'...'免于对字符串使用转义符，但是无法表示多行字符，以及包含**’**和**“**的字符串， 可以使用r\u0026rsquo;'\u0026rsquo;\u0026hellip;\u0026lsquo;\u0026lsquo;\u0026lsquo;来表示多行字符串 unicode字符串：在字符串前加u字符，当出现中文编码错误的时候可以在文件第一行添加注释 # -*- coding: utf-8 -*- python中的与运算，或运算，非运算使用的分别时and， or， not关键字来实现  python中对于list可以使用负下标来倒序访问 python中的tuple数据结构，类似于list，但是，一旦定义，里面的元素无法修改，因此list的修改方法在tuple上无法使用（注：单元素的tuple中要在元素后添加一个，，若tuple内的元素本身是可变的，则元素可以变动。） python中需要算出集合的大小可以使用**len()**来得出，如:len(list) len()... python中想要安全获取dict的值可以：  if 'Paul' in d: print d['Paul'] 或者使用dict本身的get方法，当key不存在时返回None d.get('key') python中遍历dist使用for in循环：for key in dict:... set在python中称作集合，里面的元素没有重复，而且是无序的。（无法存储可变对象），可用add()方法来添加元素，用remove()来移除元素，但是使用remove时需要判断元素是否在set里面,防止报错。 python中函数可以返回多个值（实质是返回一个tuple），可以用多个变量同时接收一个tuple来对应赋值。 python中定义可变参数：def fn(*args): ...传入的参数就相当于一个tuple python切片操作：L[start🔚step] #L[:] 相当于将list复制一遍(start与end使用负数则是倒序切片，切片操作可以使用在字符串上） python中使用for in迭代取出的就是元素本身，而非元素的索引。当确实想要在for循环中取到索引可以使用enumerate()函数：for index, value in enumerate(L): ... dict的value迭代：for v in d.values():或者for v in itervalues():前者会把dict的alue取出转化成一个list，后者直接从dict中取出value，节省了生成list的内存 dict默认迭代key，也可以使用keys(), iterkeys(),而想要同时迭代dict的key，和value的话，可以使用for k, v in d.items():或者for k, v in d,iteritems(): python中的列表生成式：[x * x for x in range(num, tonum)]在其中for之前的是操作，后面就是迭代出操作元素  同时python中可以使用复杂的列表生成式来进行快速操作，如： result = ['sentences %s , and %s' % (value1, value2) for value1, value2 in dict.iteritems()] 上面就生成了一个存储了len(dict)个句子的列表 在进行列表生成式的使用的时候，还可以在for后加入条件过滤，如[x * x for x in range(11) if x % 2 == 0 and x / 3 != 0] 列表生成式的内部还可以使用多层for循环来生成列表，如：[m + n for m in range(11) for n in range(10)]  Python进阶所学知识 Python函数式编程   高阶函数\n 高阶函数指的是可以把函数作为参数来接收的函数；能在高阶函数内被调用    Python内置高阶函数\n   **map()**函数，map函数能将一个list转换为另外一个list并返回，但不改变原list def f(x): return x * x print map(f, [1,2,3,4,5,6]) 输出结果为`[1,4,9,16,25,36]`    **reduce()**函数，传入的函数f必须接收两个参数，reduce对list的每个元素反复调用函数f，并返回最终值。reduce还可以接收第3个可选参数，作为计算的初始值 def f(x, y): return x * y print reduce(f, [1,2,3,4,5,6]) 输出结果为`720`    **filter()**函数，对每个元素进行判断返回True或False，根据判断结果自动过滤掉不符合条件的元素，返回由符合条件的元素组成的list def isNum(x): return True if type(x) == int else False print filter(isNum, [1,2,3,4,'abc', 'name',5,6]) 输出结果为`[1,2,3,4,5,6]`    **sort()**排序函数，向sort函数提供一个函数用以返回0， 1， -1等相对应的排序所需值就可以建立不同的排序规则。 def reversedCmp(x, y): if x \u0026gt; y: return -1 if x \u0026lt; y: return 1 return 0 sorted([23, 6, 11, 9, 21], reversedCmp) 结果[23, 21, 11, 9, 6]    闭包：内层函数引用了外层函数的变量（参数），然后返回内层函数的情况。闭包的特点是返回的函数还引用了外层函数的局部变量，因此，要正确地使用闭包就要确保局部变量在函数返回后不能变 def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fs f1, f2, f3 = count() print f1(), f2(), f3() 结果 9 9 9 下面例子避免了上例的情况 def count(): fs = [] for i in range(1, 4): def f(j): def temp(): return j * j return temp r = f(i) fs.append(r) return fs f1, f2, f3 = count() print f1(), f2(), f3() 结果 1 4 9    匿名函数：使用关键字**lambda**冒号前的表示参数,只能有一个表达式，返回值就是表达式的结果 map(lambda x: x * x, [1,2,3,4,5,6]) 结果[1,4,9,16,25,36]    装饰器函数 接收函数作为参数，然后返回一个新函数的高阶函数，而带参的装饰器就相当于多了一层调用。多用一层函数包裹就能够达到效果，经装饰器修改后的函数，因为其经过赋值，所以函数名等会有所改变，想要修复这个改变，可以使用**functools**模块来进行修复。 def log(f): def fn(*args, **kw): print 'call ' + f.__name__ + '()...' return f(*args, **kw) return fn @log def foo(n): print n foo('haha') 修复 import functools def log(f): @functools.wraps(f) def fn(*args, **kw): print 'call ' + f.__name__ + '()...' return f(*args, **kw) return fn @log def foo(n): print n foo('haha')    偏函数：通过使用**functools**的partical函数可以帮我们创建一个偏函数，使得调用函数变得简单 import functools int2 = functools.partical(int, base=2) #通过重新指定默认值来得出一个新的函数同时不影响原函数 int2('100000000') 结果：256     模块和包\n Python中模块和包其实就是：模块是一个.py的文件，而包一定是包含有__init__.py（用于区分python包文件夹和普通文件夹的依据）的文件夹   动态导入模块 try: import json except ImportError: import simplejson as json print json.dumps({'python':2.7})  使用__future__：通过导入此模块，可以用来试用一些新的特性from __future__ import feature    Python面向对象编程  定义类   按照编程习惯，类名以大写字母开头，而后传入继承类（object为原始类）\n   python中使用`__init__()`函数来初始化属性，例子： __init__()方法的第一个参数必须是self(习惯命名) class Person(object): def __init__(self, name, gender, birthday): self.name = name self.gender = gender self.birth = birthday   访问限制： 如果一个属性由双下划线开头（__）则属性无法被外部访问。\n  创建类属性：在类上绑定的属性，所有的实例都可以访问，而且类属性有且只有一份\n  当类属性与实例属性冲突时，实例属性优先级更高\n  定义实例方法：实例的方法就是在类中定义的函数，它的第一个参数永远是 self，指向调用该方法的实例本身，其他参数和一个普通函数是完全一样。\n   定义类方法（因为是在类上调用，而非实例上调用，因此类方法无法获得任何实例变量，只能获得类的引用。） 定义类方法需要标记一个@classmathod，传入的参数为类本身 class Person(object): count = 0 @classmethod def how_many(cls): return cls.count def __init__(self, name): self.name = name Person.count = Person.count + 1   继承一个类，在继承类的时候， 需要在__init__()里面使用初始化父类的super方法super(child, self).__init__(personNeedName, personNeedattr...)，否则子类会没有父类的属性，当使用原始类object时，不需要使用super方法。\n  判断类型：函数**isinstance()**可以判断一个变量的类型。返回布尔值。isinstance(ownInstance, class)\n  多态：类具有继承关系，子类型可以向上转型看作父类类型。因此方法的调用作用在x的实际类型上，当子类型中具有与父类型一样的方法时会优先使用自身定义的方法，没有方法则向上沿继承链查找，直到在某个父类中找到相应方法。\n   多重继承：多重继承的目的是从两种继承树中分别选择并继承出子类，以便组合功能的使用 class A(object): def __init__(self, a): print 'init A...' self.a = a class B(A): def __init__(self, a): super(B, self).__init__(a) print 'init B...' class C(A): def __init__(self, a): super(C, self).__init__(a) print 'init C...' class D(B, C): def __init__(self, a): super(D, self).__init__(a) print 'init D...'   获取对象信息：\n type(ownInstance)：type函数获取变量类型，返回一个type对象 dir(ownInstance)：dir函数获取变量的所有属性 getattr(ownInstance, attr)和setattr(ownInstance)：适用于已知一个属性名，要获取或设置对象的属性，（注：getattr在获取不存在的属性的时候会报错，所以可以使用第三个参数，在属性不存在的时候返回默认值：getattr(onwInstance, 'name', 'people')，name不存在时返回people。     ","description":"","id":20,"section":"posts","tags":["笔记","Python"],"title":"Python学习笔记","uri":"https://jmwill.github.io/blog/2015/03/16/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"content":"javascript中存在着很多糟糕的特性：全局变量的轻易添加，无块级作用域，== 判断的不精确性等等，\n但是它同时也具有许多精华的特性，对象字面量生成，函数字面量生成，使用原型继承的机制。\njavascript是不是一门备受误解的语言我不知道，但是我知道，javascript能够生存至今一定是有它的理由所在的，至少，在我认识的javascripter中，也是有着很厉害，能够驾驭这门相对奇特的语言的人的。\n语法 javascript的语法没有什么好说的，几乎与其他的编程语言没有太大的区别。\n但是有几点需要注意：\n 在每一个需要用到块级作用域的地方 ** { **都需要跟在语句的后面，不应进行换行。如：  var foo = function() { //do somthing; } ----------------------------------------- var i for (i = 0, i \u0026lt; list.length; i++) { //do somthing }  由于javascript没有块级作用域，同时，又会对变量声明，函数声明等进行提升。所以在定义变量的时候不要在使用时才进行定义，最好在函数体的顶部中声明函数中可能用到的所有变量。如：  function foo() { var i, j, mublock; var mydiv, myHeader ...; //do somthing } //同时请记住一点，对于函数字面量的函数定义，函数是不会被提升的如： a(); //会报错说没有定义这个函数 var a = function() { console.log('a'); } //而对于这样的形式，却是可以的： a(); function a() { consoel.log('a'); } 对象  在js里面，参数传递都是按值传递的。只是对于基本数据类型，它是传递变量保存的具体值，而对于引用类型的变量，它传递的就是变量保存的引用类型的引用值，所以会看似在进行引用传递. 如：  var a = 'abc'; function b(a){ a = a + 'b'; console.log(a); } b(a); //结果：abcb console.log(a); //结果abc var a = {} function b(a){ a.isin = 'function b'; console.log(a.isin); } b(a); //结果function b console.log(a.isin); //结果function b //假如进行这样的操作： function b(obj) { obj.name = 'outName'; obj = new Object(); obj.name = 'innerName'; } var a = new Object(); a.name = 'globalName'; console.log(a.name); //输出globalName b(a); console.log(a.name); //输出outNmae //实际上，obj保存的引用值在b的内部已经被替换成另一个对象的引用值了。 附： 基本变量类型\n   类型 可能的值     Undefined 只有undefined   Null 只有null   Boolean true 和 false   Number 整数或者浮点数   String 任何字符串     js中遍历对象可以使用 for in 来进行，但是，在对象中是以键值的方式来存储，所以，在遍历的时候属性名的出现顺序是不确定的。想要确保属性名以特定顺序出现，可以使用for 循环和一个包含想要遍历属性的数组来进行遍历，如：  //摘抄自《javascript语言精粹》p24, 略作修改 var i; var properties = [ 'first-name', 'middle-name', 'last-name', 'profession', }; for (i = 0; i \u0026lt; properties.lenght; i += 1) { console.log(properties[i] + ': ' + obj[properties[i]]); }  全局变量污染，在js中，全局变量十分容易创建，但是全局变量，在绝大多数情况下都是不推荐使用的。所以，我们应该在js中减少全局变量的污染。在《javascript语言精粹》中建议最小化使用全局变量的方法是只创建唯一的全局变量：  var MYAPP = {}; //让变量MYAPP变成专有容器 MYAPP.stooge = { \u0026quot;first-name\u0026quot;: \u0026quot;fname\u0026quot;, \u0026quot;last-name\u0026quot;: \u0026quot;lname\u0026quot;,, }; MYAPP.flight = { airline: \u0026quot;China\u0026quot;, ... }; 附：操作符\njs具有以下几个操作符：var, in, delete, typeof, new, instanceof, void,下面进行简单介绍：\n var 用于定义变量 in 可以单独使用（用于访问对象属性），或者用于for in循环中 delete 删除对象属性或者数组元素 (但是函数内的参数无法删除）， 删除数组时会留下孔洞，一般不进行这样的删除操作，而是使用数组的pop,shift等方法。 typeof 检查变量的类型，返回值有： 5个基本变量类型中的4个（null属于object），和两个对象类型object，function new 用于创建实例，使用new调用构造函数时经历的4步：  创建一个新对象 将构造函数的作用域赋给新对象（因此this就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象   instanceof 用于确定对象的类型：如果instanceof左侧的对象是其右侧类型的实例(这个判断也会包括对“父类”的检测)，那么instanceof操作符就会返回true。 void 操作数可以是任何数值，其返回值一直时undefined  函数  js中当函数作为一个对象的方法来调用的时候，this值会绑定到对象上。但是当函数被直接调用的时候，this被错误地绑定到了全局对象上。想要修复这个问题，可以在方法内部创建变量并赋值为this使得内部函数能够通过这个变量来使用正确的this值，如：  myObject.double = function() { var that = this; //保存指向myObject的this值到that身上 var helper = function() { that.value = add(that.value, that.value); }; helper(); };  Apply调用模式  apply方法可以允许我们传递this值还有参数给一个调用函数，因此可以使得对象也能够调用本不属于它的函数， 方法。如：  var status = Quo.prototypr.get_status.apply(statusObject);//statusObject就调用了本来属于Quo的get_status方法     向Funciton.prototype增加method方法, 使得向对象增加方法的时候更加容易  Funciton.prototype.method = function (name, func) { if (!this.prototypr[name]) { this.prototype[name] = func; } return this; };  使用闭包  使用闭包能够进行变量，方法的保护等。如变量的保护：    //这个方式使得myObject对象外的函数或者对象都无发访问到值value var myObject = (function() { var value = 0; return { increment: function (inc) { value += typeof inc === 'number' ? inc : 1; }, getValue: function() { return value; } }; }()); /*在使用此类方式的时候需要记得内部函数访问外部对象方法，或者函数时。访问到的变量是变量的本身，因此，一旦变量有什么变化，内部函数访问到的都是变化后的变量，除非将变量进行一遍复制（注：对引用变量不起作用），如：*/ var foo = function(value) { var helper = function(i) { return function(e) { alert(i) // 使用外部函数传入的参数，也就是进行了值复制后的变量 }; }; var i; for (i = 0; i \u0026lt; value.length; i++) { //do something } }; /*在编程的过程当中，应当避免在循环中创建函数  模块  模块的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；而后返回特权函数或将其保存在可以访问到的地方。 模块模式也可以用于创建安全的对象。   级联  让对象的方法返回this，而非undefined可以启用级联。参考jquery的链式调用    继承  基于原型的继承  首先创建一个有用的对象。 使用Object.create方法 构造出实例。 定制创建出来的新的实例，如添加属性，方法等   函数化  实现函数化构造器  创建一个新对象（对象字面量，使用new调用构造器函数，使用Object.create,或者调用会返回对象的函数 有选择地定义私有实例变量和方法。就是在函数中通过var语句定义的普通变量 给新对象扩充方法。方法可以拥有特权访问参数，以及第二步中定义的变量 返回新对象。      函数化构造器伪代码\nvar constructor = function(spec, my) { var that, 其他私有实例变量； my = my || {}; 把共享的变量和函数添加到my中 that = 一个新对象 添加给that的特权方法 return that; }; //js继承函数化实现示例 var mammal = function(spec) { var that = {}; that.get_name = function() { return spec.name; }; that.says = function() { return spec.saying || ''; }; return that; }; var myMammal = mammal({name: 'Herb'}); myMammal.name = 'Kitty'; myMammal.get_name = function() { var that = this; return this.name; }; var cat = function(spec) { spec.saying = spec.saying || 'meow'; var that = mammal(spec); that.purr = function(n) { var i, s = ''; for (i = 0; i \u0026lt; n; i += 1) { if (s) { s += '-'; } s += 'r'; } return s; }; that.get_name = function() { return that.says() + ' ' + spec.name + ' ' + that.says(); }; return that; }; var myCat = cat({name: 'Henrietta'}); Object.method('')  部件这一章，尚未理解！  数组  js中判断对象是否为数组的方法：   //判断一个对象是否为数组 var is_array = function(value) { return Object.prototype.toString.apply(value) === '[object Array]'; }  对数组方法的一些补充：  方法   数组方法汇总：\n array.concat(item\u0026hellip;.) //返回拼接数组 array.join(separator) //返回一个用separator作为分隔的字符串 array.pop() //删除数组最有一个元素，返回被删除元素，或undefined array.push(item\u0026hellip;) //从后向数组添加元素，并返回数组长度 array.reverse() //翻转数组本身内容，并数组 array.shift() //将数组从前删除，返回结果同pop array.unshift(item\u0026hellip;) //向数组起始位置添加元素，返回新的length array.sort(comparefn) //对array内容进行排序，默认把元素当作字符串来对待，可传入处理函数调整排序方式 array.slice, array.splice如下解释    分清array里的splice方法和slice方法\n  array.slice(start, [end]); //作用是对array中的一段做浅复制 array.splice(start, deleteCount, item...); //从array中删除一个或多个元素并用item替换它们。start为起始下标。方法返回包含被移除元素的数组  array的sort方法补充：  //sort内的数字排序函数实现 var n = [4, 5, 6, 29, 50]; n.sort(function(a, b) { return a - b; }); //sort实现字符串排序的函数 var m = ['aa', 'bb', 'c', 'a', 4, 59]; m.sort(function(a, b) { if (a === b) { return 0; } if (typeof a === typeof b) { return a \u0026lt; b ? -1 : 1; } return typeof a \u0026lt; typeof b ? -1 : 1; }); //sort的函数排序实现 var by = function(name) { return function(o, p) { var a, b; if (typeof o === 'object' \u0026amp;\u0026amp; typeof p === 'object' \u0026amp;\u0026amp; o \u0026amp;\u0026amp; p) { a = o[name]; b = p[name]; if (a === b) { return 0; } if (typeof a === typeof b) { return a \u0026lt; b ? -1 : 1; } return typeof a \u0026lt; typeof b ? -1 : 1; } else { throw { name: 'Error', message: 'Expected an object when sorting by ' + name }; } }; };  数字方法 （注意，不能直接对数字123等进行下列操作。如123.toFixed()）  number.toExponential(fractionDigits); //将number转换成一个指数形式的字符串。可选参数fractionDigits控制其小数点后的数字位数。值必须在0～20 number.toFixed(fractionDigits); //转换成为一个十进制数形式的字符串，参数控制其小数点后数字位数。0～20 number.toPrecision(precision); //将number转换成为一个十进制形式的字符串，参数控制数字精度。0～21 number.toString(radix); //将number转换为一个字符串。参数控制基数。2～36 默认为10`进制转换中可使用   ","description":"","id":21,"section":"posts","tags":["笔记","javascript"],"title":"《javascript语言精粹》记录","uri":"https://jmwill.github.io/blog/2015/03/16/javascript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%E8%AE%B0%E5%BD%95/"},{"content":"近来，因为现实原因，经常处于断网的状态（掩面T_T），所以就突发奇想在本地建立个仓库存储自己的代码，手贱的时候也可以有后悔药吃。不多说，上流程\n建立本地裸仓库 在本地建立一个裸仓库（抱歉，还不明白什么是裸仓库后续补上解释）。\n #在本地建立一个空文件夹 mkdir -p storage.git #文件夹名字可以任取 cd storage.git git init --bare #初始化裸仓库 这样就建立好了一个存储代码或者任意你喜欢的东西的仓库了。\n建立代码仓库  mkdir code_test #存放自己编写的代码的文件夹 cd code_test git init git clone ~/your_path/storage.git 链接本地存储仓库  #链接本地仓库，可以使用push origin master git remote add origin ~/your_path/storage # origin可以使用其他你喜欢的名字 测试\u0026amp;脚本助手  #现在已经可以使用仓库来存储代码 #首先创建一个测试文件 vim testfile #输入你想写的 git add . git push origin master 看是否有错误产生 下面来编写一个自己的脚本来进行日常提交\nvim .push\n输入下面的代码\n git pull origin master git add . if [ $# -gt 0 ] then mycommit=\u0026quot;\u0026quot; for arg in $@ do mycommit=\u0026quot;$mycommit $arg\u0026quot; done else mycommit=\u0026quot;auto commit\u0026quot; fi git commit -am \u0026quot;$mycommit\u0026quot; git push origin master 保存后就拥有了简单的shell脚本，能够辅助提交同时支持自带评论。（记得要提供执行权限chmod +x .push)\n结语 这次实现了本地仓库存储代码，能够在断网的状态下也可以进行代码的版本控制，顺带熟悉了一遍git的使用。\n","description":"","id":22,"section":"posts","tags":["笔记","Git"],"title":"git建立本地仓库","uri":"https://jmwill.github.io/blog/2015/03/16/git%E5%BB%BA%E7%AB%8B%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/"}]